[[keys_addresses]]
== Криптография

((("cryptography", id="ix_04keys-addresses-asciidoc0", range="startofrange")))Одной из основополагающих технологий Ethereum является ((("cryptography","defined"))) _крипторафия_ (_cryptography_), которая является разделом математики, широко используемым в компьютерной безопасности. Криптография в переводе с греческого означает "секретное письмо", но изучение криптографии включает в себя нечто большее, чем просто секретное письмо, которое называется _encryption_. Криптография может, например, также использоваться для доказательства знания секрета без раскрытия этого секрета (например, с помощью цифровой подписи) или для доказательства подлинности данных (например, с помощью цифровых отпечатков пальцев, также известных как "хэши"). Эти типы криптографических доказательств являются математическими инструментами, критически важными для работы платформы Ethereum (и, действительно, всех систем блокчейна), а также широко используются в приложениях Ethereum. ((("encryption", seealso="keys and addresses")))

Обратите внимание, что на момент публикации ни одна часть протокола Ethereum не включает шифрование; то есть все коммуникации с платформой Ethereum и между узлами (включая данные транзакций) не зашифрованы и могут (обязательно) быть прочитаны кем угодно. Это делается для того, чтобы каждый мог проверить правильность обновлений состояния и консенсус был бы достигнут. В будущем будут доступны передовые криптографические инструменты, такие как доказательства с нулевым знанием и гомоморфное шифрование, которые позволят записывать некоторые зашифрованные вычисления в блокчейн, сохраняя при этом консенсус; однако, несмотря на то, что для них были предусмотрены средства, они еще не развернуты. 

В этой главе мы представим некоторые криптографии, используемые в Ethereum, а именно криптографию с открытым ключом (PKC), которая используется для контроля владения средствами в виде приватных ключей и адресов.

[[keys_addresses_intro]]
=== Ключи и адреса

((("cryptography","keys and addresses")))((("EOA (Externally Owned Account)","keys and addresses")))((("keys and addresses")))Как мы видели ранее в книге, у Ethereum есть два разных типа учетных записей: учетные записи, принадлежащие внешним пользователям (EOAs), и контракты. Право собственности на эфир со стороны EOAs устанавливается с помощью цифровых приватных ключей, адресов Ethereum и цифровых подписей. ((("private keys", seealso="keys and addresses")))Приватные ключи лежат в основе всего взаимодействия пользователя с Ethereum. Фактически, адреса учетных записей выводятся непосредственно из закрытых ключей: закрытый ключ однозначно определяет один адрес Ethereum, также известный как _учётная запись_ (_account_).

Приватные ключи никоим образом не используются непосредственно в системе Ethereum; они никогда не передаются и не хранятся в Ethereum. То есть приватные ключи должны оставаться закрытыми и никогда не появляться в сообщениях, передаваемых в сеть, а также не должны храниться в сети; только адреса учетных записей и цифровые подписи когда-либо передаются и хранятся в системе Ethereum. Для получения дополнительной информации о том, как сохранить приватные ключи в безопасности, см. <<control_responsibility>> и <<wallets_chapter>>.

((("digital signatures")))Доступ к средствам и контроль над ними осуществляются с помощью цифровых подписей, которые также создаются с использованием приватного ключа. Транзакции Ethereum требуют, чтобы действительная цифровая подпись была включена в блокчейн. Любой, у кого есть копия приватного ключа, имеет контроль над соответствующей учетной записью и любым эфиром, который она хранит. Предполагая, что пользователь хранит свой приватный ключ в безопасности, цифровые подписи в транзакциях Ethereum доказывают истинного владельца средств, поскольку они подтверждают право собственности на приватный ключ.

((("key pairs")))В системах, основанных на криптографии с открытым ключом, таких как используемая в Ethereum, ключи представлены парами, состоящими из приватного (секретного) ключа и открытого ключа. Представьте, что открытый ключ похож на номер банковского счета, а приватный ключ похож на секретный PIN-код; именно последний обеспечивает контроль над учетной записью, а первый идентифицирует ее для других. Сами приватные ключи очень редко видны пользователям Ethereum; по большей части они хранятся (в зашифрованном виде) в специальных файлах и управляются программным обеспечением Ethereum кошельков.

В платежной части транзакции Ethereum предполагаемый получатель представлен адресом Ethereum, который используется таким же образом, как и реквизиты счета получателя банковского перевода. Как мы вскоре увидим более подробно, адрес Ethereum для EOA генерируется из части открытого ключа пары ключей. Однако не все адреса Ethereum представляют пары открытого и закрытого ключей; они также могут представлять контракты, которые, как мы увидим в <<smart_contracts_chapter>>, не поддерживаются закрытыми ключами.

В остальной части этой главы мы сначала более подробно рассмотрим основы криптографии и объясним математику, используемую в Ethereum. Затем мы рассмотрим, как генерируются, хранятся и управляются ключи. Наконец, мы рассмотрим различные форматы кодирования, используемые для представления закрытых ключей, открытых ключей и адресов.

[[pkc]]
=== Криптография с открытым ключом и криптовалюта

((("cryptography","public key cryptography and cryptocurrency", id="ix_04keys-addresses-asciidoc1", range="startofrange")))((("public key cryptography", id="ix_04keys-addresses-asciidoc2", range="startofrange")))Криптография с открытым ключом (также называемая "асимметричной криптографией") является основной частью современной информационной безопасности. ((("Diffie, Whitfield")))((("Hellman, Martin")))((("key exchange protocol")))((("Merkle, Ralph")))Протокол обмена ключами, впервые опубликованный в 1970-х годах Мартином Хеллманом, Уитфилдом Диффи и Ральфом Мерклом, стал монументальным прорывом, который вызвал первую большую волну общественного интереса к области криптографии. До 1970-х годов сильные криптографические знания хранились в секрете pass:[<span class="keep-together">правительствами</span>].

Криптография с открытым ключом использует уникальные ключи для защиты информации. Эти ключи основаны на математических функциях, которые обладают особым свойством: их легко вычислить, но трудно вычислить их обратное значение. Основываясь на этих функциях, криптография позволяет создавать цифровые секреты и цифровые подписи, которые невозможно подделать и которые защищены законами математики.

Например, умножение двух больших простых чисел вместе является тривиальным. ((("prime factorization")))Но, учитывая произведение двух больших простых чисел, очень трудно найти простые множители (проблема, называемая _prime factorization_). Допустим, мы представляем число 8 018,009 и говорим вам, что оно является произведением двух простых чисел. Найти эти два простых числа для вас гораздо сложнее, чем для меня было умножить их, чтобы получить 8 018 009.

((("trapdoor functions")))Некоторые из этих математических функций можно легко инвертировать, если вы знаете какую-то секретную информацию. В предыдущем примере, если я скажу вам, что один из простых множителей равен 2,003, вы можете тривиально найти другой с помощью простого деления: 8,018,009 ÷ 2,003 = 4,003. Такие функции часто называют _односторонние функции с потайным входом_ (_trapdoor functions_), потому что их очень трудно инвертировать, если вам не предоставлена часть секретной информации, которую можно использовать в качестве короткого способа для обратного вызова функции.

((("elliptic curve cryptography")))Более продвинутая категория математических функций, которая полезна в криптографии, основана на арифметических операциях над эллиптической кривой. В арифметике эллиптических кривых умножение по модулю простого числа является простым, но деление (обратная операция) практически невозможно. ((("discrete logarithm problem")))Это называется проблемой дискретного логарифма (discrete logarithm problem), и в настоящее время нет известных лазеек. Криптография с эллиптической кривой (Elliptic curve cryptography) широко используется в современных компьютерных системах и является основой использования Ethereum'ом (и другими криптовалютами) закрытых ключей и цифровых подписей.

[NOTE]
====
Взгляните на следующие ресурсы, если вам интересно узнать больше о криптографии и математических функциях, которые используются в современной криптографии:

* http://bit.ly/2DcwNhn[Cryptography]

* http://bit.ly/2zeZV3c[Trapdoor function]

* http://bit.ly/2ACJjnV[Prime factorization]

* http://bit.ly/2Q7mZYI[Discrete logarithm]

* http://bit.ly/2zfeKCP[Elliptic curve cryptography]
====

В Ethereum мы используем криптографию с открытым ключом (также известную как асимметричная криптография) для создания пары открытый–закрытый ключ, о которой мы говорили в этой главе. Они считаются "парой", потому что открытый ключ является производным от закрытого ключа. Вместе они представляют учетную запись Ethereum, предоставляя, соответственно, общедоступное взаимодействие с учетной записью (адрес) и приватный контроль над доступом к любому эфиру в учетной записи и над любой аутентификацией, необходимой учетной записи при использовании смарт-контрактов. ((("digital signatures","private key and")))Закрытый ключ контролирует доступ, являясь уникальной информацией, необходимой для создания цифровых подписей (_digital signatures_), которые необходимы для подписания транзакций для расходования любых средств на счете. Цифровые подписи также используются для аутентификации владельцев или пользователей контрактов, как мы увидим в <<smart_contracts_chapter>>.

[TIP]
====
((("key pairs")))В большинстве реализаций кошелька закрытый и открытый ключи хранятся вместе в виде пары ключей для удобства. Однако открытый ключ может быть тривиально вычислен из закрытого ключа, поэтому также возможно хранение только закрытого ключа.
====

Цифровая подпись может быть создана для подписи любого сообщения. Для транзакций Ethereum в качестве сообщения используются сведения о самой транзакции. Математика криптографии &#x2014;в данном случае криптография с эллиптической кривой &#x2014; обеспечивает способ объединения сообщения (т.е. деталей транзакции) с закрытым ключом для создания кода, который может быть создан только со знанием закрытого ключа. Такой
код называется цифровой подписью. Обратите внимание, что транзакция Ethereum - это, по сути, запрос на доступ к определенной учетной записи с определенным адресом Ethereum. Когда транзакция отправляется в сеть Ethereum для перевода средств или взаимодействия со смарт-контрактами, ее необходимо отправить с цифровой подписью, созданной с помощью закрытого ключа от соответствующего адреса Ethereum. Математика с эллиптической кривой означает, что любой может проверить, что транзакция правильная, проверив, что цифровая подпись соответствует деталям транзакции и адресу Ethereum, к которому запрашивается доступ. Проверка вообще не связана с закрытым ключом; он остается закрытым. Однако процесс проверки, вне всякого сомнения, отзначает, что транзакция могла быть совершена только от кого-то с закрытым ключом, который соответствует открытому ключу, стоящему за адресом Ethereum. Это и есть "магия" криптографии с открытым ключом.


[TIP]
====
В протоколе Ethereum нет шифрования &#x2014; все сообщения, которые отправляются в рамках работы сети Ethereum, могут (обязательно) быть прочитаны всеми. Таким образом, закрытые ключи используются только для создания цифровых подписей для аутентификации транзакций.(((range="endofrange", startref="ix_04keys-addresses-asciidoc2")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc1")))
====

[[private_keys]]
=== Приватные ключи

((("private keys", id="ix_04keys-addresses-asciidoc3", range="startofrange")))Закрытый ключ - это просто число, выбранное случайным образом. Владение и контроль закрытого ключа является основой контроля пользователя над всеми средствами, связанными с соответствующим адресом Ethereum, а также доступом к контрактам, которые разрешают доступ к этому адресу. Закрытый ключ используется для создания подписей, необходимых для расходования эфира, путем подтверждения права собственности на средства, использованные в транзакции. ((("warnings and cautions","private key protection")))Закрытый ключ должен всегда оставаться секретным, поскольку раскрытие его третьим лицам равносильно предоставлению им контроля над эфиром и контрактами, защищенными этим закрытым ключом. Закрытый ключ также должен быть сохранен и защищен от случайной потери. Если он потерян, он не может быть восстановлен, и средства, защищенные им, тоже теряются навсегда.

[TIP]
====
Закрытый ключ Ethereum - это всего лишь число. Один из способов случайного выбора секретных ключей - это просто использовать монету, карандаш и бумагу: подбросьте монету 256 раз, и у вас будут двоичные цифры случайного секретного ключа, который вы можете использовать в кошельке Ethereum (возможно &#x2014; см. следующий раздел). Затем открытый ключ и адрес могут быть сгенерированы из закрытого ключа.
====

[[generating_private_key]]
==== Генерация приватного ключа из случайного числа

((("entropy","private key generation and")))((("private keys","generating from random number")))((("random numbers, private key generation from")))Первым и наиболее важным шагом в генерации ключей является поиск надежного источника энтропии, или случайности. Создание закрытого ключа Ethereum, по сути, включает в себя выбор числа от 1 до 2^256^. Сам метод, который вы используете для выбора этого числа, не имеет значения, если он не является предсказуемым или детерминированным. Программное обеспечение Ethereum использует генератор случайных чисел базовой операционной системы для получения 256 случайных битов. Обычно генератор случайных чисел операционной системы инициализируется человеческим источником случайности, поэтому вас могут попросить пошевелить мышью в течение нескольких секунд или нажать случайные клавиши на клавиатуре. Альтернативой может быть шум космического излучения на микрофонном канале компьютера.

Точнее, закрытый ключ может быть любым ненулевым числом вплоть до очень большого числа, чуть меньшего, чем 2^256^ &#x2014; огромное 78-значное число, примерно 1,158 * 10^77^. Точное число разделяет первые 38 цифр с 2^256^ и определяется как порядок эллиптической кривой, используемой в Ethereum (см. <<elliptic_curve>>). Чтобы создать закрытый ключ, мы случайным образом выбираем 256-битное число и проверяем, находится ли оно в допустимом диапазоне. В терминах программирования это обычно достигается путем подачи еще большей строки случайных битов (собранных из криптографически защищенного источника случайности) в 256-битный алгоритм хэширования, такой как Keccak-256 или SHA-256, оба из которых будут удобно выдавать 256-битное число. Если результат находится в допустимом диапазоне, у нас есть подходящий закрытый ключ. В противном случае мы просто повторяем попытку с другим случайным числом.

[TIP]
====
2^256^&#x2014;размер пространства закрытых ключей Ethereum &#x2014; - это непостижимо большое число. Это приблизительно 10^77^ в десятичной системе счисления; то есть число с 77 цифрами. Для сравнения, по оценкам, видимая вселенная содержит от 10^77 до 10^80 атомов. Следовательно, в нижнем диапазоне достаточно закрытых ключей, чтобы предоставить каждому атому во вселенной учетную запись Ethereum. Если вы выберете закрытый ключ случайным образом, нет никакого мыслимого способа, которым кто-либо когда-либо угадает его или выберет сам.
====

Обратите внимание, что процесс генерации закрытого ключа является автономным; он не требует какой-либо связи с сетью Ethereum или вообще какой-либо связи с кем-либо. Таким образом, для того, чтобы выбрать число, которое никто другой никогда не выберет, оно должно быть действительно случайным. Если вы сами выберете число, вероятность того, что кто-то другой попробует его (а затем сбежит с вашим эфиром), слишком высока. Использование плохого генератора случайных чисел (например, псевдослучайной функции +rand+ в большинстве языков программирования) еще хуже, потому что это еще более очевидно и еще проще воспроизвести. Как и в случае с паролями для онлайн-аккаунтов, закрытый ключ должен быть не поддающимся угадыванию. К счастью, вам никогда не нужно запоминать свой закрытый ключ, поэтому вы можете выбрать наилучший из возможных подходов к его выбору, а именно истинную случайность.

[WARNING]
====
Do not write your own code to create a random number or use a "simple" random number generator offered by your programming language. It is vital that you use a cryptographically secure pseudo-random number generator (such as CSPRNG) with a seed from a source of sufficient entropy. Study the documentation of the random number generator library you choose to make sure it is cryptographically secure. Correct implementation of the CSPRNG library is critical to the security of the keys.
====

Ниже приведен случайно сгенерированный закрытый ключ, отображаемый в шестнадцатеричном формате (256 бит отображаются в виде 64 шестнадцатеричных цифр, каждые 4 бита):(((range="endofrange", startref="ix_04keys-addresses-asciidoc3")))

[[prv_key_example]]
----
f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
----


[[pubkey]]
=== Открытые ключи

((("cryptography","public keys", id="ix_04keys-addresses-asciidoc4", range="startofrange")))((("elliptic curve cryptography","public key generation", id="ix_04keys-addresses-asciidoc5", range="startofrange")))((("public keys", seealso="keys and addresses", id="ix_04keys-addresses-asciidoc6", range="startofrange")))Открытый ключ Ethereum - это _точка_ (_point_) на эллиптической кривой, что означает, что это набор _x_ и _y_ координат, которые удовлетворяют уравнению эллиптической кривой.

Проще говоря, открытый ключ Ethereum - это два числа, соединенные вместе. Эти числа получаются из закрытого ключа путем вычисления, которое может идти только в одну сторону. Это означает, что тривиально вычислить открытый ключ, если у вас есть закрытый ключ, но вы не можете вычислить закрытый ключ из открытого ключа.

[WARNING]
====
МАТЕМАТИКА вот-вот произойдет! Не паникуй. Если вы начнете теряться в каком-либо пункте следующих параграфов, вы можете пропустить следующие несколько разделов. Существует множество инструментов и библиотек, которые сделают математику за вас.
====

Открытый ключ вычисляется из закрытого ключа с использованием умножения на эллиптическую кривую, которое практически необратимо: _K_ = _k_ * _G_, где _k_ - закрытый ключ, _G_ - константная точка, называемая ((("generator point")))_точкой создания_ (_generator point_), _K_ - результирующий открытый ключ, и * - это специальный оператор "умножения" эллиптической кривой. Обратите внимание, что умножение на эллиптической кривой не похоже на обычное умножение. Оно имеет общие функциональные атрибуты с обычным умножением, но на этом все. Например, обратная операция (которая была бы делением для нормальных чисел), известная как "нахождение дискретного логарифма", т.е. Вычисление _k_, если вы знаете __K__ &#x2014; так же сложно, как попробовать перебрать все возможные значения _k_ (грубый-принудительный поиск, который, вероятно, займет больше времени, чем позволит эта вселенная).

Проще говоря: арифметика на эллиптической кривой отличается от "обычной" целочисленной арифметики. Точка (_G_) может быть умножена на целое число (_k_), чтобы получить другую точку (_K_). Но такого понятия, как _деление_ (_division_), не существует, поэтому невозможно просто "разделить" открытый ключ _K_ на точку _G_, чтобы вычислить закрытый ключ _k_. Это односторонняя математическая функция, описанная в <<pkc>>.

[NOTE]
====
((("one-way functions")))Умножение по эллиптической кривой - это тип функции, которую криптографы называют "односторонней" функцией: ее легко выполнить в одном направлении (умножение) и невозможно выполнить в обратном направлении (деление). Владелец закрытого ключа может легко создать открытый ключ, а затем поделиться им со всем миром, зная, что никто не сможет выполнить обратную операцию и вычислить закрытый ключ по открытому ключу. Этот математический трюк становится основой для невзламываемых и безопасных цифровых подписей, которые подтверждают право собственности на средства Ethereum и контроль над контрактами.
====

Прежде чем мы продемонстрируем, как сгенерировать открытый ключ из закрытого ключа, давайте рассмотрим криптографию с эллиптической кривой немного подробнее.


[[elliptic_curve]]
==== Объяснение криптографии с эллиптической кривой

((("elliptic curve cryptography","basics", id="ix_04keys-addresses-asciidoc7", range="startofrange")))((("elliptic curve cryptography", id="ix_04keys-addresses-asciidoc8", range="startofrange")))((("public keys","elliptic curve cryptography and", id="ix_04keys-addresses-asciidoc9", range="startofrange")))Криптография с эллиптической кривой - это тип асимметричной криптографии или криптографии с открытым ключом, основанной на задаче дискретного логарифмирования, выражаемой сложением и умножением в точках эллиптической кривой.

<<ecc-curve>> это пример эллиптической кривой, аналогичной той, что используется Ethereum.

[NOTE]
====
((("secp256k1 elliptic curve", id="ix_04keys-addresses-asciidoc10", range="startofrange")))Ethereum использует точно такую же эллиптическую кривую, называемую +secp256k1+, как и биткойн. Это позволяет повторно использовать многие библиотеки и инструменты эллиптических кривых из Биткойна.
====

[[ecc-curve]]
.Визуализация эллиптической кривой
image::images/simple_elliptic_curve.png["ecc-curve"]

Ethereum использует определенную эллиптическую кривую и набор математических констант, как определено в стандарте под названием +secp256k1+, установленном Национальным институтом стандартов и технологий США (NIST). Кривая +secp256k1+ определяется следующей функцией, которая создает эллиптическую кривую:

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <mrow>
      <msup><mi>y</mi> <mn>2</mn> </msup>
      <mo>=</mo>
      <mrow>
        <mo>(</mo>
        <msup><mi>x</mi> <mn>3</mn> </msup>
        <mo>+</mo>
        <mn>7</mn>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mspace width="3.33333pt"/>
    <mtext>over</mtext>
    <mspace width="3.33333pt"/>
    <mrow>
      <mo>(</mo>
      <msub><mi>&#x1d53d;</mi> <mi>p</mi> </msub>
      <mo>)</mo>
    </mrow>
  </mrow>
</math>
</div>
++++

or:

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <msup><mi>y</mi> <mn>2</mn> </msup>
    <mspace width="3.33333pt"/>
    <mo form="prefix">mod</mo>
    <mspace width="0.277778em"/>
    <mi>p</mi>
    <mo>=</mo>
    <mrow>
      <mo>(</mo>
      <msup><mi>x</mi> <mn>3</mn> </msup>
      <mo>+</mo>
      <mn>7</mn>
      <mo>)</mo>
    </mrow>
    <mspace width="3.33333pt"/>
    <mo form="prefix">mod</mo>
    <mspace width="0.277778em"/>
    <mi>p</mi>
  </mrow>
</math>
</div>
++++

_mod p_ (по модулю простого числа _p_) указывает, что эта кривая находится над конечным полем простого порядка _p_, также записываемым как latexmath:[\( \mathbb{F}_p \)], где _p_ = 2^256^ – 2^32^ – 2^9^ – 2^8^ – 2^7^ – 2^6^ – 2^4^ – 1, что является очень большим простым числом.

Поскольку эта кривая определена над конечным полем простого порядка, а не над действительными числами, она выглядит как узор из точек, разбросанных в двух измерениях, что затрудняет ее визуализацию. Однако математика идентична математике эллиптической кривой над действительными числами. В качестве примера, <<ecc-over-F17-math>> показывает ту же эллиптическую кривую над гораздо меньшим конечным полем простого порядка 17, показывая узор точек на сетке. Эллиптическую кривую +secp256k1+ Ethereum можно рассматривать как гораздо более сложный узор точек на непостижимо большой сетке.

[[ecc-over-F17-math]]
[role="smallersixty"]
.Криптография с эллиптической кривой: визуализация эллиптической кривой над F (p) с p=17
image::images/ec_over_small_prime_field.png["ecc-over-F17-math"]

Так, например, ниже приведена точка _Q_ с координатами (_x_,_y_), которая является точкой на кривой +secp256k1+:

[[coordinates_example]]
----
Q = 
(49790390825249384486033144355916864607616083520101638681403973749255924539515,
59574132161899900045862086493921015780032175291755807399284007721050341297360)
----

<<example_1>> показывает, как вы можете проверить это самостоятельно, используя Python. Переменные +x+ и +y+ являются координатами точки _Q_, как и в предыдущем примере. Переменная +p+ - это простой порядок эллиптической кривой (простое число, которое используется для всех операций по модулю). Последняя строка Python - это уравнение эллиптической кривой (оператор +%+ в Python - это оператор по модулю). Если +x+ и +y+ действительно являются координатами точки на эллиптической кривой, то они удовлетворяют уравнению, и результат равен нулю (+0L+ - длинное целое число с нулевым значением). Попробуйте сами, набрав ++**python**++ в командной строке и скопировав каждую строку (после подсказки +>>>+) из списка(((range="endofrange", startref="ix_04keys-addresses-asciidoc10"))).(((range="endofrange", startref="ix_04keys-addresses-asciidoc9")))

++++
<div data-type="example" id="example_1">
<h5>Использование Python для подтверждения того, что эта точка находится на эллиптической кривой</h5>
<pre data-type="programlisting">
Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> <strong>p = 115792089237316195423570985008687907853269984665640564039457584007908834 \
671663</strong>
>>> <strong>x = 49790390825249384486033144355916864607616083520101638681403973749255924539515</strong>
>>> <strong>y = 59574132161899900045862086493921015780032175291755807399284007721050341297360</strong>
>>> <strong>(x ** 3 + 7 - y**2) % p</strong>
0L
</pre>
</div>
++++

[[EC_math]]
==== Арифметические операции с эллиптической кривой

((("elliptic curve cryptography","arithmetic operations")))Большая часть математики с эллиптическими кривыми выглядит и работает очень похоже на целочисленную арифметику, которую мы изучали в школе. В частности, мы можем определить оператор сложения, который вместо перехода вдоль числовой линии переходит к другим точкам кривой. Как только у нас есть оператор сложения, мы также можем определить умножение точки и целого числа, что эквивалентно повторному сложению.

Сложение эллиптической кривой определяется таким образом, что при наличии двух точек _P_~1~ и _P_~2~ на эллиптической кривой существует третья точка _P_~3 ~ = _P_~1 ~ + _P_~2~, также на эллиптической кривой.

Геометрически эта третья точка _P_~3~ вычисляется путем проведения линии между _P_~1~ и _P_~2~. Эта линия пересечет эллиптическую кривую ровно в одном дополнительном месте (удивительно). Назовем эту точку _P_~3~' = (_x_, _y_). Затем отразите по оси x, чтобы получить _P_~3~ = (_x_, _–y_).

Если _P_~1~ и _P_~2~ являются одной и той же точкой, линия "между" _P_~1~ и _P_~2~ должна быть касательной к кривой в этой точке _P_~1~. Эта касательная пересечет кривую ровно в одной новой точке. Вы можете использовать методы из исчисления, чтобы определить наклон касательной линии. Любопытно, что эти методы работают, даже несмотря на то, что мы ограничиваем наш интерес точками на кривой с двумя целочисленными координатами!

В математике эллиптических кривых также существует точка, называемая "точкой в бесконечности", которая примерно соответствует роли числа ноль в сложении. На компьютерах это иногда представляется как _x_ = _y_ = 0 (что не удовлетворяет уравнению эллиптической кривой, но это простой отдельный случай, который можно проверить). Есть несколько особых случаев, которые объясняют необходимость точки на бесконечности.

В некоторых случаях (например, если _P_~1~ и _P_~2~ имеют одинаковые значения _x_, но разные значения _y_) линия будет точно вертикальной, и в этом случае _P_~3~ = точка на бесконечности.

Если _P_~1~ - точка на бесконечности, то _P_~1~ + _P_~2~ = _P_~2~. Аналогично, если _P_~2~ - точка на бесконечности, то _P_~1~ + _P_~2~ = _P_~1~. Это показывает, как точка на бесконечности играет ту роль, которую ноль играет в "обычной" арифметике.

Оказывается, что pass:[+] является ассоциативным, что означает, что (_A_ pass:[+] _B_) pass:[+] _C_ = _A_ pass:[+] (_B_ pass:[+] _C_). Это означает, что мы можем написать _A_ pass:[+] _B_ pass:[+] _C_ (без круглых скобок) без двусмысленности.

Теперь, когда мы определили сложение, мы можем определить умножение стандартным способом, который расширяет сложение. Для точки _P_ на эллиптической кривой, если _k_ является целым числом, то _k_ pass:[*] _P_ = _P_ pass:[+] _P_ pass:[+] _P_ pass:[+] _P_ pass:[+] ... pass:[+] _P_ (_k_ раз). Обратите внимание, что _k_ в этом случае иногда (возможно, ошибочно) называют "показателем степени".(((range="endofrange", startref="ix_04keys-addresses-asciidoc8")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc7")))

[[public_key_derivation]]
==== Генерация открытого ключа

((("elliptic curve cryptography","public key generation with")))((("generator point")))((("public keys","generating")))Начиная с закрытого ключа в виде случайно сгенерированного числа _k_, мы умножаем его на заранее определенную точку на кривой, называемую _generator point_ _G_, чтобы получить другую точку где-то еще на кривой, которая является соответствующим открытым ключом _K_: 

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <mi>K</mi>
    <mo>=</mo>
    <mi>k</mi>
    <mo>*</mo>
    <mi>G</mi>
  </mrow>
</math>
</div>
++++

((("secp256k1 elliptic curve")))Точка генератора указана как часть стандарта +secp256k1+; она одинакова для всех реализаций +secp256k1+, и все ключи, полученные из этой кривой, используют одну и ту же точку _G_. Поскольку точка генератора всегда одинакова для всех пользователей Ethereum, закрытый ключ _k_, умноженный на _G_, всегда приведет к одному и тому же открытому ключу _K_. Связь между _k_ и _K_ фиксирована, но может быть вычислена только в одном направлении, от _k_ до _K_. Вот почему адрес Ethereum (производный от _K_) может быть передан кому угодно и не раскрывает закрытый ключ пользователя (_k_).

Как мы описали в предыдущем разделе, умножение _k_ * _G_ эквивалентно повторному сложению, поэтому _G_ pass:[+] _G_ pass:[+] _G_ pass:[+] ... pass:[+] _G_, повторяется _k_ раз. Таким образом, чтобы создать открытый ключ _K_ из закрытого ключа _k_, мы добавляем точку генератора _G_ к самой себе _k_ раз.

[TIP]
====
Закрытый ключ может быть преобразован в открытый ключ, но открытый ключ не может быть преобразован обратно в закрытый ключ, потому что математика работает только в одну сторону.
====

Давайте применим это вычисление, чтобы найти открытый ключ для конкретного закрытого ключа, который мы показали вам в <<private_keys>>:


[[example_privkey]]
.Пример вычисления открытого ключа по закрытому ключу
----
K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G
----

Криптографическая библиотека может помочь нам вычислить _K_, используя умножение на эллиптическую кривую. Результирующий открытый ключ _K_ определяется как точка:

----
K = (x, y)
----

где:

----
x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

((("SECG (Standards for Efficient Cryptography Group)")))((("Standards for Efficient Cryptography Group (SECG)")))В Ethereum вы можете увидеть открытые ключи, представленные в виде сериализации из 130 шестнадцатеричных символов (65 байт). Это взято из стандартного формата сериализации, предложенного отраслевым консорциумом Standards for Efficient Cryptography Group (SECG), задокументированного в http://www.secg.org/sec1-v2.pdf[Standards for Efficient Cryptography (SEC1)]. Стандарт определяет четыре возможных префикса, которые могут использоваться для идентификации точек на эллиптической кривой, перечисленных в <<EC_prefix_table>>.

[[EC_prefix_table]]
.Сериализованные префиксы открытого ключа EC
[options="header"]
|===
| Префикс | Значение | Длина (префикс подсчета байтов)
| +0x00+ | Точка на бесконечности | 1
| +0x04+ | Несжатая точка | 65
| +0x02+ | Сжатая точка с чётным +y+ | 33
| +0x03+ | Сжатая точка с нечётным +y+ | 33
|===

Ethereum использует только несжатые открытые ключи; поэтому единственным подходящим префиксом является (шестнадцатеричный) +04+. Сериализация объединяет координаты _x_ и _y_ открытого ключа:

[[concat_coordinates]]
----
04 + x-координата (32 bytes/64 hex) + y-координата (32 bytes/64 hex)
----

Таким образом, открытый ключ, который мы рассчитали ранее, сериализуется как:

[[serialized_pubkey]]
----
046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0 \
c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

[[EC_lib]]
==== Библиотеки эллиптических кривых

((("elliptic curve cryptography","libraries")))((("secp256k1 elliptic curve")))Существует несколько реализаций эллиптической кривой +secp256k1+, которые используются в проектах, связанных с криптовалютой:

((("OpenSSL cryptographic library")))https://www.openssl.org/[OpenSSL]:: Библиотека OpenSSL предлагает полный набор криптографических примитивов, включая полную реализацию +secp256k1+. Например, для получения открытого ключа можно использовать функцию +EC_POINT_mul+.

((("libsecp256k1 cryptographic library")))https://github.com/bitcoin-core/secp256k1[libsecp256k1]:: +libsecp256k1+ от Bitcoin Core - это реализация эллиптической кривой +secp256k1+ на языке Си и других криптографических примитивов. Он был написан с нуля, чтобы заменить OpenSSL в программном обеспечении Bitcoin Core, и считается превосходным как по производительности, так и по безопасности.(((range="endofrange", startref="ix_04keys-addresses-asciidoc6")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc5")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc4")))

[[hash_functions]]
=== Криптографические хэш-функции

((("cryptographic hash functions", id="ix_04keys-addresses-asciidoc11", range="startofrange")))((("cryptography","hash functions", id="ix_04keys-addresses-asciidoc12", range="startofrange")))((("hash functions", id="ix_04keys-addresses-asciidoc13", range="startofrange")))Криптографические хэш-функции используются во всем Ethereum. На самом деле, хэш-функции широко используются почти во всех криптографических системах &#x2014; факт, зафиксированный ((("Schneier, Bruce")))pass:[<span class="keep-together">криптографом</span>] http://bit.ly/2Q79qZp[Bruce Schneier], который сказал: "Гораздо больше, чем алгоритмы шифрования, односторонние хэш-функции являются рабочими лошадками современной криптографии".

В этом разделе мы обсудим хэш-функции, изучим их основные свойства и посмотрим, как эти свойства делают их такими полезными во многих областях современной криптографии. Мы рассматриваем здесь хэш-функции, потому что они являются частью преобразования открытых ключей Ethereum в адреса. ((("цифровой отпечаток пальца")))Они также могут быть использованы для создания цифровых отпечатков пальцев, которые помогают в проверке данных.

((("one-way functions")))Проще говоря, _хэш-функция_ (http://bit.ly/2CR26gD[_hash function_]) - это &#x201c;любая функция, которая может использоваться для сопоставления данных произвольного размера с данными фиксированного размера.&#x201d; ((("pre-image")))Входные данные для хэш-функции называются _pre-image_, _message_ или просто _input data_. Результат называется _hash_. http://bit.ly/2Jrn3jM[Криптографические хэш-функции] - это особая подкатегория, которая обладает специфическими свойствами, полезными для защищенных платформ, таких как Ethereum.

Криптографическая хеш-функция - это односторонняя хеш-функция, которая отображает данные произвольного размера в строку битов фиксированного размера. "Односторонний" характер означает, что с вычислительной точки зрения невозможно воссоздать входные данные, если известен только выходной хэш. Единственный способ определить возможные входные данные - это провести полный перебор, проверяя каждого кандидата на соответствие выходным данным; учитывая, что пространство поиска практически бесконечно, легко понять практическую невозможность этой задачи. Даже если вы найдете какие-то входные данные, которые создают соответствующий хэш, это могут быть не исходные входные данные: хэш-функции - это функции "многие к одному". ((("hash collision")))Нахождение двух наборов входных данных, которые хэшируются с одним и тем же выводом, называется нахождением _хэш-коллизии_ (_hash collision_). Грубо говоря, чем лучше хэш-функция, тем реже возникают хэш-коллизии. Для Ethereum они фактически невозможны.

((("hash functions","main properties")))Давайте подробнее рассмотрим основные свойства криптографических хэш-функций. К ним относятся:

Детерминизм:: Одинаковые входные данные всегда выдают один и тот же хэш-результат.

Проверяемость:: Вычисление хэша сообщения является эффективным (линейная сложность).

Некорреляция:: Небольшое изменение входных данных (например, изменение на 1 бит) должно изменить вывод хэша настолько сильно, что его нельзя будет соотнести с хэшем исходного сообщения.

Необратимость:: Вычисление входных данных по его хэшу невозможно, что эквивалентно перебору всех возможных входных данных методом полного перебора.

Защита от столкновений:: Должно быть невозможно вычислить два разных входных набора, которые выдают один и тот же хэш-результат.

Устойчивость к коллизиям хэшей особенно важна для предотвращения подделки цифровой подписи в Ethereum.

Сочетание этих свойств делает криптографические хэш-функции полезными для широкого спектра приложений безопасности, включая:

* Снятие отпечатков пальцев с данных
* Целостность сообщения (обнаружение ошибок)
* Подтверждение работы
* Аутентификация (хэширование паролей и растяжение ключей)
* Генераторы псевдослучайных чисел
* Приверженность сообщению (механизмы фиксации–раскрытия)
* Уникальные идентификаторы

Мы найдем многие из них в Ethereum по мере прохождения различных уровней системы.

[[keccak256]]
==== Криптографическая хэш-функция Ethereum: Keccak-256

((("hash functions","Keccak-256")))((("Keccak-256 hash function")))((("SHA-3 Hash Function")))Ethereum использует криптографическую хэш-функцию _Keccak-256_ во многих местах. Keccak-256 был разработан в качестве кандидата на конкурс криптографических хэш-функций SHA-3, проводимый в 2007 году ((("National Institute of Standards and Technology (NIST)")))((("NIST (National Institute of Standards and Technology)")))Национальный институт стандартов и технологий. Победителем стал алгоритм Keccak, который стал стандартизирован как ((("Federal Information Processing Standard (FIPS)")))((("FIPS (Federal Information Processing Standard)")))((("FIPS-202")))Федеральный стандарт обработки информации (FIPS) 202 в 2015 году.

Однако в период, когда разрабатывался Ethereum, стандартизация NIST еще не была завершена. NIST скорректировал некоторые параметры Keccak после завершения процесса стандартизации, предположительно, для повышения его эффективности. Это происходило в то же время, когда героический разоблачитель ((("Snowden, Edward"))) Эдвард Сноуден раскрыл документы, которые подразумевают, что NIST, возможно, подвергся ненадлежащему влиянию Агентства национальной безопасности, чтобы намеренно ослабить ((("Dual_EC_DRBG"))) стандарт генератора случайных чисел Dual_EC_DRBG, эффективно размещение бэкдора в стандартном генераторе случайных чисел. Результатом этого противоречия стала негативная реакция на предлагаемые изменения и значительная задержка в стандартизации SHA-3. В то время Фонд Ethereum решил внедрить оригинальный алгоритм Keccak, предложенный его изобретателями, а не стандарт SHA-3, модифицированный NIST.

[WARNING]
====
Хотя вы можете видеть "SHA-3", упоминаемый во всех документах и коде Ethereum, многие, если не все, эти экземпляры на самом деле относятся к Keccak-256, а не к окончательному стандарту FIPS-202 SHA-3. Различия в реализации незначительны, связанные с параметрами заполнения, но они существенны в том смысле, что Keccak-256 выдает другие выходные данные хэша в отличие от FIPS-202 SHA-3 для одних и тех же входных данных.
====

[[which_hash]]
==== Какую хэш-функцию я использую?

((("hash functions","test vector for determining")))((("test vector, determining hash functions with")))Как вы можете определить, реализует ли используемая вами программная библиотека FIPS-202 SHA-3 или Keccak-256, если оба могут называться "SHA-3"?

Простой способ определить это - использовать _test vector_, ожидаемый результат для данного ввода. ((("тест пустого ввода"))) Тест, наиболее часто используемый для хэш-функции, - это _empty input_. Если вы запустите хэш-функцию с пустой строкой в качестве входных данных, вы должны увидеть следующие результаты:

----
Keccak256("") =
  c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

SHA3("") =
  a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a
----


Независимо от того, как вызывается функция, вы можете протестировать ее, чтобы узнать, является ли она оригинальной Keccak-256 или окончательной версией стандарта NIST FIPS-202 SHA-3, выполнив этот простой тест. Помните, что Ethereum использует Keccak-256, хотя в коде его часто называют SHA-3.

[NOTE]
====
Из-за путаницы, вызванной различием между хэш-функцией, используемой в Ethereum (Keccak-256), и окончательным стандартом (FIP-202 SHA-3), предпринимаются усилия по переименованию всех экземпляров +sha3+ во всем коде, кодах операций и библиотеках в +keccak256+. Смотрите https://github.com/ethereum/EIPs/issues/59[EIP-59] для получения подробной информации.
====


Далее давайте рассмотрим первое применение Keccak-256 в Ethereum, которое заключается в создании адресов Ethereum из открытых ключей.(((range="endofrange", startref="ix_04keys-addresses-asciidoc13")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc12")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc11")))

[[eth_address]]
=== Адреса Ethereum

((("addresses", id="ix_04keys-addresses-asciidoc14", range="startofrange")))((("cryptography","Ethereum addresses and", id="ix_04keys-addresses-asciidoc15", range="startofrange")))Адреса Ethereum - это уникальные идентификаторы, которые получены из открытых ключей или контрактов с использованием односторонней хэш-функции Keccak-256.

В наших предыдущих примерах мы начали с закрытого ключа и использовали умножение эллиптической кривой для получения открытого ключа:

[role="pagebreak-before"]
Закрытый ключ _k_:

----
k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
----

[[concat_pubkey]]
Открытый ключ _K_ (координаты _x_ и _y_ объединены и отображаются в виде шестнадцатеричных чисел):

----
K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e...
----

[NOTE]
====
Стоит отметить, что открытый ключ не форматируется с префиксом (шестнадцатеричным) +04+ при вычислении адреса.
====

Мы используем Keccak-256 для вычисления _hash_ этого открытого ключа:

[[calculate_hash]]
----
Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

Затем мы сохраняем только последние 20 байт (наименее значимые байты), которые являются нашим адресом Ethereum:

[[keep_last_20]]
----
001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

Чаще всего вы увидите адреса Ethereum с префиксом +0x+, который указывает, что они имеют шестнадцатеричную кодировку, например:

[[hex_prefix]]
----
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

[[eth_address_format]]
==== Форматы адресов Ethereum

((("addresses","formats")))Адреса Ethereum представляют собой шестнадцатеричные числа, идентификаторы, полученные из последних 20 байт хэша открытого ключа Keccak-256.

((("checksum","in Ethereum address formats")))В отличие от биткойн-адресов, которые кодируются в пользовательском интерфейсе всех клиентов, чтобы включать встроенную контрольную сумму для защиты от ошибочных адресов, адреса Ethereum представлены в виде необработанных шестнадцатеричных чисел без какой-либо контрольной суммы.

Обоснование этого решения заключалось в том, что адреса Ethereum в конечном итоге будут скрыты за абстракциями (такими как службы имен) на более высоких уровнях системы и что контрольные суммы должны быть добавлены на более высоких уровнях, если это необходимо.

На самом деле эти более высокие уровни разрабатывались слишком медленно, и такой выбор дизайна привел к ряду проблем на ранних этапах существования экосистемы, включая потерю средств из-за неправильно введенных адресов и ошибок проверки входных данных. Кроме того, поскольку сервисы имен Ethereum разрабатывались медленнее, чем первоначально ожидалось, разработчики кошельков очень медленно внедряли альтернативные кодировки. Далее мы рассмотрим несколько вариантов кодирования.

[[ICAP]]
==== Протокол обмена клиентских адресов (Inter Exchange Client Address Protocol)

((("addresses","ICAP encoding", id="ix_04keys-addresses-asciidoc16", range="startofrange")))((("ICAP (Inter-exchange Client Address Protocol)", id="ix_04keys-addresses-asciidoc17", range="startofrange")))((("Inter-exchange Client Address Protocol (ICAP)", id="ix_04keys-addresses-asciidoc18", range="startofrange")))Протокол _Inter exchange Client Address Protocol_ (ICAP) представляет собой кодировку адреса Ethereum, которая частично совместима с ((("IBAN (International Bank Account Number)")))((("International Bank Account Number (IBAN)")))одировкой международного номера банковского счета (IBAN), предлагающая универсальную, проверяемую и совместимую кодировку для адресов Ethereum. Адреса ICAP могут кодировать адреса Ethereum или общие имена, зарегистрированные в реестре имен Ethereum. Вы можете прочитать больше об ICAP на сайте https://eth.wiki/en/ideas/inter-exchange-client-address-protocol-icap[Ethereum Wiki].

IBAN - это международный стандарт идентификации номеров банковских счетов, в основном используемый для банковских переводов. Он широко применяется в Европейской платежной зоне единого евро (SEPA) и за ее пределами. IBAN - это централизованная и строго регулируемая услуга. ICAP - это децентрализованная, но совместимая реализация для адресов Ethereum.

IBAN состоит из строки длиной до 34 буквенно-цифровых символов (без учета регистра), содержащей код страны, контрольную сумму и идентификатор банковского счета (который зависит от конкретной страны).

ICAP использует ту же структуру, вводя нестандартный код страны &#x201c;XE&#x201d;, который расшифровывается как "Ethereum", за которым следует двухсимвольная контрольная сумма и три возможных варианта идентификатора учетной записи:

Прямой (Direct):: Целое число с начальным числом 36, состоящее из 30 буквенно-цифровых символов, представляющих 155 младших значащих битов адреса Ethereum. Поскольку эта кодировка соответствует менее чем полным 160 битам общего адреса Ethereum, она работает только для адресов Ethereum, которые начинаются с одного или нескольких нулевых байтов. Преимущество заключается в том, что он совместим с IBAN с точки зрения длины поля и контрольной суммы. Пример: +XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD+ (длина 33 символа).

Базовый (Basic):: То же, что и прямая кодировка, за исключением того, что она имеет длину 31 символ. Это позволяет ему кодировать любой адрес Ethereum, но делает его несовместимым с проверкой поля IBAN. Пример: +XE18CHDJBPLTBCJ03FE9O2NS0BPOJVQCU2P+ (длина 35 символов).

Косвенный (Indirect):: Кодирует идентификатор, который преобразуется в адрес Ethereum через поставщика реестра имен. Он использует 16 буквенно-цифровых символов, включая идентификатор _asset_ (например, ETH), службу имен (например, XREG) и 9-символьное удобочитаемое имя (например, KITTYCATS). Пример: +XEpass:[##]ETHXREGKITTYCATS+ (длиной 20 символов), где +##+ следует заменить двумя символами вычисленной контрольной суммы.

((("EthereumJS helpeth")))((("helpeth command-line tool")))Мы можем использовать инструмент командной строки +helpeth+ для создания адресов ICAP. Вы можете получить helpeth, установив его с помощью:

++++
<pre data-type="programlisting">
$ <strong>npm install -g helpeth</strong>
</pre>
++++

Если у вас нет npm, возможно, вам придется сначала установить NodeJS, что вы можете сделать, следуя инструкциям по адресу https://nodeJS.org . 

Теперь, когда у нас есть helpeth, давайте попробуем создать адрес ICAP с помощью нашего примера закрытого ключа (с префиксом +0x+ и переданного в качестве параметра +helpeth+). 

++++
<pre data-type="programlisting">
$ <strong>helpeth keyDetails \
  -p 0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315</strong>

Address: 0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
ICAP: XE60 HAMI CDXS V5QX VJA7 TJW4 7Q9C HWKJ D
Public key: 0x6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b...
</pre>
++++

Команда +helpeth+ создает для нас шестнадцатеричный адрес Ethereum, а также адрес ICAP. Адрес ICAP для нашего ключа:

[[ICAP_example]]
----
XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD
----

Поскольку наш пример адреса Ethereum начинается с нулевого байта, он может быть закодирован с использованием прямого метода кодирования ICAP, который действителен в формате IBAN. Вы можете сказать это, потому что он состоит из 33 символов.

Если бы ваш адрес не начинался с нуля, он был бы закодирован с использованием базовой кодировки, которая будет иметь длину 35 символов и недопустима в качестве IBAN.

[TIP]
====
Вероятность того, что любой адрес Ethereum начнется с нулевого байта, равна 1 к 256. Чтобы сгенерировать такой адрес, потребуется в среднем 256 попыток с 256 различными случайными закрытыми ключами, прежде чем мы найдем тот, который работает как совместимый с IBAN "Прямой (Direct)" кодированный ICAP-адрес.
====

В настоящее время ICAP, к сожалению, поддерживается только несколькими кошельками.(((range="endofrange", startref="ix_04keys-addresses-asciidoc18")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc17")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc16")))

[[EIP55]]
==== Шестнадцатеричная кодировка с контрольной суммой в прописных буквах (EIP-55)

((("addresses","hex encoding with checksum in capitalization (EIP-55)", id="ix_04keys-addresses-asciidoc19", range="startofrange")))((("checksum","EIP-55 and", id="ix_04keys-addresses-asciidoc20", range="startofrange")))((("EIP-55 (Ethereum Improvement Proposal 55)","checksum for addresses", id="ix_04keys-addresses-asciidoc21", range="startofrange")))Из-за медленного развертывания служб ICAP стандарт было создано https://github.com/Ethereum/EIPs/blob/master/EIPS/eip-55.md[Предложение по улучшению Ethereum 55 (EIP-55)]. EIP-55 предлагает обратно совместимую контрольную сумму для адресов Ethereum, изменяя заглавные буквы шестнадцатеричного адреса. Идея заключается в том, что адреса Ethereum не чувствительны к регистру, и все кошельки должны принимать адреса Ethereum, выраженные заглавными или строчными буквами, без какой-либо разницы в интерпретации.

Изменяя заглавные буквы буквенных символов в адресе, мы можем передать контрольную сумму, которую можно использовать для защиты целостности адреса от ошибок ввода или чтения. Кошельки, которые не поддерживают контрольные суммы EIP-55, просто игнорируют тот факт, что адрес содержит смешанные заглавные буквы, но те, которые его поддерживают, могут проверять его и обнаруживать ошибки с точностью 99,986%.

Кодировка со смешанными заглавными буквами неуловима, и поначалу вы можете ее не заметить. Наш примерный адрес::

----
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

С контрольной суммой со смешанной капитализацией EP-55 она становится:

[[mixed_capitalization]]
----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
----

Можете ли вы заметить разницу? Некоторые из буквенных символов (A&#x2013;F) из алфавита шестнадцатеричной кодировки теперь являются заглавными, в то время как другие - строчными.

EIP-55 довольно прост в реализации. Мы берем хэш Keccak-256 шестнадцатеричного адреса в нижнем регистре. Этот хэш действует как цифровой отпечаток адреса, давая нам удобную контрольную сумму. Любое небольшое изменение входных данных (адреса) должно привести к значительному изменению результирующего хэша (контрольной суммы), что позволит нам эффективно обнаруживать ошибки. Затем хэш нашего адреса кодируется в заглавных буквах самого адреса. Давайте разберем это, шаг за шагом:

1. Хэшируйте адрес в нижнем регистре без префикса +0x+:

[[hash_lower_case_address]]
----
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9") =
23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1
----

[start=2]
1. Используйте заглавные буквы для каждого символа буквенного адреса, если соответствующая шестнадцатеричная цифра хэша больше или равна +0x8+. Это легче показать, если мы сопоставим адрес и хэш:

[[capitalize_input]]
----
Адрес: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
Хэш  : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
----

Наш адрес содержит буквенный символ +d+ в четвертой позиции. Четвертый символ хэша - +6+, что меньше, чем +8+. Итак, мы оставляем +d+ в нижнем регистре. Следующий буквенный символ в нашем адресе - +f+, в шестой позиции. Шестым символом шестнадцатеричного хэша является +c+, что больше, чем +8+. Поэтому мы пишем заглавными буквами +F+ в адресе и так далее. Как вы можете видеть, мы используем только первые 20 байт (40 шестнадцатеричных символов) хэша в качестве контрольной суммы, поскольку у нас есть только 20 байт (40 шестнадцатеричных символов) в адресе для соответствующего заглавного ввода.

Проверьте полученный адрес со смешанными заглавными буквами самостоятельно и посмотрите, сможете ли вы определить, какие символы были написаны с заглавной буквы и каким символам они соответствуют в хэше адреса.:

[[capitalize_output]]
----
Адрес: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
Хэш  : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
----

[[EIP55_error]]
===== Обнаружение ошибки в адресе с кодировкой EIP-55

((("EIP-55 (Ethereum Improvement Proposal 55)","detecting an error in an encoded address")))Теперь давайте посмотрим, как адреса EIP-55 помогут нам найти ошибку. Давайте предположим, что мы распечатали адрес Ethereum, который закодирован в EIP-55:

[[correct_address]]
----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
----

Теперь давайте допустим простую ошибку при чтении этого адреса. Предпоследний символ - это заглавная буква +F+. Для этого примера давайте предположим, что мы неправильно истолковали ее как заглавную букву +E+, и мы вводим следующий (неправильный) адрес в наш кошелек:

[[incorrect_address]]
----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
----

К счастью, наш кошелек совместим с EIP-55! Он замечает смешанные заглавные и строчные буквы и пытается подтвердить адрес. Он преобразует его в нижний регистр и вычисляет хэш контрольной суммы:

[[hash_demo]]
----
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9") =
5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927
----

Как вы можете видеть, несмотря на то, что адрес изменился только на один символ (фактически, только на один бит, поскольку +e + и +f+ разделены одним битом), хэш адреса радикально изменился. Это свойство хэш-функций, которое делает их такими полезными для контрольных сумм!

Теперь давайте выстроим их в ряд и проверим заглавные буквы:

[[incorrect_capitalization]]
----
001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
5429b5d9460122fb4b11af9cb88b7bb76d892886...
----

Это все неправильно! Некоторые буквенные символы неправильно написаны заглавными буквами. Помните, что заглавные буквы - это кодировка правильной контрольной суммы.

Заглавные буквы адреса, который мы вводим, не соответствуют только что вычисленной контрольной сумме, что означает, что в адресе что-то изменилось, и была допущена pass:[<span class="keep-together">ошибка</span>](((range="endofrange", startref="ix_04keys-addresses-asciidoc21")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc20")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc19"))).(((range="endofrange", startref="ix_04keys-addresses-asciidoc15")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc14")))


[[keys-addresses-conclusions]]
=== Заключение

В этой главе мы представили краткий обзор криптографии с открытым ключом и сосредоточились на использовании открытых и закрытых ключей в Ethereum и использовании криптографических инструментов, таких как хэш-функции, при создании и проверке адресов Ethereum. Мы также рассмотрели цифровые подписи и то, как они могут продемонстрировать владение закрытым ключом, не раскрывая этот закрытый ключ. В <<wallets_chapter>> мы объединим эти идеи и рассмотрим, как кошельки можно использовать для управления коллекциями ключей.(((range="endofrange", startref="ix_04keys-addresses-asciidoc0")))

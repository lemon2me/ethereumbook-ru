[[keys_addresses]]
== Криптография

((("cryptography", id="ix_04keys-addresses-asciidoc0", range="startofrange")))Одной из основополагающих технологий Ethereum является ((("cryptography","defined"))) _крипторафия_ (_cryptography_), которая является разделом математики, широко используемым в компьютерной безопасности. Криптография в переводе с греческого означает "секретное письмо", но изучение криптографии включает в себя нечто большее, чем просто секретное письмо, которое называется _encryption_. Криптография может, например, также использоваться для доказательства знания секрета без раскрытия этого секрета (например, с помощью цифровой подписи) или для доказательства подлинности данных (например, с помощью цифровых отпечатков пальцев, также известных как "хэши"). Эти типы криптографических доказательств являются математическими инструментами, критически важными для работы платформы Ethereum (и, действительно, всех систем блокчейна), а также широко используются в приложениях Ethereum. ((("encryption", seealso="keys and addresses")))

Обратите внимание, что на момент публикации ни одна часть протокола Ethereum не включает шифрование; то есть все коммуникации с платформой Ethereum и между узлами (включая данные транзакций) не зашифрованы и могут (обязательно) быть прочитаны кем угодно. Это делается для того, чтобы каждый мог проверить правильность обновлений состояния и консенсус был бы достигнут. В будущем будут доступны передовые криптографические инструменты, такие как доказательства с нулевым знанием и гомоморфное шифрование, которые позволят записывать некоторые зашифрованные вычисления в блокчейн, сохраняя при этом консенсус; однако, несмотря на то, что для них были предусмотрены средства, они еще не развернуты. 

В этой главе мы представим некоторые криптографии, используемые в Ethereum, а именно криптографию с открытым ключом (PKC), которая используется для контроля владения средствами в виде приватных ключей и адресов.

[[keys_addresses_intro]]
=== Ключи и адреса

((("cryptography","keys and addresses")))((("EOA (Externally Owned Account)","keys and addresses")))((("keys and addresses")))Как мы видели ранее в книге, у Ethereum есть два разных типа учетных записей: учетные записи, принадлежащие внешним пользователям (EOAs), и контракты. Право собственности на эфир со стороны EOAs устанавливается с помощью цифровых приватных ключей, адресов Ethereum и цифровых подписей. ((("private keys", seealso="keys and addresses")))Приватные ключи лежат в основе всего взаимодействия пользователя с Ethereum. Фактически, адреса учетных записей выводятся непосредственно из закрытых ключей: закрытый ключ однозначно определяет один адрес Ethereum, также известный как _учётная запись_ (_account_).

Приватные ключи никоим образом не используются непосредственно в системе Ethereum; они никогда не передаются и не хранятся в Ethereum. То есть приватные ключи должны оставаться закрытыми и никогда не появляться в сообщениях, передаваемых в сеть, а также не должны храниться в сети; только адреса учетных записей и цифровые подписи когда-либо передаются и хранятся в системе Ethereum. Для получения дополнительной информации о том, как сохранить приватные ключи в безопасности, см. <<control_responsibility>> и <<wallets_chapter>>.

((("digital signatures")))Доступ к средствам и контроль над ними осуществляются с помощью цифровых подписей, которые также создаются с использованием приватного ключа. Транзакции Ethereum требуют, чтобы действительная цифровая подпись была включена в блокчейн. Любой, у кого есть копия приватного ключа, имеет контроль над соответствующей учетной записью и любым эфиром, который она хранит. Предполагая, что пользователь хранит свой приватный ключ в безопасности, цифровые подписи в транзакциях Ethereum доказывают истинного владельца средств, поскольку они подтверждают право собственности на приватный ключ.

((("key pairs")))В системах, основанных на криптографии с открытым ключом, таких как используемая в Ethereum, ключи представлены парами, состоящими из приватного (секретного) ключа и открытого ключа. Представьте, что открытый ключ похож на номер банковского счета, а приватный ключ похож на секретный PIN-код; именно последний обеспечивает контроль над учетной записью, а первый идентифицирует ее для других. Сами приватные ключи очень редко видны пользователям Ethereum; по большей части они хранятся (в зашифрованном виде) в специальных файлах и управляются программным обеспечением Ethereum кошельков.

В платежной части транзакции Ethereum предполагаемый получатель представлен адресом Ethereum, который используется таким же образом, как и реквизиты счета получателя банковского перевода. Как мы вскоре увидим более подробно, адрес Ethereum для EOA генерируется из части открытого ключа пары ключей. Однако не все адреса Ethereum представляют пары открытого и закрытого ключей; они также могут представлять контракты, которые, как мы увидим в <<smart_contracts_chapter>>, не поддерживаются закрытыми ключами.

В остальной части этой главы мы сначала более подробно рассмотрим основы криптографии и объясним математику, используемую в Ethereum. Затем мы рассмотрим, как генерируются, хранятся и управляются ключи. Наконец, мы рассмотрим различные форматы кодирования, используемые для представления закрытых ключей, открытых ключей и адресов.

[[pkc]]
=== Криптография с открытым ключом и криптовалюта

((("cryptography","public key cryptography and cryptocurrency", id="ix_04keys-addresses-asciidoc1", range="startofrange")))((("public key cryptography", id="ix_04keys-addresses-asciidoc2", range="startofrange")))Криптография с открытым ключом (также называемая "асимметричной криптографией") является основной частью современной информационной безопасности. ((("Diffie, Whitfield")))((("Hellman, Martin")))((("key exchange protocol")))((("Merkle, Ralph")))Протокол обмена ключами, впервые опубликованный в 1970-х годах Мартином Хеллманом, Уитфилдом Диффи и Ральфом Мерклом, стал монументальным прорывом, который вызвал первую большую волну общественного интереса к области криптографии. До 1970-х годов сильные криптографические знания хранились в секрете pass:[<span class="keep-together">правительствами</span>].

Криптография с открытым ключом использует уникальные ключи для защиты информации. Эти ключи основаны на математических функциях, которые обладают особым свойством: их легко вычислить, но трудно вычислить их обратное значение. Основываясь на этих функциях, криптография позволяет создавать цифровые секреты и цифровые подписи, которые невозможно подделать и которые защищены законами математики.

Например, умножение двух больших простых чисел вместе является тривиальным. ((("prime factorization")))Но, учитывая произведение двух больших простых чисел, очень трудно найти простые множители (проблема, называемая _prime factorization_). Допустим, мы представляем число 8 018,009 и говорим вам, что оно является произведением двух простых чисел. Найти эти два простых числа для вас гораздо сложнее, чем для меня было умножить их, чтобы получить 8 018 009.

((("trapdoor functions")))Некоторые из этих математических функций можно легко инвертировать, если вы знаете какую-то секретную информацию. В предыдущем примере, если я скажу вам, что один из простых множителей равен 2,003, вы можете тривиально найти другой с помощью простого деления: 8,018,009 ÷ 2,003 = 4,003. Такие функции часто называют _односторонние функции с потайным входом_ (_trapdoor functions_), потому что их очень трудно инвертировать, если вам не предоставлена часть секретной информации, которую можно использовать в качестве короткого способа для обратного вызова функции.

((("elliptic curve cryptography")))Более продвинутая категория математических функций, которая полезна в криптографии, основана на арифметических операциях над эллиптической кривой. В арифметике эллиптических кривых умножение по модулю простого числа является простым, но деление (обратная операция) практически невозможно. ((("discrete logarithm problem")))Это называется проблемой дискретного логарифма (discrete logarithm problem), и в настоящее время нет известных лазеек. Криптография с эллиптической кривой (Elliptic curve cryptography) широко используется в современных компьютерных системах и является основой использования Ethereum'ом (и другими криптовалютами) закрытых ключей и цифровых подписей.

[NOTE]
====
Взгляните на следующие ресурсы, если вам интересно узнать больше о криптографии и математических функциях, которые используются в современной криптографии:

* http://bit.ly/2DcwNhn[Cryptography]

* http://bit.ly/2zeZV3c[Trapdoor function]

* http://bit.ly/2ACJjnV[Prime factorization]

* http://bit.ly/2Q7mZYI[Discrete logarithm]

* http://bit.ly/2zfeKCP[Elliptic curve cryptography]
====

В Ethereum мы используем криптографию с открытым ключом (также известную как асимметричная криптография) для создания пары открытый–закрытый ключ, о которой мы говорили в этой главе. Они считаются "парой", потому что открытый ключ является производным от закрытого ключа. Вместе они представляют учетную запись Ethereum, предоставляя, соответственно, общедоступное взаимодействие с учетной записью (адрес) и приватный контроль над доступом к любому эфиру в учетной записи и над любой аутентификацией, необходимой учетной записи при использовании смарт-контрактов. ((("digital signatures","private key and")))Закрытый ключ контролирует доступ, являясь уникальной информацией, необходимой для создания цифровых подписей (_digital signatures_), которые необходимы для подписания транзакций для расходования любых средств на счете. Цифровые подписи также используются для аутентификации владельцев или пользователей контрактов, как мы увидим в <<smart_contracts_chapter>>.

[TIP]
====
((("key pairs")))В большинстве реализаций кошелька закрытый и открытый ключи хранятся вместе в виде пары ключей для удобства. Однако открытый ключ может быть тривиально вычислен из закрытого ключа, поэтому также возможно хранение только закрытого ключа.
====

Цифровая подпись может быть создана для подписи любого сообщения. Для транзакций Ethereum в качестве сообщения используются сведения о самой транзакции. Математика криптографии &#x2014;в данном случае криптография с эллиптической кривой &#x2014; обеспечивает способ объединения сообщения (т.е. деталей транзакции) с закрытым ключом для создания кода, который может быть создан только со знанием закрытого ключа. Такой
код называется цифровой подписью. Обратите внимание, что транзакция Ethereum - это, по сути, запрос на доступ к определенной учетной записи с определенным адресом Ethereum. Когда транзакция отправляется в сеть Ethereum для перевода средств или взаимодействия со смарт-контрактами, ее необходимо отправить с цифровой подписью, созданной с помощью закрытого ключа от соответствующего адреса Ethereum. Математика с эллиптической кривой означает, что любой может проверить, что транзакция правильная, проверив, что цифровая подпись соответствует деталям транзакции и адресу Ethereum, к которому запрашивается доступ. Проверка вообще не связана с закрытым ключом; он остается закрытым. Однако процесс проверки, вне всякого сомнения, отзначает, что транзакция могла быть совершена только от кого-то с закрытым ключом, который соответствует открытому ключу, стоящему за адресом Ethereum. Это и есть "магия" криптографии с открытым ключом.


[TIP]
====
В протоколе Ethereum нет шифрования &#x2014; все сообщения, которые отправляются в рамках работы сети Ethereum, могут (обязательно) быть прочитаны всеми. Таким образом, закрытые ключи используются только для создания цифровых подписей для аутентификации транзакций.(((range="endofrange", startref="ix_04keys-addresses-asciidoc2")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc1")))
====

[[private_keys]]
=== Приватные ключи

((("private keys", id="ix_04keys-addresses-asciidoc3", range="startofrange")))Закрытый ключ - это просто число, выбранное случайным образом. Владение и контроль закрытого ключа является основой контроля пользователя над всеми средствами, связанными с соответствующим адресом Ethereum, а также доступом к контрактам, которые разрешают доступ к этому адресу. Закрытый ключ используется для создания подписей, необходимых для расходования эфира, путем подтверждения права собственности на средства, использованные в транзакции. ((("warnings and cautions","private key protection")))Закрытый ключ должен всегда оставаться секретным, поскольку раскрытие его третьим лицам равносильно предоставлению им контроля над эфиром и контрактами, защищенными этим закрытым ключом. Закрытый ключ также должен быть сохранен и защищен от случайной потери. Если он потерян, он не может быть восстановлен, и средства, защищенные им, тоже теряются навсегда.

[TIP]
====
Закрытый ключ Ethereum - это всего лишь число. Один из способов случайного выбора секретных ключей - это просто использовать монету, карандаш и бумагу: подбросьте монету 256 раз, и у вас будут двоичные цифры случайного секретного ключа, который вы можете использовать в кошельке Ethereum (возможно &#x2014; см. следующий раздел). Затем открытый ключ и адрес могут быть сгенерированы из закрытого ключа.
====

[[generating_private_key]]
==== Генерация приватного ключа из случайного числа

((("entropy","private key generation and")))((("private keys","generating from random number")))((("random numbers, private key generation from")))Первым и наиболее важным шагом в генерации ключей является поиск надежного источника энтропии, или случайности. Создание закрытого ключа Ethereum, по сути, включает в себя выбор числа от 1 до 2^256^. Сам метод, который вы используете для выбора этого числа, не имеет значения, если он не является предсказуемым или детерминированным. Программное обеспечение Ethereum использует генератор случайных чисел базовой операционной системы для получения 256 случайных битов. Обычно генератор случайных чисел операционной системы инициализируется человеческим источником случайности, поэтому вас могут попросить пошевелить мышью в течение нескольких секунд или нажать случайные клавиши на клавиатуре. Альтернативой может быть шум космического излучения на микрофонном канале компьютера.

Точнее, закрытый ключ может быть любым ненулевым числом вплоть до очень большого числа, чуть меньшего, чем 2^256^ &#x2014; огромное 78-значное число, примерно 1,158 * 10^77^. Точное число разделяет первые 38 цифр с 2^256^ и определяется как порядок эллиптической кривой, используемой в Ethereum (см. <<elliptic_curve>>). Чтобы создать закрытый ключ, мы случайным образом выбираем 256-битное число и проверяем, находится ли оно в допустимом диапазоне. В терминах программирования это обычно достигается путем подачи еще большей строки случайных битов (собранных из криптографически защищенного источника случайности) в 256-битный алгоритм хэширования, такой как Keccak-256 или SHA-256, оба из которых будут удобно выдавать 256-битное число. Если результат находится в допустимом диапазоне, у нас есть подходящий закрытый ключ. В противном случае мы просто повторяем попытку с другим случайным числом.

[TIP]
====
2^256^&#x2014;размер пространства закрытых ключей Ethereum &#x2014; - это непостижимо большое число. Это приблизительно 10^77^ в десятичной системе счисления; то есть число с 77 цифрами. Для сравнения, по оценкам, видимая вселенная содержит от 10^77 до 10^80 атомов. Следовательно, в нижнем диапазоне достаточно закрытых ключей, чтобы предоставить каждому атому во вселенной учетную запись Ethereum. Если вы выберете закрытый ключ случайным образом, нет никакого мыслимого способа, которым кто-либо когда-либо угадает его или выберет сам.
====

Обратите внимание, что процесс генерации закрытого ключа является автономным; он не требует какой-либо связи с сетью Ethereum или вообще какой-либо связи с кем-либо. Таким образом, для того, чтобы выбрать число, которое никто другой никогда не выберет, оно должно быть действительно случайным. Если вы сами выберете число, вероятность того, что кто-то другой попробует его (а затем сбежит с вашим эфиром), слишком высока. Использование плохого генератора случайных чисел (например, псевдослучайной функции +rand+ в большинстве языков программирования) еще хуже, потому что это еще более очевидно и еще проще воспроизвести. Как и в случае с паролями для онлайн-аккаунтов, закрытый ключ должен быть не поддающимся угадыванию. К счастью, вам никогда не нужно запоминать свой закрытый ключ, поэтому вы можете выбрать наилучший из возможных подходов к его выбору, а именно истинную случайность.

[WARNING]
====
Do not write your own code to create a random number or use a "simple" random number generator offered by your programming language. It is vital that you use a cryptographically secure pseudo-random number generator (such as CSPRNG) with a seed from a source of sufficient entropy. Study the documentation of the random number generator library you choose to make sure it is cryptographically secure. Correct implementation of the CSPRNG library is critical to the security of the keys.
====

Ниже приведен случайно сгенерированный закрытый ключ, отображаемый в шестнадцатеричном формате (256 бит отображаются в виде 64 шестнадцатеричных цифр, каждые 4 бита):(((range="endofrange", startref="ix_04keys-addresses-asciidoc3")))

[[prv_key_example]]
----
f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
----


[[pubkey]]
=== Открытые ключи

((("cryptography","public keys", id="ix_04keys-addresses-asciidoc4", range="startofrange")))((("elliptic curve cryptography","public key generation", id="ix_04keys-addresses-asciidoc5", range="startofrange")))((("public keys", seealso="keys and addresses", id="ix_04keys-addresses-asciidoc6", range="startofrange")))Открытый ключ Ethereum - это _точка_ (_point_) на эллиптической кривой, что означает, что это набор _x_ и _y_ координат, которые удовлетворяют уравнению эллиптической кривой.

Проще говоря, открытый ключ Ethereum - это два числа, соединенные вместе. Эти числа получаются из закрытого ключа путем вычисления, которое может идти только в одну сторону. Это означает, что тривиально вычислить открытый ключ, если у вас есть закрытый ключ, но вы не можете вычислить закрытый ключ из открытого ключа.

[WARNING]
====
МАТЕМАТИКА вот-вот произойдет! Не паникуй. Если вы начнете теряться в каком-либо пункте следующих параграфов, вы можете пропустить следующие несколько разделов. Существует множество инструментов и библиотек, которые сделают математику за вас.
====

Открытый ключ вычисляется из закрытого ключа с использованием умножения на эллиптическую кривую, которое практически необратимо: _K_ = _k_ * _G_, где _k_ - закрытый ключ, _G_ - константная точка, называемая ((("generator point")))_точкой создания_ (_generator point_), _K_ - результирующий открытый ключ, и * - это специальный оператор "умножения" эллиптической кривой. Обратите внимание, что умножение на эллиптической кривой не похоже на обычное умножение. Оно имеет общие функциональные атрибуты с обычным умножением, но на этом все. Например, обратная операция (которая была бы делением для нормальных чисел), известная как "нахождение дискретного логарифма", т.е. Вычисление _k_, если вы знаете __K__ &#x2014; так же сложно, как попробовать перебрать все возможные значения _k_ (грубый-принудительный поиск, который, вероятно, займет больше времени, чем позволит эта вселенная).

Проще говоря: арифметика на эллиптической кривой отличается от "обычной" целочисленной арифметики. Точка (_G_) может быть умножена на целое число (_k_), чтобы получить другую точку (_K_). Но такого понятия, как _деление_ (_division_), не существует, поэтому невозможно просто "разделить" открытый ключ _K_ на точку _G_, чтобы вычислить закрытый ключ _k_. Это односторонняя математическая функция, описанная в <<pkc>>.

[NOTE]
====
((("one-way functions")))Умножение по эллиптической кривой - это тип функции, которую криптографы называют "односторонней" функцией: ее легко выполнить в одном направлении (умножение) и невозможно выполнить в обратном направлении (деление). Владелец закрытого ключа может легко создать открытый ключ, а затем поделиться им со всем миром, зная, что никто не сможет выполнить обратную операцию и вычислить закрытый ключ по открытому ключу. Этот математический трюк становится основой для невзламываемых и безопасных цифровых подписей, которые подтверждают право собственности на средства Ethereum и контроль над контрактами.
====

Прежде чем мы продемонстрируем, как сгенерировать открытый ключ из закрытого ключа, давайте рассмотрим криптографию с эллиптической кривой немного подробнее.


[[elliptic_curve]]
==== Объяснение криптографии с эллиптической кривой

((("elliptic curve cryptography","basics", id="ix_04keys-addresses-asciidoc7", range="startofrange")))Elliptic ((("elliptic curve cryptography", id="ix_04keys-addresses-asciidoc8", range="startofrange")))((("public keys","elliptic curve cryptography and", id="ix_04keys-addresses-asciidoc9", range="startofrange")))curve cryptography is a type of asymmetric or public key cryptography based on the discrete logarithm problem as expressed by addition and multiplication on the points of an elliptic curve.

<<ecc-curve>> is an example of an elliptic curve, similar to that used by Ethereum.

[NOTE]
====
((("secp256k1 elliptic curve", id="ix_04keys-addresses-asciidoc10", range="startofrange")))Ethereum uses the exact same elliptic curve, called +secp256k1+, as Bitcoin. That makes it possible to reuse many of the elliptic curve libraries and tools from Bitcoin.
====

[[ecc-curve]]
.A visualization of an elliptic curve
image::images/simple_elliptic_curve.png["ecc-curve"]

Ethereum uses a specific elliptic curve and set of mathematical constants, as defined in a standard called +secp256k1+, established by the US National Institute of Standards and Technology (NIST). The +secp256k1+ curve is defined by the following function, which produces an elliptic curve:

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <mrow>
      <msup><mi>y</mi> <mn>2</mn> </msup>
      <mo>=</mo>
      <mrow>
        <mo>(</mo>
        <msup><mi>x</mi> <mn>3</mn> </msup>
        <mo>+</mo>
        <mn>7</mn>
        <mo>)</mo>
      </mrow>
    </mrow>
    <mspace width="3.33333pt"/>
    <mtext>over</mtext>
    <mspace width="3.33333pt"/>
    <mrow>
      <mo>(</mo>
      <msub><mi>&#x1d53d;</mi> <mi>p</mi> </msub>
      <mo>)</mo>
    </mrow>
  </mrow>
</math>
</div>
++++

or:

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <msup><mi>y</mi> <mn>2</mn> </msup>
    <mspace width="3.33333pt"/>
    <mo form="prefix">mod</mo>
    <mspace width="0.277778em"/>
    <mi>p</mi>
    <mo>=</mo>
    <mrow>
      <mo>(</mo>
      <msup><mi>x</mi> <mn>3</mn> </msup>
      <mo>+</mo>
      <mn>7</mn>
      <mo>)</mo>
    </mrow>
    <mspace width="3.33333pt"/>
    <mo form="prefix">mod</mo>
    <mspace width="0.277778em"/>
    <mi>p</mi>
  </mrow>
</math>
</div>
++++

The _mod p_ (modulo prime number _p_) indicates that this curve is over a finite field of prime order _p_, also written as latexmath:[\( \mathbb{F}_p \)], where _p_ = 2^256^ – 2^32^ – 2^9^ – 2^8^ – 2^7^ – 2^6^ – 2^4^ – 1, which is a very large prime number.

Because this curve is defined over a finite field of prime order instead of over the real numbers, it looks like a pattern of dots scattered in two dimensions, which makes it difficult to visualize. However, the math is identical to that of an elliptic curve over real numbers. As an example, <<ecc-over-F17-math>> shows the same elliptic curve over a much smaller finite field of prime order 17, showing a pattern of dots on a grid. The +secp256k1+ Ethereum elliptic curve can be thought of as a much more complex pattern of dots on an unfathomably large grid.

[[ecc-over-F17-math]]
[role="smallersixty"]
.Elliptic curve cryptography: visualizing an elliptic curve over F(p), with p=17
image::images/ec_over_small_prime_field.png["ecc-over-F17-math"]

So, for example, the following is a point _Q_ with coordinates (_x_,_y_) that is a point on the +secp256k1+ curve:

[[coordinates_example]]
----
Q = 
(49790390825249384486033144355916864607616083520101638681403973749255924539515,
59574132161899900045862086493921015780032175291755807399284007721050341297360)
----

<<example_1>> shows how you can check this yourself using Python. The variables +x+ and +y+ are the coordinates of the point _Q_, as in the preceding example. The variable +p+ is the prime order of the elliptic curve (the prime that is used for all the modulo operations). The last line of Python is the elliptic curve equation (the +%+ operator in Python is the modulo operator). If +x+ and +y+ are indeed the coordinates of a point on the elliptic curve, then they satisfy the equation and the result is zero (+0L+ is a long integer with value zero). Try it yourself, by typing ++**python**++ on a command line and copying each line (after the prompt +>>>+) from the listing(((range="endofrange", startref="ix_04keys-addresses-asciidoc10"))).(((range="endofrange", startref="ix_04keys-addresses-asciidoc9")))

++++
<div data-type="example" id="example_1">
<h5>Using Python to confirm that this point is on the elliptic curve</h5>
<pre data-type="programlisting">
Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> <strong>p = 115792089237316195423570985008687907853269984665640564039457584007908834 \
671663</strong>
>>> <strong>x = 49790390825249384486033144355916864607616083520101638681403973749255924539515</strong>
>>> <strong>y = 59574132161899900045862086493921015780032175291755807399284007721050341297360</strong>
>>> <strong>(x ** 3 + 7 - y**2) % p</strong>
0L
</pre>
</div>
++++

[[EC_math]]
==== Elliptic Curve Arithmetic Operations

((("elliptic curve cryptography","arithmetic operations")))A lot of elliptic curve math looks and works very much like the integer arithmetic we learned at school. Specifically, we can define an addition operator, which instead of jumping along the number line is jumping to other points on the curve. Once we have the addition operator, we can also define multiplication of a point and a whole number, which is equivalent to repeated addition.

Elliptic curve addition is defined such that given two points _P_~1~ and _P_~2~ on the elliptic curve, there is a third point _P_~3~ = _P_~1~ + _P_~2~, also on the elliptic curve.

Geometrically, this third point _P_~3~ is calculated by drawing a line between _P_~1~ and _P_~2~. This line will intersect the elliptic curve in exactly one additional place (amazingly). Call this point _P_~3~' = (_x_, _y_). Then reflect in the x-axis to get _P_~3~ = (_x_, _–y_).

If _P_~1~ and _P_~2~ are the same point, the line "between" _P_~1~ and _P_~2~ should extend to be the tangent to the curve at this point _P_~1~. This tangent will intersect the curve at exactly one new point. You can use techniques from calculus to determine the slope of the tangent line. Curiously, these techniques work, even though we are restricting our interest to points on the curve with two integer coordinates!

In elliptic curve math, there is also a point called the "point at infinity," which roughly corresponds to the role of the number zero in addition. On computers, it's sometimes represented by _x_ = _y_ = 0 (which doesn't satisfy the elliptic curve equation, but it's an easy separate case that can be checked). There are a couple of special cases that explain the need for the point at infinity.

In some cases (e.g., if _P_~1~ and _P_~2~ have the same _x_ values but different _y_ values), the line will be exactly vertical, in which case _P_~3~ = the point at infinity.

If _P_~1~ is the point at infinity, then _P_~1~ + _P_~2~ = _P_~2~. Similarly, if _P_~2~ is the point at infinity, then _P_~1~ + _P_~2~ = _P_~1~. This shows how the point at infinity plays the role that zero plays in "normal" arithmetic.

It turns out that pass:[+] is associative, which means that (_A_ pass:[+] _B_) pass:[+] _C_ = _A_ pass:[+] (_B_ pass:[+] _C_). That means we can write _A_ pass:[+] _B_ pass:[+] _C_ (without parentheses) without ambiguity.

Now that we have defined addition, we can define multiplication in the standard way that extends addition. For a point _P_ on the elliptic curve, if _k_ is a whole number, then _k_ pass:[*] _P_ = _P_ pass:[+] _P_ pass:[+] _P_ pass:[+] ... pass:[+] _P_ (_k_ times). Note that _k_ is sometimes (perhaps confusingly) called an "exponent" in this case.(((range="endofrange", startref="ix_04keys-addresses-asciidoc8")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc7")))

[[public_key_derivation]]
==== Generating a Public Key

((("elliptic curve cryptography","public key generation with")))((("generator point")))((("public keys","generating")))Starting with a private key in the form of a randomly generated number _k_, we multiply it by a predetermined point on the curve called the _generator point_ _G_ to produce another point somewhere else on the curve, which is the corresponding public key _K_: 

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <mi>K</mi>
    <mo>=</mo>
    <mi>k</mi>
    <mo>*</mo>
    <mi>G</mi>
  </mrow>
</math>
</div>
++++

((("secp256k1 elliptic curve")))The generator point is specified as part of the +secp256k1+ standard; it is the same for all implementations of +secp256k1+, and all keys derived from that curve use the same point _G_. Because the generator point is always the same for all Ethereum users, a private key _k_ multiplied with _G_ will always result in the same public key _K_. The relationship between _k_ and _K_ is fixed, but can only be calculated in one direction, from _k_ to _K_. That's why an Ethereum address (derived from _K_) can be shared with anyone and does not reveal the user's private key (_k_).

As we described in the previous section, the multiplication of _k_ * _G_ is equivalent to repeated addition, so _G_ pass:[+] _G_ pass:[+] _G_ pass:[+] ... pass:[+] _G_, repeated _k_ times. In summary, to produce a public key _K_ from a private key _k_, we add the generator point _G_ to itself, _k_ times.

[TIP]
====
A private key can be converted into a public key, but a public key cannot be converted back into a private key, because the math only works one way.
====

Let's apply this calculation to find the public key for the specific private key we showed you in <<private_keys>>:


[[example_privkey]]
.Example private key to public key calculation
----
K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G
----

A cryptographic library can help us calculate _K_, using elliptic curve multiplication. The resulting public key _K_ is defined as the point:

----
K = (x, y)
----

where:

----
x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

((("SECG (Standards for Efficient Cryptography Group)")))((("Standards for Efficient Cryptography Group (SECG)")))In Ethereum you may see public keys represented as a serialization of 130 hexadecimal characters (65 bytes). This is adopted from a standard serialization format proposed by the industry consortium Standards for Efficient Cryptography Group (SECG), documented in http://www.secg.org/sec1-v2.pdf[Standards for Efficient Cryptography (SEC1)]. The standard defines four possible prefixes that can be used to identify points on an elliptic curve, listed in <<EC_prefix_table>>.

[[EC_prefix_table]]
.Serialized EC public key prefixes
[options="header"]
|===
| Prefix | Meaning | Length (bytes counting prefix)
| +0x00+ | Point at infinity | 1
| +0x04+ | Uncompressed point | 65
| +0x02+ | Compressed point with even +y+ | 33
| +0x03+ | Compressed point with odd +y+ | 33
|===

Ethereum only uses uncompressed public keys; therefore the only prefix that is relevant is (hex) +04+. The serialization concatenates the _x_ and _y_ coordinates of the public key:

[[concat_coordinates]]
----
04 + x-coordinate (32 bytes/64 hex) + y-coordinate (32 bytes/64 hex)
----

Therefore, the public key we calculated earlier is serialized as:

[[serialized_pubkey]]
----
046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0 \
c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

[[EC_lib]]
==== Elliptic Curve Libraries

((("elliptic curve cryptography","libraries")))((("secp256k1 elliptic curve")))There are a couple of implementations of the +secp256k1+ elliptic curve that are used in cryptocurrency-related projects:

((("OpenSSL cryptographic library")))https://www.openssl.org/[OpenSSL]:: The OpenSSL library offers a comprehensive set of cryptographic primitives, including a full implementation of +secp256k1+. For example, to derive the public key, the function +EC_POINT_mul+ can be used.

((("libsecp256k1 cryptographic library")))https://github.com/bitcoin-core/secp256k1[libsecp256k1]:: Bitcoin Core's +libsecp256k1+ is a C-language implementation of the +secp256k1+ elliptic curve and other cryptographic primitives. It was written from scratch to replace OpenSSL in Bitcoin Core software, and is considered superior in both performance and security.(((range="endofrange", startref="ix_04keys-addresses-asciidoc6")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc5")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc4")))

[[hash_functions]]
=== Cryptographic Hash Functions

((("cryptographic hash functions", id="ix_04keys-addresses-asciidoc11", range="startofrange")))((("cryptography","hash functions", id="ix_04keys-addresses-asciidoc12", range="startofrange")))((("hash functions", id="ix_04keys-addresses-asciidoc13", range="startofrange")))Cryptographic hash functions are used throughout Ethereum. In fact, hash functions are used extensively in almost all cryptographic systems&#x2014;a fact captured by ((("Schneier, Bruce")))pass:[<span class="keep-together">cryptographer</span>] http://bit.ly/2Q79qZp[Bruce Schneier], who said, "Much more than encryption algorithms, one-way hash functions are the workhorses of modern cryptography."

In this section we will discuss hash functions, explore their basic properties, and see how those properties make them so useful in so many areas of modern cryptography. We address hash functions here because they are part of the transformation of Ethereum public keys into addresses. ((("digital fingerprint")))They can also be used to create _digital fingerprints_, which aid in the verification of data.

((("one-way functions")))In simple terms, a http://bit.ly/2CR26gD[_hash function_] is &#x201c;any function that can be used to map data of arbitrary size to data of fixed size.&#x201d; ((("pre-image")))The input to a hash function is called a _pre-image_, the _message_, or simply the _input data_. The output is called the _hash_. http://bit.ly/2Jrn3jM[_Cryptographic hash functions_] are a special subcategory that have specific properties that are useful to secure platforms, such as Ethereum.

A cryptographic hash function is a _one-way_ hash function that maps data of arbitrary size to a fixed-size string of bits. The "one-way" nature means that it is computationally infeasible to recreate the input data if one only knows the output hash. The only way to determine a possible input is to conduct a brute-force search, checking each candidate for a matching output; given that the search space is virtually infinite, it is easy to understand the practical impossibility of the task. Even if you find some input data that creates a matching hash, it may not be the original input data: hash functions are "many-to-one" functions. ((("hash collision")))Finding two sets of input data that hash to the same output is called finding a _hash collision_. Roughly speaking, the better the hash function, the rarer hash collisions are. For Ethereum, they are effectively impossible.

((("hash functions","main properties")))Let's take a closer look at the main properties of cryptographic hash functions. These include:

Determinism:: A given input message always produces the same hash output.

Verifiability:: Computing the hash of a message is efficient (linear complexity).

Noncorrelation:: A small change to the message (e.g., a 1-bit change) should change the hash output so extensively that it cannot be correlated to the hash of the original message.

Irreversibility:: Computing the message from its hash is infeasible, equivalent to a brute-force search through all possible messages.

Collision protection:: It should be infeasible to calculate two different messages that produce the same hash output.

Resistance to hash collisions is particularly important for avoiding digital signature forgery in Ethereum.

The combination of these properties make cryptographic hash functions useful for a broad range of security applications, including:

* Data fingerprinting
* Message integrity (error detection)
* Proof of work
* Authentication (password hashing and key stretching)
* Pseudorandom number generators
* Message commitment (commit–reveal mechanisms)
* Unique identifiers

We will find many of these in Ethereum as we progress through the various layers of the system.

[[keccak256]]
==== Ethereum's Cryptographic Hash Function: Keccak-256

((("hash functions","Keccak-256")))((("Keccak-256 hash function")))((("SHA-3 Hash Function")))Ethereum uses the _Keccak-256_ cryptographic hash function in many places. Keccak-256 was designed as a candidate for the SHA-3 Cryptographic Hash Function Competition held in 2007 by the ((("National Institute of Standards and Technology (NIST)")))((("NIST (National Institute of Standards and Technology)")))National Institute of Standards and Technology. Keccak was the winning algorithm, which became standardized as ((("Federal Information Processing Standard (FIPS)")))((("FIPS (Federal Information Processing Standard)")))((("FIPS-202")))Federal Information Processing Standard (FIPS) 202 in 2015.

However, during the period when Ethereum was developed, the NIST standardization was not yet finalized. NIST adjusted some of the parameters of Keccak after the completion of the standards process, allegedly to improve its efficiency. This was occurring at the same time as heroic whistleblower ((("Snowden, Edward")))Edward Snowden revealed documents that imply that NIST may have been improperly influenced by the National Security Agency to intentionally weaken the ((("Dual_EC_DRBG")))Dual_EC_DRBG random-number generator standard, effectively placing a backdoor in the standard random number generator. The result of this controversy was a backlash against the proposed changes and a significant delay in the standardization of SHA-3. At the time, the Ethereum Foundation decided to implement the original Keccak algorithm, as proposed by its inventors, rather than the SHA-3 standard as modified by NIST.

[WARNING]
====
While you may see "SHA-3" mentioned throughout Ethereum documents and code, many if not all of those instances actually refer to Keccak-256, not the finalized FIPS-202 SHA-3 standard. The implementation differences are slight, having to do with padding parameters, but they are significant in that Keccak-256 produces different hash outputs from FIPS-202 SHA-3 for the same input.
====

[[which_hash]]
==== Which Hash Function Am I Using?

((("hash functions","test vector for determining")))((("test vector, determining hash functions with")))How can you tell if the software library you are using implements FIPS-202 SHA-3 or Keccak-256, if both might be called "SHA-3"?

An easy way to tell is to use a _test vector_, an expected output for a given input. ((("empty input test")))The test most commonly used for a hash function is the _empty input_. If you run the hash function with an empty string as input you should see the following results:

----
Keccak256("") =
  c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

SHA3("") =
  a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a
----


Regardless of what the function is called, you can test it to see whether it is the original Keccak-256 or the final NIST standard FIPS-202 SHA-3 by running this simple test. Remember, Ethereum uses Keccak-256, even though it is often called SHA-3 in the code.

[NOTE]
====
Due to the confusion created by the difference between the hash function used in Ethereum (Keccak-256) and the finalized standard (FIP-202 SHA-3), there is an effort underway to rename all instances of +sha3+ in all code, opcodes, and libraries to +keccak256+. See https://github.com/ethereum/EIPs/issues/59[EIP-59] for details.
====


Next, let's examine the first application of Keccak-256 in Ethereum, which is to produce Ethereum addresses from public keys.(((range="endofrange", startref="ix_04keys-addresses-asciidoc13")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc12")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc11")))

[[eth_address]]
=== Ethereum Addresses

((("addresses", id="ix_04keys-addresses-asciidoc14", range="startofrange")))((("cryptography","Ethereum addresses and", id="ix_04keys-addresses-asciidoc15", range="startofrange")))Ethereum addresses are _unique identifiers_ that are derived from public keys or contracts using the Keccak-256 one-way hash function.

In our previous examples, we started with a private key and used elliptic curve multiplication to derive a public key:

[role="pagebreak-before"]
Private key _k_:

----
k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
----

[[concat_pubkey]]
Public key _K_ (_x_ and _y_ coordinates concatenated and shown as hex):

----
K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e...
----

[NOTE]
====
It is worth noting that the public key is not formatted with the prefix (hex) +04+ when the address is calculated.
====

We use Keccak-256 to calculate the _hash_ of this public key:

[[calculate_hash]]
----
Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

Then we keep only the last 20 bytes (least significant bytes), which is our Ethereum address:

[[keep_last_20]]
----
001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

Most often you will see Ethereum addresses with the prefix +0x+ that indicates they are hexadecimal-encoded, like this:

[[hex_prefix]]
----
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

[[eth_address_format]]
==== Ethereum Address Formats

((("addresses","formats")))Ethereum addresses are hexadecimal numbers, identifiers derived from the last 20 bytes of the Keccak-256 hash of the public key.

((("checksum","in Ethereum address formats")))Unlike Bitcoin addresses, which are encoded in the user interface of all clients to include a built-in checksum to protect against mistyped addresses, Ethereum addresses are presented as raw hexadecimal without any checksum.

The rationale behind that decision was that Ethereum addresses would eventually be hidden behind abstractions (such as name services) at higher layers of the system and that checksums should be added at higher layers if necessary.

In reality, these higher layers were developed too slowly and this design choice led to a number of problems in the early days of the ecosystem, including the loss of funds due to mistyped addresses and input validation errors. Furthermore, because Ethereum name services were developed slower than initially expected, alternative encodings were adopted very slowly by wallet developers. We'll look at a few of the encoding options next.

[[ICAP]]
==== Inter Exchange Client Address Protocol

((("addresses","ICAP encoding", id="ix_04keys-addresses-asciidoc16", range="startofrange")))((("ICAP (Inter-exchange Client Address Protocol)", id="ix_04keys-addresses-asciidoc17", range="startofrange")))((("Inter-exchange Client Address Protocol (ICAP)", id="ix_04keys-addresses-asciidoc18", range="startofrange")))The _Inter exchange Client Address Protocol_ (ICAP) is an Ethereum address encoding that is partly compatible with the ((("IBAN (International Bank Account Number)")))((("International Bank Account Number (IBAN)")))International Bank Account Number (IBAN) encoding, offering a versatile, checksummed, and interoperable encoding for Ethereum addresses. ICAP addresses can encode Ethereum addresses or common names registered with an Ethereum name registry. You can read more about ICAP on the https://eth.wiki/en/ideas/inter-exchange-client-address-protocol-icap[Ethereum Wiki].

IBAN is an international standard for identifying bank account numbers, mostly used for wire transfers. It is broadly adopted in the European Single Euro Payments Area (SEPA) and beyond. IBAN is a centralized and heavily regulated service. ICAP is a decentralized but compatible implementation for Ethereum addresses.

An IBAN consists of a string of up to 34 alphanumeric characters (case-insensitive) comprising a country code, checksum, and bank account identifier (which is country-specific).

ICAP uses the same structure by introducing a nonstandard country code, &#x201c;XE,&#x201d; that stands for "Ethereum,&#x201d; followed by a two-character checksum and three possible variations of an account identifier:

Direct:: A big-endian base-36 integer comprised of up to 30 alphanumeric characters, representing the 155 least significant bits of an Ethereum address. Because this encoding fits less than the full 160 bits of a general Ethereum address, it only works for Ethereum addresses that start with one or more zero bytes. The advantage is that it is compatible with IBAN, in terms of the field length and checksum. Example: +XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD+ (33 characters long).

Basic:: Same as the Direct encoding, except that it is 31 characters long. This allows it to encode any Ethereum address, but makes it incompatible with IBAN field validation. Example: +XE18CHDJBPLTBCJ03FE9O2NS0BPOJVQCU2P+ (35 characters long).

Indirect:: Encodes an identifier that resolves to an Ethereum address through a name registry provider. It uses 16 alphanumeric characters, comprising an _asset identifier_ (e.g., ETH), a name service (e.g., XREG), and a 9-character human-readable name (e.g., KITTYCATS). Example: +XEpass:[##]ETHXREGKITTYCATS+ (20 characters long), where the +##+ should be replaced by the two computed checksum characters.

((("EthereumJS helpeth")))((("helpeth command-line tool")))We can use the +helpeth+ command-line tool to create ICAP addresses. You can get helpeth by installing it with:

++++
<pre data-type="programlisting">
$ <strong>npm install -g helpeth</strong>
</pre>
++++

If you don't have npm, you may have to install nodeJS first, which you can do by following the instructions at https://nodeJS.org. 

Now that we have helpeth, let's try creating an ICAP address with our example private key (prefixed with +0x+ and passed as a parameter to +helpeth+). 

++++
<pre data-type="programlisting">
$ <strong>helpeth keyDetails \
  -p 0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315</strong>

Address: 0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
ICAP: XE60 HAMI CDXS V5QX VJA7 TJW4 7Q9C HWKJ D
Public key: 0x6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b...
</pre>
++++

The +helpeth+ command constructs a hexadecimal Ethereum address as well as an ICAP address for us. The ICAP address for our example key is:

[[ICAP_example]]
----
XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD
----

Because our example Ethereum address happens to start with a zero byte, it can be encoded using the Direct ICAP encoding method that is valid in IBAN format. You can tell because it is 33 characters long.

If our address did not start with a zero, it would be encoded with the Basic encoding, which would be 35 characters long and invalid as an IBAN.

[TIP]
====
The chances of any Ethereum address starting with a zero byte are 1 in 256. To generate one like that, it will take on average 256 attempts with 256 different random private keys before we find one that works as an IBAN-compatible "Direct" encoded ICAP address.
====

At this time, ICAP is unfortunately only supported by a few wallets.(((range="endofrange", startref="ix_04keys-addresses-asciidoc18")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc17")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc16")))

[[EIP55]]
==== Hex Encoding with Checksum in Capitalization (EIP-55)

((("addresses","hex encoding with checksum in capitalization (EIP-55)", id="ix_04keys-addresses-asciidoc19", range="startofrange")))((("checksum","EIP-55 and", id="ix_04keys-addresses-asciidoc20", range="startofrange")))((("EIP-55 (Ethereum Improvement Proposal 55)","checksum for addresses", id="ix_04keys-addresses-asciidoc21", range="startofrange")))Due to the slow deployment of ICAP and name services, a standard was proposed by https://github.com/Ethereum/EIPs/blob/master/EIPS/eip-55.md[Ethereum Improvement Proposal 55 (EIP-55)]. EIP-55 offers a backward-compatible checksum for Ethereum addresses by modifying the capitalization of the hexadecimal address. The idea is that Ethereum addresses are case-insensitive and all wallets are supposed to accept Ethereum addresses expressed in capital or lowercase characters, without any difference in interpretation.

By modifying the capitalization of the alphabetic characters in the address, we can convey a checksum that can be used to protect the integrity of the address against typing or reading mistakes. Wallets that do not support EIP-55 checksums simply ignore the fact that the address contains mixed capitalization, but those that do support it can validate it and detect errors with a 99.986% accuracy.

The mixed-capitals encoding is subtle and you may not notice it at first. Our example address is:

----
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

With an EIP-55 mixed-capitalization checksum it becomes:

[[mixed_capitalization]]
----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
----

Can you tell the difference? Some of the alphabetic (A&#x2013;F) characters from the hexadecimal encoding alphabet are now capital, while others are lowercase.

EIP-55 is quite simple to implement. We take the Keccak-256 hash of the lowercase hexadecimal address. This hash acts as a digital fingerprint of the address, giving us a convenient checksum. Any small change in the input (the address) should cause a big change in the resulting hash (the checksum), allowing us to detect errors effectively. The hash of our address is then encoded in the capitalization of the address itself. Let's break it down, step by step:

1. Hash the lowercase address, without the +0x+ prefix:

[[hash_lower_case_address]]
----
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9") =
23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1
----

[start=2]
1. Capitalize each alphabetic address character if the corresponding hex digit of the hash is greater than or equal to +0x8+. This is easier to show if we line up the address and the hash:

[[capitalize_input]]
----
Address: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
----

Our address contains an alphabetic character +d+ in the fourth position. The fourth character of the hash is +6+, which is less than +8+. So, we leave the +d+ lowercase. The next alphabetic character in our address is +f+, in the sixth position. The sixth character of the hexadecimal hash is +c+, which is greater than +8+. Therefore, we capitalize the +F+ in the address, and so on. As you can see, we only use the first 20 bytes (40 hex characters) of the hash as a checksum, since we only have 20 bytes (40 hex characters) in the address to capitalize appropriately.

Check the resulting mixed-capitals address yourself and see if you can tell which characters were capitalized and which characters they correspond to in the address hash:

[[capitalize_output]]
----
Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
----

[[EIP55_error]]
===== Detecting an error in an EIP-55 encoded address

((("EIP-55 (Ethereum Improvement Proposal 55)","detecting an error in an encoded address")))Now, let's look at how EIP-55 addresses will help us find an error. Let's assume we have printed out an Ethereum address, which is EIP-55 encoded:

[[correct_address]]
----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
----

Now let's make a basic mistake in reading that address. The character before the last one is a capital +F+. For this example let's assume we misread that as a capital +E+, and we type the following (incorrect) address into our wallet:

[[incorrect_address]]
----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
----

Fortunately, our wallet is EIP-55 compliant! It notices the mixed capitalization and attempts to validate the address. It converts it to lowercase, and calculates the checksum hash:

[[hash_demo]]
----
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9") =
5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927
----

As you can see, even though the address has only changed by one character (in fact, only one bit, as +e+ and +f+ are one bit apart), the hash of the address has changed radically. That's the property of hash functions that makes them so useful for checksums!

Now, let's line up the two and check the capitalization:

[[incorrect_capitalization]]
----
001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
5429b5d9460122fb4b11af9cb88b7bb76d892886...
----

It's all wrong! Several of the alphabetic characters are incorrectly capitalized. Remember that the capitalization is the encoding of the _correct_ checksum.

The capitalization of the address we input doesn't match the checksum just calculated, meaning something has changed in the address, and an error has been pass:[<span class="keep-together">introduced</span>](((range="endofrange", startref="ix_04keys-addresses-asciidoc21")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc20")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc19"))).(((range="endofrange", startref="ix_04keys-addresses-asciidoc15")))(((range="endofrange", startref="ix_04keys-addresses-asciidoc14")))


[[keys-addresses-conclusions]]
=== Conclusions

In this chapter we provided a brief survey of public key cryptography and focused on the use of public and private keys in Ethereum and the use of cryptographic tools, such as hash functions, in the creation and verification of Ethereum addresses. We also looked at digital signatures and how they can demonstrate ownership of a private key without revealing that private key. In <<wallets_chapter>>, we will put these ideas together and look at how wallets can be used to manage collections of keys.(((range="endofrange", startref="ix_04keys-addresses-asciidoc0")))

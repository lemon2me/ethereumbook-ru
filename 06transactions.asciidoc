[[tx_chapter]]
== Транзакции

((("transactions", id="ix_06transactions-asciidoc0", range="startofrange")))Транзакции - это подписанные сообщения, исходящие от внешней учетной записи (externally owned account) (EOA), передаваемые сетью Ethereum и записываемые в блокчейне Ethereum. Это базовое определение скрывает множество удивительных и увлекательных деталей. Другой способ взглянуть на транзакции заключается в том, что они являются единственными вещами, которые могут вызвать изменение состояния или вызвать выполнение контракта в EVM. Ethereum - это глобальный конечный автомат (единственный – singleton), и транзакции - это то, что заставляет этот конечный автомат "тикать", изменяя его состояние. Контракты не выполняются сами по себе. Ethereum не работает автономно. Все начинается с транзакции.

В этой главе мы проанализируем транзакции, покажем, как они работают, и рассмотрим детали. Обратите внимание, что большая часть этой главы адресована тем, кто заинтересован в управлении своими собственными транзакциями на низком уровне, возможно, потому, что они пишут приложение для кошелька; вам не нужно беспокоиться об этом, если вы довольны использованием существующих приложений для кошельков, хотя детали могут показаться вам интересными!

[[tx_struct]]
=== Структура транзакции

((("transactions","basic structure")))Сначала давайте взглянем на базовую структуру транзакции, поскольку она сериализуется и передается в сети Ethereum. Каждый клиент и приложение, получающие сериализованную транзакцию, будут хранить ее в памяти, используя свою собственную внутреннюю структуру данных, возможно, украшенную метаданными, которых нет в самой сетевой сериализованной транзакции. Сетевая сериализация - это единственная стандартная форма транзакции.

Транзакция - это сериализованное двоичное сообщение, содержащее следующие данные:

Одноразовый номер:: Порядковый номер, выданный отправителем EOA, используемый для предотвращения воспроизведения сообщения

Цена на газ:: Количество эфира (в wei), которое отправитель готов заплатить за каждую единицу газа

Лимит газа:: Максимальное количество газа, которое отправитель готов купить для данной транзакции

Получатель:: Адрес назначения Ethereum

Значение:: Количество эфира (в wei) для отправки в пункт назначения

Данные:: Полезная нагрузка двоичных данных переменной длины

v,r,s:: Три компонента цифровой подписи ECDSA исходного EOA

((("Recursive Length Prefix (RLP)")))((("RLP (Recursive Length Prefix)")))Структура сообщения транзакции сериализуется с использованием схемы кодирования рекурсивного префикса длины (RLP), которая была создана специально для простой, идеальной по байтам сериализации данных в Ethereum. Все числа в Ethereum кодируются как целые числа в порядке от старшего к младшему (big-endian), длина которых кратна 8 битам.

Обратите внимание, что метки полей (+to+, +gas limit+ и т.д.) показаны здесь для наглядности, но они не являются частью сериализованных данных транзакции, которые содержат значения полей в RLP-кодировке. Как правило, RLP не содержит никаких разделителей полей или меток. Префикс длины RLP используется для определения длины каждого поля. Все, что выходит за пределы заданной длины, относится к следующему полю в структуре.

Хотя это фактическая передаваемая структура транзакции, большинство внутренних представлений и визуализаций пользовательского интерфейса приукрашивают её дополнительной информацией, полученной из транзакции или из блокчейна.

Например, вы можете заметить, что в адресе, идентифицирующем отправителя EOA, отсутствуют данные &#x201c;from&#x201d;. Это связано с тем, что открытый ключ EOA может быть получен из компонентов +v,r,s+ подписи ECDSA. Адрес, в свою очередь, может быть получен из открытого ключа. Когда вы видите транзакцию с полем "от", это значит, что поле было добавлено программным обеспечением, используемым для визуализации транзакции. Другие метаданные, часто добавляемые к транзакции клиентским программным обеспечением, включают номер блока (после его майнинга и включения в блокчейн) и идентификатор транзакции (вычисляемый хэш). Опять же, эти данные получены из транзакции и не являются частью самого сообщения транзакции.

[[tx_nonce]]
=== Одноразовый номер (nonce – number once) транзакции

((("nonces", id="ix_06transactions-asciidoc1", range="startofrange")))((("transactions","nonces", id="ix_06transactions-asciidoc2", range="startofrange")))Одноразовый номер (nonce – number that can only be used once) является одним из наиболее важных и наименее понятных компонентов транзакции. Определение в Yellow Paper (см. <<references>>):

____
+nonce+: Скалярное значение, равное количеству транзакций, отправленных с этого адреса, или, в случае учетных записей с соответствующим кодом, количеству контрактов, созданных этой учетной записью.
____

Строго говоря, одноразовый номер является атрибутом исходного адреса; то есть он имеет значение только в контексте отправляющего адреса. Однако одноразовый номер явно не сохраняется как часть состояния учетной записи в блокчейне. Вместо этого он рассчитывается динамически, путем подсчета количества подтвержденных транзакций, которые были отправлены с адреса.

Существует два сценария, в которых важно наличие одноразового номера для подсчета транзакций: функция удобства использования транзакций, включаемых в порядок создания, и жизненно важная функция защиты от дублирования транзакций. Давайте рассмотрим пример сценария для каждого из этих:

1. Представьте, что вы хотите совершить две транзакции. Вам нужно произвести важный платеж в размере 6 эфиров, а также еще один платеж в размере 8 эфиров. Сначала вы подписываете и отправляете транзакцию в 6 эфиров, потому что она более важная, а затем вы подписываете и отправляете вторую транзакцию в 8 эфиров. К сожалению, вы упустили из виду тот факт, что на вашем аккаунте всего 10 эфиров, поэтому сеть не может принять обе транзакции: одна из них завершится неудачей. Поскольку вы сначала отправили более важное сообщение с 6 эфирами, вы, по понятным причинам, ожидаете, что оно пройдет, а сообщение с 8 эфирами будет отклонено. Однако в децентрализованной системе, такой как Ethereum, узлы могут получать транзакции в любом порядке; нет никакой гарантии, что конкретному узлу будет передана одна транзакция перед другой. Таким образом, почти наверняка произойдет так, что некоторые узлы сначала получат транзакцию с 6 эфирами, а другие сначала получат транзакцию с 8 эфирами. Без одноразового номера было бы определено случайным образом какая из них будет принята, а какая отклонена. Однако, если включить одноразовый номер, первая отправленная вами транзакция будет иметь одноразовый номер, скажем, 3, в то время как транзакция с 8 эфирами будет иметь следующее одноразовое значение (т.е. 4). Таким образом, эта транзакция будет игнорироваться до тех пор, пока не будут обработаны транзакции с одноразовыми номерами от 0 до 3, даже если она будет получена первой. Уф!


2. Теперь представьте, что у вас есть аккаунт со 100 эфирами. Фантастика! Вы находите кого-то в Интернете, кто примет оплату в эфире за виджет Макгаффина (mcguffin), который вы действительно хотите купить. Вы отправляете им 2 эфира, и они отправляют вам виджет Макгаффина. Прекрасно. Чтобы произвести этот платеж в 2 эфира, вы подписали транзакцию, отправив 2 эфира со своей учетной записи на их учетную запись, а затем передали ее в сеть Ethereum для проверки и включения в блокчейн. Теперь, без одноразового значения в транзакции, вторая транзакция, отправляющая 2 эфира на тот же адрес во второй раз, будет выглядеть точно так же, как и первая транзакция. Это означает, что любой, кто видит вашу транзакцию в сети Ethereum (что означает, что все, включая получателя или ваших врагов), могут "воспроизводить" транзакцию снова, снова и снова, пока весь ваш эфир не исчезнет, просто скопировав и вставив вашу исходную транзакцию и повторно отправив ее в сеть. Однако, поскольку значение nonce включено в данные транзакции, каждая отдельная транзакция уникальна, даже при многократной отправке одного и того же количества эфира на один и тот же адрес получателя. Таким образом, имея увеличивающийся одноразовый номер как часть транзакции, никто просто не сможет "дублировать" произведенный вами платеж.

Подводя итог, важно отметить, что использование одноразового номера на самом деле жизненно важно для протокола, основанного на _account-based_, в отличие от механизма вывода неизрасходованных транзакций (UTXO) протокола Биткойн.

[[tracking_nonce]]
==== Отслеживание одноразовых номеров (nonces)

((("nonces","keeping track of")))С практической точки зрения одноразовый номер - это актуальный подсчет количества _подтвержденных_ (т.е. внутри цепочки) транзакций, которые были произведены со счета. Чтобы узнать, что такое одноразовый номер, вы можете запросить блокчейн, например, через интерфейс web3. Откройте консоль JavaScript в Geth (или предпочитаемый вами интерфейс web3) в Ropsten testnet, затем введите:

++++
<pre data-type="programlisting">
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")</strong>
40
</pre>
++++

[TIP]
====
Одноразовый номер - это счетчик, основанный на нуле, что означает, что первая транзакция имеет одноразовый номер 0. В этом примере у нас есть количество транзакций 40, что означает, что были замечены одноразовые номера от 0 до 39. Одноразовый номер следующей транзакции должен быть равен 40.
====

Ваш кошелек будет отслеживать одноразовые номера для каждого адреса, которым он управляет. Это довольно просто сделать, если вы отправляете транзакции только из одной точки. Допустим, вы пишете свое собственное программное обеспечение для кошелька или какое-то другое приложение, которое инициирует транзакции. Как вы отслеживаете одноразовые номера?

Когда вы создаете новую транзакцию, вы назначаете следующий одноразовый номер в последовательности. Но до тех пор, пока он не будет подтвержден, он не будет учитываться в pass:[<span class="keep-together"><code>getTransactionCount</code></span>].

[[get_tx_count_bug]]
[WARNING]
====
Будьте осторожны при использовании функции pass:[<span class="keep-together"><code>getTransactionCount</code></span>] для подсчета ожидающих транзакций, потому что вы можете столкнуться с некоторыми проблемами, если отправите несколько транзакций подряд.
====

Let's look at an example:

++++
<pre data-type="programlisting">
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
40
&gt; <strong>web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});</strong>
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
41
&gt; <strong>web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});</strong>
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
41
&gt; <strong>web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});</strong>
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
41
</pre>
++++
[TIP]
====
Если вы пытаетесь воссоздать эти примеры кода самостоятельно в консоли javascript Geth, вам следует использовать web3.toWei() вместо web3.utils.toWei(). Это связано с тем, что Geth использует более старую версию библиотеки web3.
====

Как вы можете видеть, первая отправленная нами транзакция увеличила количество транзакций до 41, показав ожидающую транзакцию. Но когда мы отправили еще три транзакции в быстрой последовательности, вызов pass:[<span class="keep-together"><code>getTransactionCount</code></span>] не подсчитал их. Он насчитал только одну, хотя вы могли бы ожидать, что в mempool будет три ожидающих рассмотрения. Если мы подождем несколько секунд, чтобы сетевое взаимодействие закончилось, вызов pass:[<span class="keep-together"><code>getTransactionCount</code></span>] вернет ожидаемое число. Но в промежуточный период, пока на рассмотрении находится более одной транзакции, это может нам не помочь.

Когда вы создаете приложение, которое создает транзакции, оно не может полагаться на pass:[<span class="keep-together"><code>getTransactionCount</code></span>] для ожидающих транзакций. Только когда ожидающие и подтвержденные подсчеты равны (все незавершенные транзакции подтверждены), вы можете доверять выводам pass:[<span class="keep-together"><code>getTransactionCount</code></span>] для запуска вашего счетчика одноразовых номеров. После этого следите за одноразовым номером в вашем приложении до подтверждения каждой транзакции.

((("Четность","подсчет одноразовых номеров")))Интерфейс JSON RPC Parity предлагает функцию pass:[<span class="keep-together"><code>parity_nextNonce</code></span>], которая возвращает следующий одноразовый номер, который следует использовать в транзакция. Функция pass:[<span class="keep-together"><code>parity_nextNonce</code></span>] правильно подсчитывает одноразовые номера, даже если вы быстро создаете несколько транзакций подряд, не подтверждая их:

++++
<pre data-type="programlisting">
$ <strong>curl --data '{"method":"parity_nextNonce", \
  "params":["0x9e713963a92c02317a681b9bb3065a8249de124f"],\
  "id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST \
  localhost:8545</strong>

{"jsonrpc":"2.0","result":"0x32","id":1}
</pre>
++++

[[parity_curl]]
[TIP]
====
У Parity есть веб-консоль для доступа к интерфейсу JSON RPC, но здесь мы используем HTTP-клиент командной строки для доступа к нему.
====

[[gaps_nonce]]
==== Пробелы в одноразовых номерах, Повторяющиеся одноразовые номера и Подтверждение

((("nonces","gaps in sequence of")))Важно отслеживать одноразовые номера, если вы создаете транзакции программно, особенно если вы делаете это из нескольких независимых процессов pass:[<span class="keep-together">одновременно</span>].

Сеть Ethereum обрабатывает транзакции последовательно, на основе одноразового номера. Это означает, что если вы передадите транзакцию с одноразовым номером 0, а затем передадите транзакцию с одноразовым номером 2, вторая транзакция не будет включена ни в какие блоки. Она будет сохранена в mempool, в то время как сеть Ethereum ожидает появления отсутствующего одноразового номера. Все узлы будут предполагать, что отсутствующий одноразовый номер просто был отложен и что транзакция с одноразовым номером 2 была получена не по порядку.

Если затем вы передадите транзакцию с отсутствующим одноразовым номером 1, обе транзакции (одноразовые номера 1 и 2) будут обработаны и включены (если, конечно, они действительны). Как только вы восполните этот пробел, сеть сможет обработать транзакцию вне последовательности, которую она хранила в mempool.

Это означает, что если вы создадите несколько транзакций последовательно, и одна из них не будет официально включена ни в какие блоки, все последующие транзакции "застрянут", ожидая пропущенного одноразового номера. Транзакция может создать непреднамеренный "пробел" в последовательности одноразовых номеров, поскольку она недействительна или содержит недостаточно газа. Чтобы все снова сдвинулось с мертвой точки, вы должны передать действительную транзакцию с отсутствующим одноразовым номером. Вы также должны помнить, что как только транзакция с "отсутствующим" одноразовым номером будет подтверждена сетью, все ожидающие транзакции с последующими одноразовыми номерами постепенно станут действительными; "отозвать" транзакцию невозможно!

((("nonces","confirmation")))((("nonces","duplicated")))Если, с другой стороны, вы случайно продублируете одноразовый номер, например, передавая две транзакции с одним и тем же одноразовым номером, но с разными получателями или значениями, то одна из них будет подтверждена, и одна будет отклонена. Какая из них будет подтверждена, будет определяться последовательностью, в которой они поступают для проверки на первый узел, который их получает &#x2014; т.е. это будет довольно случайным образом.

Как вы можете видеть, отслеживание одноразовых номеров необходимо, и если ваше приложение неправильно управляет этим процессом, вы столкнетесь с проблемами. К сожалению, все становится еще сложнее, если вы пытаетесь делать это одновременно, как мы увидим в следующем разделе.

[[concurrency]]
==== Параллелизм, Инициирование транзакций и Одноразовые номера

((("concurrency, nonces and")))((("nonces","concurrency")))((("nonces","transaction origination")))Параллелизм - это сложный аспект информатики, и иногда он возникает неожиданно, особенно в децентрализованных и распределенных системах реального времени, таких как pass:[<span class="keep-together">Ethereum</span>].

Проще говоря, параллелизм - это когда у вас есть одновременные вычисления несколькими независимыми системами. Они могут быть в одной и той же программе (например, многопоточность), на одном и том же процессоре (например, многопроцессорная обработка) или на разных компьютерах (например, распределенных pass:[<span class="keep-together">системах</span>]). Ethereum, по определению, - это система, которая допускает параллелизм операций (узлов, клиентов, dApps), но обеспечивает единое для всех состояние посредством консенсуса.

Теперь представьте, что у вас есть несколько независимых приложений кошелька, которые генерируют транзакции с одного и того же адреса или адресов. Одним из примеров такой ситуации может быть обмен, обрабатывающий снятие средств с горячего кошелька (hot wallet) биржи (кошелька, ключи которого хранятся онлайн, в отличие от холодного кошелька, где ключи никогда не находятся в сети). В идеале вы хотели бы иметь несколько компьютеров, обрабатывающих снятие средств, чтобы это не стало узким местом или единственной точкой отказа. Однако это быстро становится проблематичным, поскольку наличие более чем одного компьютера, производящего снятие средств, приведет к некоторым сложным проблемам параллелизма, не последней из которых является выбор одноразовых номеров. Как координируются несколько компьютеров, генерирующих, подписывающих и транслирующих транзакции с одной и той же учетной записи hot wallet?

Вы могли бы использовать один компьютер для назначения одноразовых номеров в порядке живой очереди компьютерам, подписывающим транзакции. Однако этот компьютер теперь является единственной точкой отказа. Хуже того, если назначено несколько одноразовых номеров, и один из них никогда не используется (из-за сбоя в компьютере, обрабатывающем транзакцию с этим одноразовым номером), все последующие транзакции застревают.

Другим подходом было бы генерировать транзакции, но не присваивать им одноразовый номер (и, следовательно, оставлять их неподписанными &#x2014; помните, что одноразовый номер является неотъемлемой частью данных транзакции и поэтому должен быть включен в цифровую подпись, которая аутентифицирует транзакцию). Затем вы можете поместить их в очередь на один узел, который их подписывает, а также отслеживает одноразовые номера. Опять же, однако, это было бы затруднительным моментом в процессе: подписание и отслеживание одноразовых номеров - это та часть вашей операции, которая, вероятно, будет перегружена под нагрузкой, в то время как генерация неподписанной транзакции - это та часть, которую вам действительно не нужно распараллеливать. У вас был бы некоторый параллелизм, но его не хватало бы в критической части процесса.

В конце концов, эти проблемы с параллелизмом, в дополнение к сложности отслеживания остатков на счетах и подтверждений транзакций в независимых процессах, вынуждают большинство реализаций избегать параллелизма и создавать узкие места, такие как единый процесс, обрабатывающий все транзакции вывода средств на бирже, или настройка нескольких горячих кошельков, которые могут работать полностью независимо для снятия средств и нужно только периодически восстанавливать баланс на них.(((range="endofrange", startref="ix_06transactions-asciidoc2")))(((range="endofrange", startref="ix_06transactions-asciidoc1")))

[[tx_gas]]
=== Транзакционный газ

((("gas","transactions and", id="ix_06transactions-asciidoc3", range="startofrange")))((("transactions","gas", id="ix_06transactions-asciidoc4", range="startofrange")))Мы немного говорили о газе в предыдущих главах, и мы обсуждаем его более подробно в <<gas>>. Однако давайте рассмотрим некоторые основы касаемо роли компонентов +gasPrice+ и +gasLimit+ в транзакции.

Газ - это топливо Эфириума. Газ - это не эфир &#x2014; это отдельная виртуальная валюта со своим собственным обменным курсом по отношению к эфиру. Ethereum использует gas для контроля количества ресурсов, которые может использовать транзакция, поскольку она будет обрабатываться на тысячах компьютеров по всему миру. Открытая (полная по Тьюрингу) вычислительная модель требует некоторой формы учета, чтобы избежать атак типа "отказ в обслуживании" (DoS) или непреднамеренных транзакций, поглощающих ресурсы.

Gas отделен от эфира, чтобы защитить систему от нестабильности, которая может возникнуть вместе с быстрыми изменениями стоимости эфира, а также как способ управления важными и чувствительными соотношениями между затратами на различные ресурсы, за которые платит gas (а именно, вычисления, память и хранение).

((("gasPrice field")))Поле +gasPrice+ в транзакции позволяет инициатору транзакции установить цену, которую он готов заплатить в обмен на газ. Цена измеряется в вей за единицу газа. Например, в примере транзакции в <<intro_chapter>> ваш кошелек установил +gasPrice+ равным 3 гвеям (3 гигавея или 3 миллиарда вей).

[TIP]
====
Популярный сайт https://ethgasstation.info/[ethgasstation.info] предоставляет информацию о текущих ценах на газ и других соответствующих показателях газа для основной сети Ethereum.
====

Кошельки могут корректировать +цену на газ+ в транзакциях, которые они инициируют, чтобы добиться более быстрого подтверждения транзакций. Чем выше +цена на газ+, тем быстрее транзакция, скорее всего, будет подтверждена. И наоборот, транзакции с более низким приоритетом могут иметь более низкую цену, что приводит к более медленному подтверждению. Минимальная +цена на газ+ может быть установлена равной нулю, что означает транзакцию без комиссии. В периоды низкого спроса на место в блоке такие транзакции вполне могут быть добыты.

[NOTE]
====
Минимально приемлемая +цена на газ+ равна нулю. Это означает, что кошельки могут генерировать совершенно бесплатные транзакции. В зависимости от пропускной способности они могут никогда не быть подтверждены, но в протоколе нет ничего, что запрещало бы бесплатные транзакции. Вы можете найти несколько примеров таких транзакций, успешно включенных в блокчейн Ethereum.
====

[[gas_price_suggestion]]
Интерфейс web3 предлагает +цену на газ+, рассчитывая среднюю цену по нескольким блокам (для этого мы можем использовать консоль truffle или любую консоль JavaScript web3).:

++++
<pre data-type="programlisting">
> <strong>web3.eth.getGasPrice(console.log)</strong>
> null BigNumber { s: 1, e: 10, c: [ 10000000000 ] }
</pre>
++++

[[calc_gas_price]]
((("gasLimit field")))Второе важное поле, связанное с газом, - это +ограничение газа+. Проще говоря, +gasLimit+ дает максимальное количество единиц газа, которое инициатор транзакции готов купить для завершения транзакции. Для простых платежей, то есть транзакций, которые переводят эфир из одного EOA в другой EOA, необходимое количество газа фиксировано на уровне 21 000 единиц газа. Чтобы рассчитать, сколько эфира это будет стоить, вы умножаете 21 000 на + цену на газ +, которую вы готовы заплатить. Например:

++++
<pre data-type="programlisting">
> <strong>web3.eth.getGasPrice(function(err, res) {console.log(res*21000)} )</strong>
> 210000000000000
</pre>
++++

Если адрес назначения вашей транзакции является контрактом, то необходимое количество газа может быть оценено, но не может быть определено с точностью. Это связано с тем, что контракт может оценивать разные условия, которые приводят к разным путям исполнения, с разными общими затратами на газ. Контракт может выполнять только простые вычисления или более сложные, в зависимости от условий, которые находятся вне вашего контроля и не могут быть предсказаны. Чтобы продемонстрировать это, давайте рассмотрим пример: мы можем написать смарт-контракт, который увеличивает счетчик при каждом вызове и выполняет определенный цикл столько раз, сколько был вызван. Возможно, при 100-м вызове он выдает специальный приз, как в лотерее, но для расчета приза необходимо выполнить дополнительные вычисления. Если вы вызываете контракт 99 раз, происходит одно, но при 100-м вызове происходит что-то совсем другое. Количество газа, которое вы заплатили бы за это, зависит от того, сколько других транзакций вызывали эту функцию до того, как ваша транзакция была включена в блок. Возможно, ваша оценка основана на том, что это 99-я транзакция, но непосредственно перед тем, как ваша транзакция будет подтверждена, кто-то другой вызывает контракт в 99-й раз. Теперь вы вызываете 100-ю транзакцию, и вычислительные затраты (и стоимость газа) намного выше.

Чтобы позаимствовать распространенную аналогию, используемую в Ethereum, вы можете думать о +gasLimit+ как о емкости топливного бака в вашем автомобиле (ваш автомобиль - это транзакция). Вы наполняете бак таким количеством бензина, какое, по вашему мнению, потребуется для поездки (вычисление, необходимое для подтверждения вашей транзакции). Вы можете в какой-то степени оценить эту сумму, но в вашем путешествии могут произойти неожиданные изменения, такие как отклонение (более сложный маршрут выполнения), которые увеличат расход топлива.

Однако аналогия с топливным баком несколько вводит в заблуждение. На самом деле это больше похоже на кредитный счет компании-заправщика, где вы платите после завершения поездки, исходя из того, сколько бензина вы фактически израсходовали. Когда вы передаете свою транзакцию, одним из первых шагов проверки является проверка того, что на счете, с которого она была отправлена, достаточно эфира для оплаты +gasPrice * gasLimit+. Но сумма фактически не списывается с вашего счета до тех пор, пока транзакция не завершится. Вам выставляется счет только за газ, фактически потребленный вашей транзакцией, но перед отправкой транзакции у вас должно быть достаточно баланса для максимальной суммы, которую вы готовы заплатить.(((range="endofrange", startref="ix_06transactions-asciidoc4")))(((range="endofrange", startref="ix_06transactions-asciidoc3")))

[[tx_recipient]]
=== Получатель транзакции

((("transactions","recipient of")))Получатель транзакции указывается в поле +кому+. Он содержит 20-байтовый адрес Ethereum. Адрес может быть EOA или адресом контракта.

Ethereum не проводит дальнейшую проверку этого поля. Любое 20-байтовое значение считается допустимым. Если 20-байтовое значение соответствует адресу без соответствующего приватного ключа или без соответствующего контракта, транзакция все еще действительна. У Ethereum нет способа узнать, был ли адрес правильно получен из существующего открытого ключа (и, следовательно, из приватного ключа).

[WARNING]
====
Протокол Ethereum не проверяет адреса получателей в транзакциях. Вы можете отправить на адрес, у которого нет соответствующего приватного ключа или контракта, тем самым "сжигая" эфир, делая его навсегда неизрасходованным. Проверка должна выполняться на уровне пользовательского интерфейса.
====

((("ether burn")))Отправка транзакции по неправильному адресу, вероятно, _сожжет_ (_burn_) отправленный эфир, сделав его навсегда недоступным (неизрасходованным), поскольку большинство адресов не имеют известного приватного ключа, и поэтому для его использования не может быть сгенерирована подпись. Предполагается, что проверка адреса происходит на уровне пользовательского интерфейса (см. <<EIP55>>). На самом деле, существует ряд веских причин для сжигания эфира &#x2014; например, для препятствования мошенничеству в платежных каналах и других смарт-контрактах &#x2014; и поскольку количество эфира ограничено, сжигание эфира эффективно распределяет сожженную стоимость между всеми держателями эфира (пропорционально количеству эфира, которое они удерживают).

[[tx_value_data]]
=== Значение транзакции и её данные

((("transactions","value and data fields", id="ix_06transactions-asciidoc5", range="startofrange")))Основная "полезная нагрузка" транзакции содержится в  ((("data field", id="ix_06transactions-asciidoc6", range="startofrange")))((("value field", id="ix_06transactions-asciidoc7", range="startofrange")))двух полях: +значение+ и +данные+. Транзакции могут иметь как значение, так и данные, только значение, только данные или ни значения, ни данных. Все четыре комбинации возможны.

((("invocation")))((("payment")))Транзакция, имеющая только значение, является _платежом_ (_payment_). Транзакция, содержащая только данные, является _вызовом_ (_invocation_). Транзакция, содержащая как значение, так и данные, является одновременно платежом и вызовом. Транзакция, не имеющая ни ценности, ни данных &#x2014; ну, это, вероятно, просто пустая трата газа! Но это все еще возможно.

Давайте попробуем все эти комбинации. Сначала мы установим адреса источника и получателя из нашего кошелька, просто чтобы облегчить чтение демо-версии:

[source,javascript]
----
src = web3.eth.accounts[0];
dst = web3.eth.accounts[1];
----

Наша первая транзакция содержит только значение (платеж) и никаких полезных данных:

[[tx_value_nodata_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, \
  value: web3.utils.toWei(0.01, "ether"), data: ""});
----

На вашем кошельке появится экран подтверждения с указанием суммы для отправки, как показано на <<parity_txdemo_value_nodata>>.

[[parity_txdemo_value_nodata]]
.Кошелек Parity, показывающий транзакцию со значением, но без данных
image::images/parity_txdemo_value_nodata.png["Parity wallet showing a transaction with value, but no data"]


В следующем примере указывается как значение, так и полезная нагрузка в виде данных:

[[tx_value_data_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, \
  value: web3.utils.toWei(0.01, "ether"), data: "0x1234"});
----

Наш кошелек показывает экран подтверждения с указанием значения для отправки, а также полезной нагрузки с данными, как показано на <<parity_txdemo_value_data>>.

[[parity_txdemo_value_data]]
.Кошелек Parity, показывающий транзакцию со значением и данными
image::images/parity_txdemo_value_data.png["Parity wallet showing a transaction with value and data"]

Следующая транзакция включает в себя полезную нагрузку данных, но указывает нулевое значение (value):

[[tx_novalue_data_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, value: 0, data: "0x1234"});
----

Наш кошелек показывает экран подтверждения с указанием нулевого значения и полезной нагрузки данных, как показано на <<parity_txdemo_novalue_data>>.

[[parity_txdemo_novalue_data]]
.Кошелек Parity, показывающий транзакцию без значения, только с данными
image::images/parity_txdemo_novalue_data.png["Parity wallet showing a transaction with no value, only data"]

[role="pagebreak-before"]
Наконец, последняя транзакция не содержит ни значения для отправки, ни полезной нагрузки данных:

[[tx_novalue_nodata_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, value: 0, data: ""}));
----

На вашем кошельке отображается экран подтверждения с указанием нулевого значения, как показано на <<parity_txdemo_novalue_nodata>>.

[[parity_txdemo_novalue_nodata]]
.Кошелек Parity, показывающий транзакцию без ценности и без данных
image::images/parity_txdemo_novalue_nodata.png["Parity wallet showing a transaction with no value, and no data"]

[[value_EOA_contracts]]
==== Передача ценности EOAs и контрактам

((("EOA (Externally Owned Account)","transmitting value to")))((("smart contracts","transmitting value to")))((("transactions","transmitting value to EOAs and contract")))Когда вы создаете транзакцию Ethereum, содержащую значение, это эквивалентно _платежу_ (_payment_). Такие транзакции ведут себя по-разному в зависимости от того, является ли адрес назначения контрактом или нет.

Для адресов EOA, или, скорее, для любого адреса, который не помечен как контракт в блокчейне, Ethereum запишет изменение состояния, добавив отправленное вами значение к балансу адреса. Если адрес не был замечен ранее, он будет добавлен во внутреннее представление состояния клиента, а его баланс будет инициализирован значением вашего платежа.

Если адрес назначения (+to+) является контрактом, то EVM выполнит контракт и попытается вызвать функцию, указанную в полезной нагрузке данных вашей транзакции. Если в вашей транзакции нет данных, EVM вызовет функцию _fallback_ и, если эта функция подлежит оплате, выполнит ее, чтобы определить, что делать дальше. Если в резервной функции нет кода, то результатом транзакции будет увеличение баланса контракта, точно так же, как платеж на кошелек. Если нет резервной функции или не подлежащей оплате резервной функции, транзакция будет отменена.

Контракт может отклонять входящие платежи, вызывая исключение (exception) немедленно при вызове функции или в соответствии с условиями, закодированными в функции. Если функция завершается успешно (без исключения), то состояние контракта обновляется, чтобы отразить увеличение эфирного баланса контракта.(((range="endofrange", startref="ix_06transactions-asciidoc7")))(((range="endofrange", startref="ix_06transactions-asciidoc6")))

[[data_EOA]]
==== Передача полезной нагрузки данных в EOA или в контракт

((("data payload, transmitting to EOAs and contracts", id="ix_06transactions-asciidoc8", range="startofrange")))((("EOA (Externally Owned Account)","transmitting data payload to", id="ix_06transactions-asciidoc9", range="startofrange")))((("smart contracts","transmitting data payload to", id="ix_06transactions-asciidoc10", range="startofrange")))((("transactions","transmitting data payload to EOAs and contracts", id="ix_06transactions-asciidoc11", range="startofrange")))Когда ваша транзакция содержит данные, она, скорее всего, адресована на адрес контракта. Это не означает, что вы не можете отправить полезную нагрузку данных в EOA &#x2014;, которая полностью действительна в протоколе Ethereum. Однако в этом случае интерпретация данных зависит от кошелька, который вы используете для доступа к EOA. Он игнорируется протоколом Ethereum. Большинство кошельков также игнорируют любые данные, полученные в ходе транзакции с EOA, которую они контролируют. В будущем, возможно, могут появиться стандарты, которые позволят кошелькам интерпретировать данные так, как это делают контракты, тем самым позволяя транзакциям вызывать функции, работающие внутри пользовательских кошельков. Критическое различие заключается в том, что любая интерпретация полезной нагрузки данных EOA не подпадает под действие консенсусных правил Ethereum, в отличие от выполнения контракта pass:[<span class="keep-together"></span>].

На данный момент давайте предположим, что ваша транзакция доставляет данные на адрес контракта. ((("contract invocation")))((("invocation")))В этом случае данные будут интерпретироваться EVM как _вызов контракта_ (_contract invocation_). ((("function invocation")))Большинство контрактов используют эти данные более конкретно как _вызов функции_ (_function invocation_), вызывая именованную функцию и передавая любые закодированные аргументы функции.

Полезная нагрузка данных, отправляемая в ABI-совместимый контракт (которым, как вы можете предположить, являются все контракты), представляет собой шестнадцатеричную сериализованную кодировку:

Селектор (название) функций:: – это первые 4 байта хэша Keccak-256 прототипа функции. Это позволяет контракту однозначно определить, какую функцию вы хотите вызвать.

Аргументы функции:: Аргументы функции, закодированные в соответствии с правилами для различных элементарных типов, определенных в спецификации ABI.

В <<solidity_faucet_example>>, мы определили функцию для вывода средств:

[[withdraw_function_src]]
[source,solidity]
----
function withdraw(uint withdraw_amount) public {
----

((("prototype of a function")))_Прототип_ (_prototype_) функции определяется как строка, содержащая имя функции, за которым следуют типы данных каждого из ее аргументов, заключенные в круглые скобки и разделенные запятыми. Имя функции здесь - +withdraw+, и она принимает единственный аргумент, который является +uint+ (который является псевдонимом для +uint256+), поэтому прототипом +withdraw+ будет:

[source,solidity]
----
withdraw(uint256)
----

Давайте вычислим хэш Keccak-256 этой строки:

++++
<pre data-type="programlisting">
> <strong>web3.utils.sha3("withdraw(uint256)");</strong>
'0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f'
</pre>
++++

Первые 4 байта хэша равны +0x2e1a7d4d+. Это наше значение "function selector", которое укажет контракту, какую функцию мы хотим вызвать.

Далее давайте вычислим значение для передачи в качестве аргумента +withdraw_amount+. Мы хотим вывести 0,01 эфира. Давайте закодируем это в шестнадцатеричное сериализованное 256-битное целое число без знака в порядке от старшего к младшему, обозначенное в wei:

++++
<pre data-type="programlisting">
> <strong>withdraw_amount = web3.utils.toWei(0.01, "ether");</strong>
'10000000000000000'
> <strong>withdraw_amount_hex = web3.utils.toHex(withdraw_amount);</strong>
'0x2386f26fc10000'
</pre>
++++

Теперь мы добавляем селектор функций к сумме (дополненной до 32 байт).:

----
2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000
----

Это полезная нагрузка данных для нашей транзакции, вызывающая функцию +withdraw+ и запрашивающая 0,01 эфира в качестве +withdraw_amount+(((range="endofrange", startref="ix_06transactions-asciidoc11")))(((range="endofrange", startref="ix_06transactions-asciidoc10")))(((range="endofrange", startref="ix_06transactions-asciidoc9")))(((range="endofrange", startref="ix_06transactions-asciidoc8"))).(((range="endofrange", startref="ix_06transactions-asciidoc5")))

[[contract_reg]]
=== Специальная транзакция: создание контракта

((("contract creation transaction", id="ix_06transactions-asciidoc12", range="startofrange")))((("transactions","contract creation", id="ix_06transactions-asciidoc13", range="startofrange")))Один особый случай, который мы должны упомянуть, - это транзакция, которая _создает новый контракт_ на блокчейне, развертывая его для будущего использования.((("zero address","contract creation")))Транзакции создания контракта отправляются на специальный адрес назначения, называемый _нулевым адресом_ (_zero address_); поле +кому+ в транзакции регистрации контракта содержит адрес +0x0+. Этот адрес не представляет ни EOA (нет соответствующей пары закрытого и открытого ключей), ни контракта. Он никогда не сможет потратить эфир или инициировать транзакцию. Он используется только в качестве пункта назначения со специальным значением "создать этот контракт".

В то время как нулевой адрес предназначен только для создания контракта, он иногда получает платежи с разных адресов. ((("сжигание эфира"))) Этому есть два объяснения: либо это случайно, что приводит к потере эфира, либо это преднамеренное сжигание эфира (преднамеренное уничтожение эфира отправляя их на адрес, с которого они никогда не могут быть потрачены). Однако, если вы хотите выполнить преднамеренное сжигание эфира, вы должны четко сообщить о своем намерении сети и вместо этого использовать специально назначенный адрес записи:

[[burn_address]]
----
0x000000000000000000000000000000000000dEaD
----

[WARNING]
====
Любой эфир, отправленный на указанный адрес записи, станет нерастраченным и будет потерян навсегда.
====

Транзакция создания контракта должна содержать только полезную нагрузку с данными, содержащую скомпилированный байт-код, который создаст контракт. Единственным результатом этой транзакции является создание контракта. Вы можете указать сумму эфира в поле +значение+, если хотите настроить новый контракт с начальным балансом, но это совершенно необязательно. Если вы отправляете значение (эфир) на адрес создания контракта без полезной нагрузки данных (без контракта), то эффект будет таким же, как при отправке на адрес записи &#x2014; нет контракта для зачисления, поэтому эфир теряется.

В качестве примера мы можем создать контракт _Faucet.sol_, используемый в <<intro_chapter>>, вручную создав транзакцию на нулевой адрес с контрактом в полезной нагрузке данных. Контракт должен быть скомпилирован в представление байт-кода. Это можно сделать с помощью компилятора Solidity:

++++
<pre data-type="programlisting" class="pagebreak-before">
$ <strong>solc --bin Faucet.sol</strong>

Байт-код:
6060604052341561000f57600080fd5b60e58061001d6000396000f30060606040526004361060...
</pre>
++++

Ту же информацию также можно получить из онлайн-компилятора Remix.

Теперь мы можем создать транзакцию:

++++
<pre data-type="programlisting">
> <strong>src = web3.eth.accounts[0];</strong>
> <strong>faucet_code = \
  "0x6060604052341561000f57600080fd5b60e58061001d6000396000f300606...f0029";</strong>
> <strong>web3.eth.sendTransaction({from: src, to: 0, data: faucet_code, \
  gas: 113558, gasPrice: 200000000000});</strong>

"0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b"
</pre>
++++

Рекомендуется всегда указывать параметр +to +, даже в случае создания контракта с нулевым адресом, потому что стоимость случайной отправки вашего эфира на +0x0+ и потери его навсегда слишком велика. Вы также должны указать +цену на газ+ и +ограничение на газ+.

Как только контракт будет добыт, мы сможем увидеть его в проводнике блоков Etherscan, как показано на <<publish_contract_from_web3>>.

[[publish_contract_from_web3]]
.Etherscan, показывающий успешно добытый контракт
image::images/contract_published.png["Etherscan showing the contract successfully mined"]

Мы можем посмотреть квитанцию о транзакции, чтобы получить информацию о контракте:

++++
<pre data-type="programlisting">
> <strong>web3.eth.getTransactionReceipt( \
  "0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b");</strong>

{
  blockHash: "0x6fa7d8bf982490de6246875deb2c21e5f3665b4422089c060138fc3907a95bb2",
  blockNumber: 3105256,
  contractAddress: "0xb226270965b43373e98ffc6e2c7693c17e2cf40b",
  cumulativeGasUsed: 113558,
  from: "0x2a966a87db5913c1b22a59b0d8a11cc51c167a89",
  gasUsed: 113558,
  logs: [],
  logsBloom: \
    "0x00000000000000000000000000000000000000000000000000...00000",
  status: "0x1",
  to: null,
  transactionHash: \
    "0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b",
  transactionIndex: 0
}
</pre>
++++

Она включает в себя адрес контракта, который мы можем использовать для отправки средств и получения средств по контракту, как показано в предыдущем разделе:

++++
<pre data-type="programlisting">
> <strong>contract_address = "0xb226270965b43373e98ffc6e2c7693c17e2cf40b"</strong>
> <strong>web3.eth.sendTransaction({from: src, to: contract_address, \
  value: web3.utils.toWei(0.1, "ether"), data: ""});</strong>

"0x6ebf2e1fe95cc9c1fe2e1a0dc45678ccd127d374fdf145c5c8e6cd4ea2e6ca9f"

> <strong>web3.eth.sendTransaction({from: src, to: contract_address, value: 0, data: \
  "0x2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000"});</strong>

"0x59836029e7ce43e92daf84313816ca31420a76a9a571b69e31ec4bf4b37cd16e"
</pre>
++++

Через некоторое время обе транзакции будут видны на Etherscan, как показано на <<publish_contract_transactions>>.(((range="endofrange", startref="ix_06transactions-asciidoc13")))(((range="endofrange", startref="ix_06transactions-asciidoc12")))

[[publish_contract_transactions]]
.Etherscan, показывающий транзакции для отправки и получения средств
image::images/published_contract_transactions.png["Etherscan showing the transactions for sending and receiving funds"]


[[digital_sign]]
=== Цифровые подписи

((("digital signatures", id="ix_06transactions-asciidoc14", range="startofrange")))((("transactions","digital signatures and", id="ix_06transactions-asciidoc15", range="startofrange")))До сих пор мы не вдавались в какие-либо подробности о цифровых подписях. В этом разделе мы рассмотрим, как работают цифровые подписи и как их можно использовать для представления доказательств владения закрытым ключом, не раскрывая этот закрытый ключ.

[[ecdsa]]
==== Алгоритм цифровой подписи с эллиптической кривой

((("digital signatures","ECDSA and")))((("Elliptic Curve Digital Signature Algorithm (ECDSA)","about")))Алгоритм цифровой подписи, используемый в Ethereum, - это _алгоритм цифровой подписи с эллиптической кривой_ (_Elliptic Curve Digital Signature Algorithm_) (ECDSA). Он основан на парах закрытого и открытого ключей на эллиптической кривой, как описано в <<elliptic_curve>>.

Цифровая подпись служит трем целям в Ethereum (см. следующую боковую панель). Во-первых, подпись доказывает, что владелец закрытого ключа, который косвенно является владельцем учетной записи Ethereum, _разрешил_ расходование эфира или выполнение контракта. ((("non-repudiation"))) Во-вторых, это гарантирует отсутствие отказа: доказательство авторизации неоспоримо. В-третьих, подпись доказывает, что данные транзакции не были и не могут быть изменены никем после подписания транзакции.

[[digital_signature_definition]]
.Определение цифровой подписи в Википедии
****
((("digital signatures","Wikipedia definition")))_Цифровая подпись_ - это математическая схема для представления подлинности цифровых сообщений или документов. Действительная цифровая подпись дает получателю основание полагать, что сообщение было создано известным отправителем (аутентификация), что отправитель не может отрицать отправку сообщения (неотказ) и что сообщение не было изменено при передаче (целостность).

_Источник: https://en.wikipedia.org/wiki/Digital_signature_
****

[[digital_sign_work]]
==== Как работают Цифровые подписи

((("digital signatures","mechanism of operation")))Цифровая подпись - это математическая схема, состоящая из двух частей. Первая часть - это алгоритм создания подписи с использованием закрытого ключа (ключа подписи) из сообщения (которым в нашем случае является транзакция). Вторая часть - это алгоритм, который позволяет любому проверить подпись, используя только сообщение и открытый ключ.

[[digital_sign_create]]
===== Создание цифровой подписи

((("digital signatures","creating")))((("Elliptic Curve Digital Signature Algorithm (ECDSA)","signature creation")))В реализации ECDSA в Ethereum подписываемое "сообщение" - это транзакция, или, точнее, хэш Keccak-256 от закодированных в RLP данных из транзакции. Ключ подписи - это приватный ключ EOA (учётной записи). Результатом является подпись:

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <mrow>
      <mi>S</mi>
      <mi>i</mi>
      <mi>g</mi>
    </mrow>
    <mo>=</mo>
    <msub><mi>F</mi> <mrow><mi>s</mi><mi>i</mi><mi>g</mi></mrow> </msub>
    <mrow>
      <mo>(</mo>
      <msub><mi>F</mi> <mrow><mi>k</mi><mi>e</mi><mi>c</mi><mi>c</mi><mi>a</mi><mi>k</mi><mn>256</mn></mrow> </msub>
      <mrow>
        <mo>(</mo>
        <mi>m</mi>
        <mo>)</mo>
      </mrow>
      <mo>,</mo>
      <mi>k</mi>
      <mo>)</mo>
    </mrow>
  </mrow>
</math>
</div>
++++

где:

* _k_ - это приватный ключ подписи.
* _m_ - это RLP-закодированная транзакция.
* _F_~_keccak256_~ - это Keccak-256 хэш-функция.
* _F_~_sig_~ - это алгоритм подписи.
* _Sig_ - это полученная подпись.

[[sign_function]]
Функция _F_~_sig_~ создает сигнатуру __Sig__, состоящую из двух значений, обычно называемых _r_ и _s_:

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <mrow>
      <mi>S</mi>
      <mi>i</mi>
      <mi>g</mi>
    </mrow>
    <mo>=</mo>
    <mo>(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>)</mo>
  </mrow>
</math>
</div>
++++

[[verify_sign]]
==== Проверка подписи

((("digital signatures","verifying")))Для проверки подписи необходимо иметь саму подпись (_r_ и _s_), сериализованную транзакцию и открытый ключ, соответствующий закрытому ключу, использованному для создания подписи. По сути, проверка подписи означает, что "только владелец закрытого ключа, который сгенерировал этот открытый ключ, мог создать эту подпись для этой транзакции".

Алгоритм проверки подписи принимает сообщение (т.е. хэш транзакции для нашего использования), открытый ключ подписывающего лица и подпись (значения _r_ и _s_) и возвращает +true+, если подпись действительна для этого сообщения и открытого ключа.

[[ecdsa_math]]
==== ECDSA математика

((("digital signatures","ECDSA math", id="ix_06transactions-asciidoc16", range="startofrange")))((("Elliptic Curve Digital Signature Algorithm (ECDSA)","mathematics of", id="ix_06transactions-asciidoc17", range="startofrange")))Как упоминалось ранее, подписи создаются с помощью математической функции _F_~_sig_~, которая создает подпись, состоящую из двух значений, _r_ и _s_. В этом разделе мы рассмотрим функцию _F_~_sig_~ более подробно.

((("ephemeral private key")))Алгоритм подписи сначала генерирует _ephemeral_ (временный) закрытый ключ криптографически безопасным способом. Этот временный ключ используется при вычислении значений _r_ и _s_, чтобы гарантировать, что фактический закрытый ключ отправителя не может быть вычислен злоумышленниками, наблюдающими за подписанными транзакциями в сети Ethereum.

Как мы знаем из <<pubkey>>, эфемерный закрытый ключ используется для получения соответствующего (эфемерного) открытого ключа, поэтому у нас есть:

* Криптографически защищенное случайное число _q_, которое используется в качестве эфемерного закрытого ключа
* Соответствующий эфемерный открытый ключ _Q_, сгенерированный из _q_ и точки генератора эллиптической кривой _G_

Значение _r_ цифровой подписи в этом случае является _x_ координатой эфемерного открытого ключа _Q_.

Оттуда алгоритм вычисляет значение _s_ подписи, такое, что:

++++
<ul class="simplelist">
<li><em>s</em> &#8801; <em>q</em><sup>-1</sup> (<em>Keccak256</em>(<em>m</em>) + <em>r</em> * <em>k</em>)  &nbsp;  &nbsp; (<em>mod p</em>)</li>
</ul>
++++

где:

* _q_ - это эфемерный закрытый ключ.
* _r_ - это координата _x_ эфемерного открытого ключа.
* _k_ - это закрытый ключ подписи (владельца EOA).
* _m_ - это данные транзакции.
* _p_ - это простой порядок эллиптической кривой.

Проверка является обратной функцией генерации подписи, используя значения _r_ и _s_ и открытый ключ отправителя для вычисления значения _Q_, которое представляет собой точку на эллиптической кривой (эфемерный открытый ключ, используемый при создании подписи). Эти шаги заключаются в следующем:

1. Проверьте правильность формирования всех входных данных
2. Вычислите _w_ = __s__^-1^ _mod p_
3. Вычислите _u~1~_ = __Keccak256__(__m__) * _w_ _mod p_
4. Вычислите _u~2~_ = _r_ * _w_ _mod p_
5. Наконец, вычислите точку на эллиптической кривой _Q_ &#8801; _u~1~_ * _G_ + _u~2~_ * _K_ {nbsp} {nbsp} (_mod p_)

где:

* _r_ и _s_ - это значения подписи.
* _K_ - открытый ключ подписывающего лица (владельца EOA).
* _m_ - это данные транзакции, которые были подписаны.
* _G_ - точка генератора эллиптической кривой.
* _p_ - это простой порядок эллиптической кривой.

Если координата _x_ вычисленной точки _Q_ равна _r_, то верификатор может заключить, что подпись действительна.

Обратите внимание, что при проверке подписи закрытый ключ не известен и не раскрывается.

[TIP]
====
ECDSA - это, безусловно, довольно сложная математическая часть; полное объяснение выходит за рамки этой книги. Несколько отличных онлайн-руководств помогут вам пройти через это шаг за шагом: поищите "Объяснение ECDSA" или попробуйте это: http://bit.ly/2r0HhGB[].(((range="endofrange", startref="ix_06transactions-asciidoc17")))(((range="endofrange", startref="ix_06transactions-asciidoc16")))
====

[[tx_sign]]
==== Подписание транзакции на практике

((("digital signatures","signing in practice")))((("Elliptic Curve Digital Signature Algorithm (ECDSA)","transaction signing in practice")))((("transactions","signing in practice")))Чтобы произвести валидную транзакцию, отправитель должен подписать сообщение цифровой подписью, используя алгоритм цифровой подписи на эллиптической кривой. Когда мы говорим "подписать транзакцию", мы на самом деле имеем в виду "подписать хэш Keccak-256 данных транзакции, сериализованных RLP". Подпись применяется к хэшу данных транзакции, а не к самой транзакции.

Чтобы подписать транзакцию в Ethereum, отправитель должен:

1. Создайте структуру данных транзакции, содержащую девять полей: +nonce+, +gasPrice+, +gasLimit+, +to+, +value+, +data+, +chainId+, +0+, +0+.
2. Создайте закодированное в RLP сериализованное сообщение структуры данных транзакции.
3. Вычислите хэш Keccak-256 этого сериализованного сообщения.
4. Вычислите подпись ECDSA, подписав хэш закрытым ключом исходного EOA.
5. Добавьте к транзакции вычисленные значения подписи ECDSA: +v+, +r+ и +s+.

Специальная переменная подписи +v+ указывает две вещи: идентификатор цепочки и идентификатор восстановления, чтобы помочь функции +ECDSArecover+ проверить подпись. Он рассчитывается либо как одно из 27, либо как 28, либо как удвоенный идентификатор цепочки плюс 35 или 36. Для получения дополнительной информации об идентификаторе цепочки см. <<raw_tx_eip155>>. Идентификатор восстановления (27 или 28 в подписях "старого стиля" или 35 или 36 в транзакциях в стиле Spurious Dragon) используется для указания четности компонента +y+ открытого ключа (см. <<sign_prefix>> для получения более подробной информации).


[NOTE]
====
((("Spurious Dragon")))В блоке #2,675,000 Ethereum реализовал хард-форк "Spurious Dragon", который, среди прочих изменений, ввел новую схему подписи, включающую защиту от повторного воспроизведения транзакций (предотвращение воспроизведения транзакций, предназначенных для одной сети, в других). Эта новая схема подписания указана в EIP-155. Это изменение влияет на форму транзакции и ее подпись, поэтому необходимо обратить внимание на первую из трех переменных подписи (т.е. +v+), которая принимает одну из двух форм и указывает поля данных, включенные в хэшируемое сообщение транзакции.
====


[[raw_tx]]
==== Создание и подписание необработанной (raw) транзакции

((("EthereumJS")))((("transactions","raw transaction creation/signing")))В этом разделе мы создадим необработанную транзакцию и подпишем ее, используя библиотеку +ethereumjs-tx+, которую можно установить вместе с npm. Это демонстрирует функции, которые обычно используются внутри кошелька или приложения, подписывающего транзакции от имени пользователя. Исходный код для этого примера находится в файле __raw_tx_demo.js__ в репозитории книги на http://bit.ly/2yI2GL3[Github]:

[[raw_tx_demo_source]]
[source,javascript]
----
include::code/web3js/raw_tx/raw_tx_demo.js[]
----

[[raw_tx_demo_run]]
Выполнение примера кода приводит к следующим результатам:

++++
<pre data-type="programlisting">
$ <strong>node raw_tx_demo.js</strong>
RLP-Encoded Tx: 0xe6808609184e72a0008303000094b0920c523d582040f2bcb1bd7fb1c7c1...
Tx Hash: 0xaa7f03f9f4e52fcf69f836a6d2bbc7706580adce0a068ff6525ba337218e6992
Signed Raw Transaction: 0xf866808609184e72a0008303000094b0920c523d582040f2bcb1...
</pre>
++++

[[raw_tx_eip155]]
==== Создание необработанной транзакции с помощью EIP-155

((("chain identifier")))((("EIP-155 Simple Replay Attack Protection standard")))((("transactions","raw transaction creation with EIP-155")))Стандарт EIP-155 "Простая защита от повторных атак" определяет кодировку транзакции, защищенную от повторных атак, которая включает в себя _идентификатор цепочки_ (_chain identifier_) внутри данных транзакции перед подписанием. Это гарантирует, что транзакции, созданные для одного блокчейна (например, основной сети Ethereum), будут недействительными в другом блокчейне (например, Ethereum Classic или тестовой сети Ropsten). Следовательно, транзакции, транслируемые в одной сети, не могут быть воспроизведены в другой, отсюда и название стандарта.

EIP-155 добавляет три поля к основным шести полям структуры данных транзакции, а именно идентификатор цепочки, +0+ и +0+. Эти три поля добавляются к данным транзакции _перед тем, как они будут закодированы и хэшированы_. Поэтому они изменяют хэш транзакции, к которому позже применяется подпись. Включив идентификатор цепочки в подписываемые данные, подпись транзакции предотвращает любые изменения, поскольку подпись становится недействительной при изменении идентификатора цепочки. Таким образом, EIP-155 делает невозможным воспроизведение транзакции в другой цепочке, поскольку действительность подписи зависит от идентификатора цепочки.


Поле идентификатора цепочки принимает значение в соответствии с сетью, для которой предназначена транзакция, как описано в <<chain_id_table>>.

[[chain_id_table]]
.Идентификаторы цепочки
[options="header"]
|======
| Chain | Chain ID
| Ethereum mainnet | 1
| Morden (obsolete), Expanse | 2
| Ropsten | 3
| Rinkeby | 4
| Rootstock mainnet | 30
| Rootstock testnet | 31
| Kovan | 42
| Ethereum Classic mainnet | 61
| Ethereum Classic testnet | 62
| Geth private testnets | 1337
|======

Результирующая структура транзакции кодируется в RLP, хэшируется и подписывается. Алгоритм подписи немного изменен, чтобы кодировать идентификатор цепочки также в префиксе +v+.

Для получения более подробной информации см. http://bit.ly/2CQUgne[the EIP-155 specification].(((range="endofrange", startref="ix_06transactions-asciidoc15")))(((range="endofrange", startref="ix_06transactions-asciidoc14")))

[[sign_prefix]]
=== Значение префикса подписи (v) и восстановление открытого ключа

((("digital signatures","signature prefix value (v) and public key recovery")))((("public key recovery")))((("transactions","signature prefix value (v) and public key recovery")))Как упоминалось в <<tx_struct>>, сообщение о транзакции не содержит поля "от". Это связано с тем, что открытый ключ отправителя может быть вычислен непосредственно из подписи ECDSA. Как только у вас будет открытый ключ, вы сможете легко вычислить адрес. Процесс восстановления открытого ключа подписавшего называется _public key recovery_.

Учитывая значения +r+ и +s+, которые были вычислены в <<ecdsa_math>>, мы можем вычислить два возможных открытых ключа.

Сначала мы вычисляем две точки эллиптической кривой, _R_ и __R__^__'__^, из координаты _x_ значения +r+, которое находится в подписи. Есть две точки, потому что эллиптическая кривая симметрична поперек оси x, так что для любого значения +x+ есть два возможных значения, которые соответствуют кривой, по одному с каждой стороны оси x.

Из +r+ мы также вычисляем __r__^-1^, который является мультипликативной обратной величиной +r+.

Наконец, мы вычисляем _z_, который является _n_ младшими битами хэша сообщения, где _n_ - порядок эллиптической кривой.

Затем два возможных открытых ключа являются:

++++
<ul class="simplelist">
<li><em>K</em><sub>1</sub> = <em>r</em><sup>&#x2013;1</sup> (<em>sR</em> &#x2013; <em>zG</em>)</li>
</ul>
++++

и:

++++
<ul class="simplelist">
<li><em>K</em><sub>2</sub> = <em>r</em><sup>&#x2013;1</sup> (<em>sR</em><sup>'</sup> &#x2013; <em>zG</em>)</li>
</ul>
++++

где:

* __K__~1~ и __K__~2~ - это два варианта открытого ключа, принадлежащего подписывающему лицу.
* __r__^-1^ является мультипликативным обратным значением сигнатуры +r+.
* _s_ - это значение подписи +s+.
* __R__ и __R__^'^ - это две возможности для эфемерного открытого ключа _Q_.
* _z_ - это __n__-младших бит хэша сообщения.
* _G_ - точка генератора эллиптической кривой.

Чтобы сделать работу более эффективной, подпись транзакции включает значение префикса +v+, которое сообщает нам, какое из двух возможных значений _R_ является эфемерным открытым ключом. Если +v+ четное, то _R_ - правильное значение. Если +v+ нечетно, то это __R__^'^. Таким образом, нам нужно вычислить только одно значение для _R_ и только одно значение для _K_.

[[offline_sign]]
=== Разделение подписи и передачи (офлайн-подпись)

((("digital signatures","separating signing and transmission", id="ix_06transactions-asciidoc18", range="startofrange")))((("offline signing", id="ix_06transactions-asciidoc19", range="startofrange")))((("transactions","separating signing and transmission", id="ix_06transactions-asciidoc20", range="startofrange")))Как только транзакция подписана, она готова к передаче в сеть Ethereum. Три этапа создания, подписания и трансляции транзакции обычно выполняются как одна операция, например, с использованием +web3.eth.sendTransaction+. Однако, как вы видели в <<raw_tx>>, вы можете создать и подписать транзакцию в два отдельных шага. Как только у вас есть подписанная транзакция, вы можете затем передать ее с помощью +web3.eth.sendSignedTransaction+, который принимает транзакцию в шестнадцатеричной кодировке, подписывает ее и передает по сети Ethereum.

Почему вы хотите разделить подписание и передачу транзакций? Самая распространенная причина - это безопасность. Компьютер, который подписывает транзакцию, должен иметь незащищённые приватные ключи, загруженные в память. Компьютер, который выполняет передачу, должен быть подключен к Интернету (и работать под управлением клиента Ethereum). Если эти две функции находятся на одном компьютере, то у вас есть приватные ключи в онлайн-системе, что довольно опасно. Разделение функций подписи и передачи и выполнение их на разных машинах (на автономном и онлайн-устройстве соответственно) называется _offline signing_ и является обычной практикой обеспечения безопасности.

<<offline_signing>> показывает процесс:

1. Создайте неподписанную транзакцию на онлайн-компьютере, где можно получить информацию о текущем состоянии счета, в частности о текущем одноразовом номере и доступных средствах.
2. Перенесите неподписанную транзакцию на автономное устройство с "воздушным зазором" для подписания транзакции, например, с помощью QR-кода или флэш-накопителя USB.
3. Передайте подписанную транзакцию (обратно) на онлайн-устройство для трансляции в блокчейн Ethereum, например, с помощью QR-кода или флэш-накопителя USB.

[[offline_signing]]
.Автономное подписание транзакций Ethereum
image::images/offline_signing.png["Offline signing of Ethereum transactions"]

В зависимости от необходимого вам уровня безопасности ваш компьютер с "оффлайн-подписью" может иметь различную степень отделения от сетевого компьютера, начиная от изолированной и защищенной брандмауэром подсети (онлайн, но разделенной) до полностью автономной системы, известной как система с воздушным зазором. ((("air-gapped system"))) В системе с воздушным зазором вообще отсутствует сетевое подключение &#x2014; компьютер отделен от онлайн-среды "воздушным зазором". Чтобы подписывать транзакции, вы переносите их на компьютер с воздушным зазором и обратно с помощью носителя данных или (что еще лучше) веб-камеры и QR-кода. Конечно, это означает, что вы должны вручную переносить каждую транзакцию, которую хотите подписать, и это не масштабируется.

Хотя не во многих средах можно использовать полностью герметичную систему, даже небольшая степень изоляции дает значительные преимущества в плане безопасности. Например, изолированная подсеть с брандмауэром, который пропускает только протокол очереди сообщений, может обеспечить значительно меньше возможностей для атаки и гораздо более высокую безопасность, чем вход в онлайн-систему. ((("ZeroMQ (0MQ)")))Многие компании используют для этой цели такой протокол, как ZeroMQ (0MQ). При такой настройке транзакции сериализуются и ставятся в очередь для подписания. Протокол очередей передает сериализованное сообщение способом, аналогичным TCP-сокету, на подписывающий компьютер. Подписывающий компьютер считывает сериализованные транзакции из очереди (осторожно), применяет подпись с соответствующим ключом и помещает их в исходящую очередь. Исходящая очередь передает подписанные транзакции на компьютер с клиентом Ethereum, который снимает их с очереди и передает.(((range="endofrange", startref="ix_06transactions-asciidoc20")))(((range="endofrange", startref="ix_06transactions-asciidoc19")))(((range="endofrange", startref="ix_06transactions-asciidoc18")))

[[tx_propagation]]
=== Распространение транзакций

((("flood routing")))((("node","transaction propagation")))((("propagation of transactions")))((("transactions","propagation of")))Сеть Ethereum использует протокол "маршрутизации потока". Каждый клиент Ethereum действует как _node_ в _peer-to-peer (P2P)_ сети, которая (в идеале) образует _mesh_ сеть. Ни один сетевой узел не является особенным: все они действуют как равные одноранговые узлы. Мы будем использовать термин "узел" для обозначения клиента Ethereum, который подключен к сети P2P и участвует в ней.

Распространение транзакций начинается с того, что исходный узел Ethereum создает (или получает из офлайна) подписанную транзакцию. Транзакция проверяется, а затем передается всем другим узлам Ethereum, которые напрямую подключены к исходному узлу. ((("соседние узлы"))) В среднем каждый узел Ethereum поддерживает соединения по меньшей мере с 13 другими узлами, называемыми его соседями. Каждый соседний узел проверяет транзакцию, как только он ее получает. Если они согласны с тем, что она действительна, они сохраняют копию и распространяют ее среди всех своих соседей (кроме того, от которого она поступила). В результате транзакция распространяется от исходного узла наружу, _растекаясь_ по сети, пока все узлы в сети не получат копию транзакции. Узлы могут фильтровать сообщения, которые они распространяют, но по умолчанию распространяются все действительные сообщения транзакций, которые они получают.

Всего за несколько секунд транзакция Ethereum распространяется на все узлы Ethereum по всему миру. С точки зрения каждого узла невозможно определить источник транзакции. Сосед, отправивший его на узел, может быть инициатором транзакции или, возможно, получил его от одного из своих соседей. Чтобы иметь возможность отслеживать происхождение транзакций или вмешиваться в распространение, злоумышленнику пришлось бы контролировать значительный процент всех узлов. Это часть дизайна безопасности и конфиденциальности P2P-сетей, особенно применительно к сетям блокчейна.

[[chain_record]]
=== Запись в блокчейн

((("blockchain","recording transactions on")))((("miners")))((("mining farms")))((("transactions","recording on the blockchain")))В то время как все узлы в Ethereum являются равноправными узлами, некоторые из них управляются майнерами и передают транзакции и блоки на майнинговые фермы, которые представляют собой компьютеры с высокопроизводительными графическими процессорами (GPU). Компьютеры майнинга добавляют транзакции в блок-кандидат и пытаются найти _proof of work_, который делает блок-кандидат действительным. Мы обсудим это более подробно в разделе <<консенсус>>.

Не вдаваясь в подробности, допустимые транзакции в конечном итоге будут включены в блок транзакций и, таким образом, записаны в блокчейне Ethereum. После майнинга в блок, транзакции также изменяют состояние синглтона Ethereum, либо изменяя баланс учетной записи (в случае простого платежа), либо вызывая контракты, которые изменяют их внутреннее состояние. Эти изменения записываются вместе с транзакцией в форме _квитанции_ (_receipt_) транзакции, которая также может включать с_события_ (_events_). Мы рассмотрим все это гораздо более подробно в <<evm_chapter>>.

Транзакция, которая завершила свой путь от создания до подписания EOA, распространения и, наконец, майнинга, изменила состояние синглтона и оставила неизгладимый след в блокчейне.

=== Множественная подпись (Multisig) транзакций

((("multiple-signature (multisig) transactions")))((("transactions","multiple-signature")))Если вы знакомы со скриптовыми возможностями Биткойна, вы знаете, что можно создать учетную запись с несколькими подписями в биткойне, которая может тратить средства только тогда, когда транзакцию подписывают несколько сторон (например, 2 из 2 или 3 из 4 подписей). Базовые транзакции от EOA в Ethereum не предусматривают множественных подписей; однако произвольные ограничения на подписание могут быть применены с помощью смарт-контрактов с любыми условиями, которые вы можете придумать, чтобы обрабатывать передачу эфира и токенов одинаково.

Чтобы воспользоваться этой возможностью, эфир должен быть переведен на "контракт кошелька", который запрограммирован с желаемыми правилами расходования, такими как требования о мультиподписи или лимиты расходов (или их комбинации). Затем контракт кошелька отправляет средства по запросу авторизованного EOA, как только условия расходования будут выполнены. Например, чтобы защитить свой эфир в условиях мультиподписи, переведите эфир в контракт с несколькими подписями. Всякий раз, когда вы захотите отправить средства на другой счет, все необходимые пользователи должны будут отправлять транзакции в контракт с помощью обычного приложения кошелька, фактически разрешая контракту выполнить последнюю pass: [<span class="keep-together">транзакцию</span>].

Эти контракты также могут быть сконструированы так, чтобы требовать нескольких подписей перед выполнением локального кода или для запуска других контрактов. Безопасность схемы в конечном счете определяется кодом контракта с несколькими подписями.

Возможность реализации транзакций с несколькими подписями в виде смарт-контракта демонстрирует гибкость Ethereum. Однако это палка о двух концах, поскольку дополнительная гибкость может привести к ошибкам, которые подрывают безопасность схем с несколькими подписями. На самом деле существует ряд предложений (proposals) по созданию команды для мультиподписи в EVM, которая устраняет необходимость в смарт-контрактах, по крайней мере, для простых схем мультиподписи вида M-of-N. Это было бы эквивалентно системе мультиподписи Биткойна, которая является частью основных правил консенсуса и доказала свою надежность и безопасность.

=== Заключение

Транзакции являются отправной точкой любой деятельности в системе Ethereum. Транзакции - это "входные данные", которые заставляют виртуальную машину Ethereum выполнять контракты, обновлять балансы и, в более общем плане, изменять состояние блокчейна Ethereum. Далее мы будем работать со смарт-контрактами гораздо более подробно и узнаем, как программировать на контрактно-ориентированном языке Solidity.(((range="endofrange", startref="ix_06transactions-asciidoc0")))

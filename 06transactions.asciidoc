[[tx_chapter]]
== Транзакции

((("transactions", id="ix_06transactions-asciidoc0", range="startofrange")))Транзакции - это подписанные сообщения, исходящие от внешней учетной записи (externally owned account) (EOA), передаваемые сетью Ethereum и записываемые в блокчейне Ethereum. Это базовое определение скрывает множество удивительных и увлекательных деталей. Другой способ взглянуть на транзакции заключается в том, что они являются единственными вещами, которые могут вызвать изменение состояния или вызвать выполнение контракта в EVM. Ethereum - это глобальный конечный автомат (единственный – singleton), и транзакции - это то, что заставляет этот конечный автомат "тикать", изменяя его состояние. Контракты не выполняются сами по себе. Ethereum не работает автономно. Все начинается с транзакции.

В этой главе мы проанализируем транзакции, покажем, как они работают, и рассмотрим детали. Обратите внимание, что большая часть этой главы адресована тем, кто заинтересован в управлении своими собственными транзакциями на низком уровне, возможно, потому, что они пишут приложение для кошелька; вам не нужно беспокоиться об этом, если вы довольны использованием существующих приложений для кошельков, хотя детали могут показаться вам интересными!

[[tx_struct]]
=== Структура транзакции

((("transactions","basic structure")))Сначала давайте взглянем на базовую структуру транзакции, поскольку она сериализуется и передается в сети Ethereum. Каждый клиент и приложение, получающие сериализованную транзакцию, будут хранить ее в памяти, используя свою собственную внутреннюю структуру данных, возможно, украшенную метаданными, которых нет в самой сетевой сериализованной транзакции. Сетевая сериализация - это единственная стандартная форма транзакции.

Транзакция - это сериализованное двоичное сообщение, содержащее следующие данные:

Одноразовый номер:: Порядковый номер, выданный отправителем EOA, используемый для предотвращения воспроизведения сообщения

Цена на газ:: Количество эфира (в wei), которое отправитель готов заплатить за каждую единицу газа

Лимит газа:: Максимальное количество газа, которое отправитель готов купить для данной транзакции

Получатель:: Адрес назначения Ethereum

Значение:: Количество эфира (в wei) для отправки в пункт назначения

Данные:: Полезная нагрузка двоичных данных переменной длины

v,r,s:: Три компонента цифровой подписи ECDSA исходного EOA

((("Recursive Length Prefix (RLP)")))((("RLP (Recursive Length Prefix)")))Структура сообщения транзакции сериализуется с использованием схемы кодирования рекурсивного префикса длины (RLP), которая была создана специально для простой, идеальной по байтам сериализации данных в Ethereum. Все числа в Ethereum кодируются как целые числа в порядке от старшего к младшему (big-endian), длина которых кратна 8 битам.

Обратите внимание, что метки полей (+to+, +gas limit+ и т.д.) показаны здесь для наглядности, но не являются частью сериализованных данных транзакции, которые содержат значения полей в RLP-кодировке. Как правило, RLP не содержит никаких разделителей полей или меток. Префикс длины RLP используется для определения длины каждого поля. Все, что выходит за пределы заданной длины, относится к следующему полю в структуре.

Хотя это фактическая передаваемая структура транзакции, большинство внутренних представлений и визуализаций пользовательского интерфейса приукрашивают это дополнительной информацией, полученной из транзакции или из блокчейна.

Например, вы можете заметить, что в адресе, идентифицирующем отправителя EOA, отсутствуют данные &#x201c;from&#x201d;. Это связано с тем, что открытый ключ EOA может быть получен из компонентов +v,r,s+ подписи ECDSA. Адрес, в свою очередь, может быть получен из открытого ключа. Когда вы видите транзакцию с полем "от", это значит, что поле было добавлено программным обеспечением, используемым для визуализации транзакции. Другие метаданные, часто добавляемые к транзакции клиентским программным обеспечением, включают номер блока (после его майнинга и включения в блокчейн) и идентификатор транзакции (вычисляемый хэш). Опять же, эти данные получены из транзакции и не являются частью самого сообщения транзакции.

[[tx_nonce]]
=== Одноразовый номер (nonce – number once) транзакции

((("nonces", id="ix_06transactions-asciidoc1", range="startofrange")))((("transactions","nonces", id="ix_06transactions-asciidoc2", range="startofrange")))Одноразовый номер (nonce – number that can only be used once) является одним из наиболее важных и наименее понятных компонентов транзакции. Определение в Yellow Paper (см. <<references>>):

____
+nonce+: Скалярное значение, равное количеству транзакций, отправленных с этого адреса, или, в случае учетных записей с соответствующим кодом, количеству контрактов, созданных этой учетной записью.
____

Строго говоря, одноразовый номер является атрибутом исходного адреса; то есть он имеет значение только в контексте отправляющего адреса. Однако одноразовый номер явно не сохраняется как часть состояния учетной записи в блокчейне. Вместо этого он рассчитывается динамически, путем подсчета количества подтвержденных транзакций, которые были отправлены с адреса.

Существует два сценария, в которых важно наличие одноразового номера для подсчета транзакций: функция удобства использования транзакций, включаемых в порядок создания, и жизненно важная функция защиты от дублирования транзакций. Давайте рассмотрим пример сценария для каждого из этих:

1. Представьте, что вы хотите совершить две транзакции. Вам нужно произвести важный платеж в размере 6 эфиров, а также еще один платеж в размере 8 эфиров. Сначала вы подписываете и отправляете транзакцию в 6 эфиров, потому что она более важная, а затем вы подписываете и отправляете вторую транзакцию в 8 эфиров. К сожалению, вы упустили из виду тот факт, что на вашем аккаунте всего 10 эфиров, поэтому сеть не может принять обе транзакции: одна из них завершится неудачей. Поскольку вы сначала отправили более важное сообщение с 6 эфирами, вы, по понятным причинам, ожидаете, что оно пройдет, а сообщение с 8 эфирами будет отклонено. Однако в децентрализованной системе, такой как Ethereum, узлы могут получать транзакции в любом порядке; нет никакой гарантии, что конкретному узлу будет передана одна транзакция перед другой. Таким образом, почти наверняка произойдет так, что некоторые узлы сначала получат транзакцию с 6 эфирами, а другие сначала получат транзакцию с 8 эфирами. Без одноразового номера было бы определено случайным образом какая из них будет принята, а какая отклонена. Однако, если включить одноразовый номер, первая отправленная вами транзакция будет иметь одноразовый номер, скажем, 3, в то время как транзакция с 8 эфирами будет иметь следующее одноразовое значение (т.е. 4). Таким образом, эта транзакция будет игнорироваться до тех пор, пока не будут обработаны транзакции с одноразовыми номерами от 0 до 3, даже если она будет получена первой. Уф!


2. Теперь представьте, что у вас есть аккаунт со 100 эфирами. Фантастика! Вы находите кого-то в Интернете, кто примет оплату в эфире за виджет Макгаффина (mcguffin), который вы действительно хотите купить. Вы отправляете им 2 эфира, и они отправляют вам виджет Макгаффина. Прекрасно. Чтобы произвести этот платеж в 2 эфира, вы подписали транзакцию, отправив 2 эфира со своей учетной записи на их учетную запись, а затем передали ее в сеть Ethereum для проверки и включения в блокчейн. Теперь, без одноразового значения в транзакции, вторая транзакция, отправляющая 2 эфира на тот же адрес во второй раз, будет выглядеть точно так же, как и первая транзакция. Это означает, что любой, кто видит вашу транзакцию в сети Ethereum (что означает, что все, включая получателя или ваших врагов), могут "воспроизводить" транзакцию снова, снова и снова, пока весь ваш эфир не исчезнет, просто скопировав и вставив вашу исходную транзакцию и повторно отправив ее в сеть. Однако, поскольку значение nonce включено в данные транзакции, каждая отдельная транзакция уникальна, даже при многократной отправке одного и того же количества эфира на один и тот же адрес получателя. Таким образом, имея увеличивающийся одноразовый номер как часть транзакции, никто просто не сможет "дублировать" произведенный вами платеж.

Подводя итог, важно отметить, что использование одноразового номера на самом деле жизненно важно для протокола, основанного на _account-based_, в отличие от механизма вывода неизрасходованных транзакций (UTXO) протокола Биткойн.

[[tracking_nonce]]
==== Отслеживание одноразовых номеров (nonces)

((("nonces","keeping track of")))С практической точки зрения одноразовый номер - это актуальный подсчет количества _подтвержденных _ (т.е. внутри цепочки) транзакций, которые были произведены со счета. Чтобы узнать, что такое одноразовый номер, вы можете запросить блокчейн, например, через интерфейс web3. Откройте консоль JavaScript в Geth (или предпочитаемый вами интерфейс web3) в Ropsten testnet, затем введите:

++++
<pre data-type="programlisting">
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")</strong>
40
</pre>
++++

[TIP]
====
Одноразовый номер - это счетчик, основанный на нуле, что означает, что первая транзакция имеет одноразовый номер 0. В этом примере у нас есть количество транзакций 40, что означает, что были замечены одноразовые номера от 0 до 39. Одноразовый номер следующей транзакции должен быть равен 40.
====

Ваш кошелек будет отслеживать одноразовые номера для каждого адреса, которым он управляет. Это довольно просто сделать, если вы отправляете транзакции только из одной точки. Допустим, вы пишете свое собственное программное обеспечение для кошелька или какое-то другое приложение, которое инициирует транзакции. Как вы отслеживаете одноразовые номера?

Когда вы создаете новую транзакцию, вы назначаете следующий одноразовый номер в последовательности. Но до тех пор, пока он не будет подтвержден, он не будет учитываться в pass:[<span class="keep-together"><code>getTransactionCount</code></span>].

[[get_tx_count_bug]]
[WARNING]
====
Будьте осторожны при использовании функции pass:[<span class="keep-together"><code>getTransactionCount</code></span>] для подсчета ожидающих транзакций, потому что вы можете столкнуться с некоторыми проблемами, если отправите несколько транзакций подряд.
====

Let's look at an example:

++++
<pre data-type="programlisting">
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
40
&gt; <strong>web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});</strong>
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
41
&gt; <strong>web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});</strong>
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
41
&gt; <strong>web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});</strong>
&gt; <strong>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")</strong>
41
</pre>
++++
[TIP]
====
Если вы пытаетесь воссоздать эти примеры кода самостоятельно в консоли javascript Geth, вам следует использовать web3.toWei() вместо web3.utils.toWei(). Это связано с тем, что Geth использует более старую версию библиотеки web3.
====

Как вы можете видеть, первая отправленная нами транзакция увеличила количество транзакций до 41, показав ожидающую транзакцию. Но когда мы отправили еще три транзакции в быстрой последовательности, вызов pass:[<span class="keep-together"><code>getTransactionCount</code></span>] не подсчитал их. Он насчитал только одну, хотя вы могли бы ожидать, что в mempool будет три ожидающих рассмотрения. Если мы подождем несколько секунд, чтобы сетевое взаимодействие закончилось, вызов pass:[<span class="keep-together"><code>getTransactionCount</code></span>] вернет ожидаемое число. Но в промежуточный период, пока на рассмотрении находится более одной транзакции, это может нам не помочь.

Когда вы создаете приложение, которое создает транзакции, оно не может полагаться на pass:[<span class="keep-together"><code>getTransactionCount</code></span>] для ожидающих транзакций. Только когда ожидающие и подтвержденные подсчеты равны (все незавершенные транзакции подтверждены), вы можете доверять выводам pass:[<span class="keep-together"><code>getTransactionCount</code></span>] для запуска вашего счетчика одноразовых номеров. После этого следите за одноразовым номером в вашем приложении до подтверждения каждой транзакции.

((("Четность","подсчет одноразовых номеров")))Интерфейс JSON RPC Parity предлагает функцию pass:[<span class="keep-together"><code>parity_nextNonce</code></span>], которая возвращает следующий одноразовый номер, который следует использовать в транзакция. Функция pass:[<span class="keep-together"><code>parity_nextNonce</code></span>] правильно подсчитывает одноразовые номера, даже если вы быстро создаете несколько транзакций подряд, не подтверждая их:

++++
<pre data-type="programlisting">
$ <strong>curl --data '{"method":"parity_nextNonce", \
  "params":["0x9e713963a92c02317a681b9bb3065a8249de124f"],\
  "id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST \
  localhost:8545</strong>

{"jsonrpc":"2.0","result":"0x32","id":1}
</pre>
++++

[[parity_curl]]
[TIP]
====
У Parity есть веб-консоль для доступа к интерфейсу JSON RPC, но здесь мы используем HTTP-клиент командной строки для доступа к нему.
====

[[gaps_nonce]]
==== Пробелы в одноразовых номерах, Повторяющиеся одноразовые номера и Подтверждение

((("nonces","gaps in sequence of")))Важно отслеживать одноразовые номера, если вы создаете транзакции программно, особенно если вы делаете это из нескольких независимых процессов pass:[<span class="keep-together">одновременно</span>].

Сеть Ethereum обрабатывает транзакции последовательно, на основе одноразового номера. Это означает, что если вы передадите транзакцию с одноразовым номером 0, а затем передадите транзакцию с одноразовым номером 2, вторая транзакция не будет включена ни в какие блоки. Она будет сохранена в mempool, в то время как сеть Ethereum ожидает появления отсутствующего одноразового номера. Все узлы будут предполагать, что отсутствующий одноразовый номер просто был отложен и что транзакция с одноразовым номером 2 была получена не по порядку.

Если затем вы передадите транзакцию с отсутствующим одноразовым номером 1, обе транзакции (одноразовые номера 1 и 2) будут обработаны и включены (если, конечно, они действительны). Как только вы восполните этот пробел, сеть сможет обработать транзакцию вне последовательности, которую она хранила в mempool.

Это означает, что если вы создадите несколько транзакций последовательно, и одна из них не будет официально включена ни в какие блоки, все последующие транзакции "застрянут", ожидая пропущенного одноразового номера. Транзакция может создать непреднамеренный "пробел" в последовательности одноразовых номеров, поскольку она недействительна или содержит недостаточно газа. Чтобы все снова сдвинулось с мертвой точки, вы должны передать действительную транзакцию с отсутствующим одноразовым номером. Вы также должны помнить, что как только транзакция с "отсутствующим" одноразовым номером будет подтверждена сетью, все широковещательные транзакции с последующими одноразовыми номерами постепенно станут действительными; "отозвать" транзакцию невозможно!

((("nonces","confirmation")))((("nonces","duplicated")))Если, с другой стороны, вы случайно продублируете одноразовый номер, например, передавая две транзакции с одним и тем же одноразовым номером, но с разными получателями или значениями, то одна из них будет подтверждена, и одна будет отклонена. Какая из них будет подтверждена, будет определяться последовательностью, в которой они поступают для проверки на первый узел, который их получает &#x2014; т.е. это будет довольно случайным образом.

Как вы можете видеть, отслеживание одноразовых номеров необходимо, и если ваше приложение неправильно управляет этим процессом, вы столкнетесь с проблемами. К сожалению, все становится еще сложнее, если вы пытаетесь делать это одновременно, как мы увидим в следующем разделе.

[[concurrency]]
==== Параллелизм, Инициирование транзакций и Одноразовые номера

((("concurrency, nonces and")))((("nonces","concurrency")))((("nonces","transaction origination")))Параллелизм - это сложный аспект информатики, и иногда он возникает неожиданно, особенно в децентрализованных и распределенных системах реального времени, таких как pass:[<span class="keep-together">Ethereum</span>].

Проще говоря, параллелизм - это когда у вас есть одновременные вычисления несколькими независимыми системами. Они могут быть в одной и той же программе (например, многопоточность), на одном и том же процессоре (например, многопроцессорная обработка) или на разных компьютерах (например, распределенных pass:[<span class="keep-together">системах</span>]). Ethereum, по определению, - это система, которая допускает параллелизм операций (узлов, клиентов, dApps), но обеспечивает единое для всех состояние посредством консенсуса.

Теперь представьте, что у вас есть несколько независимых приложений кошелька, которые генерируют транзакции с одного и того же адреса или адресов. Одним из примеров такой ситуации может быть обмен, обрабатывающий снятие средств с горячего кошелька (hot wallet) биржи (кошелька, ключи которого хранятся онлайн, в отличие от холодного кошелька, где ключи никогда не находятся в сети). В идеале вы хотели бы иметь несколько компьютеров, обрабатывающих снятие средств, чтобы это не стало узким местом или единственной точкой отказа. Однако это быстро становится проблематичным, поскольку наличие более чем одного компьютера, производящего снятие средств, приведет к некоторым сложным проблемам параллелизма, не последней из которых является выбор одноразовых номеров. Как координируются несколько компьютеров, генерирующих, подписывающих и транслирующих транзакции с одной и той же учетной записи hot wallet?

Вы могли бы использовать один компьютер для назначения одноразовых номеров в порядке живой очереди компьютерам, подписывающим транзакции. Однако этот компьютер теперь является единственной точкой отказа. Хуже того, если назначено несколько одноразовых номеров, и один из них никогда не используется (из-за сбоя в компьютере, обрабатывающем транзакцию с этим одноразовым номером), все последующие транзакции застревают.

Другим подходом было бы генерировать транзакции, но не присваивать им одноразовый номер (и, следовательно, оставлять их неподписанными &#x2014; помните, что одноразовый номер является неотъемлемой частью данных транзакции и поэтому должен быть включен в цифровую подпись, которая аутентифицирует транзакцию). Затем вы можете поместить их в очередь на один узел, который их подписывает, а также отслеживает одноразовые номера. Опять же, однако, это было бы затруднительным моментом в процессе: подписание и отслеживание одноразовых номеров - это та часть вашей операции, которая, вероятно, будет перегружена под нагрузкой, в то время как генерация неподписанной транзакции - это та часть, которую вам действительно не нужно распараллеливать. У вас был бы некоторый параллелизм, но его не хватало бы в критической части процесса.

В конце концов, эти проблемы с параллелизмом, в дополнение к сложности отслеживания остатков на счетах и подтверждений транзакций в независимых процессах, вынуждают большинство реализаций избегать параллелизма и создавать узкие места, такие как единый процесс, обрабатывающий все транзакции вывода средств на бирже, или настройка нескольких горячих кошельков, которые могут работать полностью независимо для снятия средств и нужно только периодически восстанавливать баланс на них.(((range="endofrange", startref="ix_06transactions-asciidoc2")))(((range="endofrange", startref="ix_06transactions-asciidoc1")))

[[tx_gas]]
=== Транзакционный газ

((("gas","transactions and", id="ix_06transactions-asciidoc3", range="startofrange")))((("transactions","gas", id="ix_06transactions-asciidoc4", range="startofrange")))Мы немного говорили о газе в предыдущих главах, и мы обсуждаем его более подробно в <<gas>>. Однако давайте рассмотрим некоторые основы касаемо роли компонентов +gasPrice+ и +gasLimit+ в транзакции.

Газ - это топливо Эфириума. Газ - это не эфир &#x2014; это отдельная виртуальная валюта со своим собственным обменным курсом по отношению к эфиру. Ethereum использует gas для контроля количества ресурсов, которые может использовать транзакция, поскольку она будет обрабатываться на тысячах компьютеров по всему миру. Открытая (полная по Тьюрингу) вычислительная модель требует некоторой формы учета, чтобы избежать атак типа "отказ в обслуживании" или непреднамеренных транзакций, поглощающих ресурсы.

Gas отделен от эфира, чтобы защитить систему от нестабильности, которая может возникнуть вместе с быстрыми изменениями стоимости эфира, а также как способ управления важными и чувствительными соотношениями между затратами на различные ресурсы, за которые платит gas (а именно, вычисления, память и хранение).

((("gasPrice field")))Поле +gasPrice+ в транзакции позволяет инициатору транзакции установить цену, которую он готов заплатить в обмен на газ. Цена измеряется в вей за единицу газа. Например, в примере транзакции в <<intro_chapter>> ваш кошелек установил +gasPrice+ равным 3 гвеям (3 гигавея или 3 миллиарда вей).

[TIP]
====
Популярный сайт https://ethgasstation.info/[Заправочная станция ETH] предоставляет информацию о текущих ценах на газ и других соответствующих показателях газа для основной сети Ethereum.
====

Кошельки могут корректировать +цену на газ+ в транзакциях, которые они инициируют, чтобы добиться более быстрого подтверждения транзакций. Чем выше +цена на газ+, тем быстрее транзакция, скорее всего, будет подтверждена. И наоборот, транзакции с более низким приоритетом могут иметь более низкую цену, что приводит к более медленному подтверждению. Минимальное значение, которое +цена на газ+ может быть установлено равным нулю, что означает транзакцию без комиссии. В периоды низкого спроса на место в блоке такие транзакции вполне могут быть добыты.

[NOTE]
====
Минимально приемлемая +цена на газ+ равна нулю. Это означает, что кошельки могут генерировать совершенно бесплатные транзакции. В зависимости от пропускной способности они могут никогда не быть подтверждены, но в протоколе нет ничего, что запрещало бы бесплатные транзакции. Вы можете найти несколько примеров таких транзакций, успешно включенных в блокчейн Ethereum.
====

[[gas_price_suggestion]]
Интерфейс web3 предлагает +цену на газ+, рассчитывая среднюю цену по нескольким блокам (для этого мы можем использовать консоль truffle или любую консоль JavaScript web3).:

++++
<pre data-type="programlisting">
> <strong>web3.eth.getGasPrice(console.log)</strong>
> null BigNumber { s: 1, e: 10, c: [ 10000000000 ] }
</pre>
++++

[[calc_gas_price]]
((("gasLimit field")))Второе важное поле, связанное с газом, - это +ограничение газа+. Проще говоря, +gasLimit+ дает максимальное количество единиц газа, которое инициатор транзакции готов купить для завершения транзакции. Для простых платежей, то есть транзакций, которые переводят эфир из одного EOA в другой EOA, необходимое количество газа фиксировано на уровне 21 000 единиц газа. Чтобы рассчитать, сколько эфира это будет стоить, вы умножаете 21 000 на + цену на газ +, которую вы готовы заплатить. Например:

++++
<pre data-type="programlisting">
> <strong>web3.eth.getGasPrice(function(err, res) {console.log(res*21000)} )</strong>
> 210000000000000
</pre>
++++

If your transaction's destination address is a contract, then the amount of gas needed can be estimated but cannot be determined with accuracy. That's because a contract can evaluate different conditions that lead to different execution paths, with different total gas costs. The contract may execute only a simple computation or a more complex one, depending on conditions that are outside of your control and cannot be predicted. To demonstrate this, let's look at an example: we can write a smart contract that increments a counter each time it is called and executes a particular loop a number of times equal to the call count. Maybe on the 100th call it gives out a special prize, like a lottery, but needs to do additional computation to calculate the prize. If you call the contract 99 times one thing happens, but on the 100th call something very different happens. The amount of gas you would pay for that depends on how many other transactions have called that function before your transaction is included in a block. Perhaps your estimate is based on being the 99th transaction, but just before your transaction is confirmed someone else calls the contract for the 99th time. Now you're the 100th transaction to call, and the computation effort (and gas cost) is much higher.

To borrow a common analogy used in Ethereum, you can think of +gasLimit+ as the capacity of the fuel tank in your car (your car is the transaction). You fill the tank with as much gas as you think it will need for the journey (the computation needed to validate your transaction). You can estimate the amount to some degree, but there might be unexpected changes to your journey, such as a diversion (a more complex execution path), that increase fuel consumption.

The analogy to a fuel tank is somewhat misleading, however. It's actually more like a credit account for a gas station company, where you pay after the trip is completed, based on how much gas you actually used. When you transmit your transaction, one of the first validation steps is to check that the account it originated from has enough ether to pay the +gasPrice * gasLimit+. But the amount is not actually deducted from your account until the transaction finishes executing. You are only billed for gas actually consumed by your transaction, but you have to have enough balance for the maximum amount you are willing to pay before you send your transaction.(((range="endofrange", startref="ix_06transactions-asciidoc4")))(((range="endofrange", startref="ix_06transactions-asciidoc3")))

[[tx_recipient]]
=== Transaction Recipient

((("transactions","recipient of")))The recipient of a transaction is specified in the +to+ field. This contains a 20-byte Ethereum address. The address can be an EOA or a contract address.

Ethereum does no further validation of this field. Any 20-byte value is considered valid. If the 20-byte value corresponds to an address without a corresponding private key, or without a corresponding contract, the transaction is still valid. Ethereum has no way of knowing whether an address was correctly derived from a public key (and therefore from a private key) in existence.

[WARNING]
====
The Ethereum protocol does not validate recipient addresses in transactions. You can send to an address that has no corresponding private key or contract, thereby "burning" the ether, rendering it forever unspendable. Validation should be done at the user interface level.
====

((("ether burn")))Sending a transaction to the wrong address will probably _burn_ the ether sent, rendering it forever inaccessible (unspendable), since most addresses do not have a known private key and therefore no signature can be generated to spend it. It is assumed that validation of the address happens at the user interface level (see <<EIP55>>). In fact, there are a number of valid reasons for burning ether&#x2014;for example, as a disincentive to cheating in payment channels and other smart contracts&#x2014;and since the amount of ether is finite, burning ether effectively distributes the value burned to all ether holders (in proportion to the amount of ether they hold).

[[tx_value_data]]
=== Transaction Value and Data

((("transactions","value and data fields", id="ix_06transactions-asciidoc5", range="startofrange")))The main "payload" of a transaction is contained in ((("data field", id="ix_06transactions-asciidoc6", range="startofrange")))((("value field", id="ix_06transactions-asciidoc7", range="startofrange")))two fields: +value+ and +data+. Transactions can have both value and data, only value, only data, or neither value nor data. All four combinations are valid.

((("invocation")))((("payment")))A transaction with only value is a _payment_. A transaction with only data is an _invocation_. A transaction with both value and data is both a payment and an invocation. A transaction with neither value nor data&#x2014;well that's probably just a waste of gas! But it is still possible.

Let's try all of these combinations. First we'll set the source and destination addresses from our wallet, just to make the demo easier to read:

[source,javascript]
----
src = web3.eth.accounts[0];
dst = web3.eth.accounts[1];
----

Our first transaction contains only a value (payment), and no data payload:

[[tx_value_nodata_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, \
  value: web3.utils.toWei(0.01, "ether"), data: ""});
----

Our wallet shows a confirmation screen indicating the value to send, as shown in <<parity_txdemo_value_nodata>>.

[[parity_txdemo_value_nodata]]
.Parity wallet showing a transaction with value, but no data
image::images/parity_txdemo_value_nodata.png["Parity wallet showing a transaction with value, but no data"]


The next example specifies both a value and a data payload:

[[tx_value_data_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, \
  value: web3.utils.toWei(0.01, "ether"), data: "0x1234"});
----

Our wallet shows a confirmation screen indicating the value to send as well as the data payload, as shown in <<parity_txdemo_value_data>>.

[[parity_txdemo_value_data]]
.Parity wallet showing a transaction with value and data
image::images/parity_txdemo_value_data.png["Parity wallet showing a transaction with value and data"]

The next transaction includes a data payload but specifies a value of zero:

[[tx_novalue_data_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, value: 0, data: "0x1234"});
----

Our wallet shows a confirmation screen indicating the zero value and the data payload, as shown in <<parity_txdemo_novalue_data>>.

[[parity_txdemo_novalue_data]]
.Parity wallet showing a transaction with no value, only data
image::images/parity_txdemo_novalue_data.png["Parity wallet showing a transaction with no value, only data"]

[role="pagebreak-before"]
Finally, the last transaction includes neither a value to send nor a data payload:

[[tx_novalue_nodata_src]]
[source,javascript]
----
web3.eth.sendTransaction({from: src, to: dst, value: 0, data: ""}));
----

Our wallet shows a confirmation screen indicating zero value, as shown in <<parity_txdemo_novalue_nodata>>.

[[parity_txdemo_novalue_nodata]]
.Parity wallet showing a transaction with no value, and no data
image::images/parity_txdemo_novalue_nodata.png["Parity wallet showing a transaction with no value, and no data"]

[[value_EOA_contracts]]
==== Transmitting Value to EOAs and Contracts

((("EOA (Externally Owned Account)","transmitting value to")))((("smart contracts","transmitting value to")))((("transactions","transmitting value to EOAs and contract")))When you construct an Ethereum transaction that contains a value, it is the equivalent of a _payment_. Such transactions behave differently depending on whether the destination address is a contract or not.

For EOA addresses, or rather for any address that isn't flagged as a contract on the blockchain, Ethereum will record a state change, adding the value you sent to the balance of the address. If the address has not been seen before, it will be added to the client's internal representation of the state and its balance initialized to the value of your payment.

If the destination address (+to+) is a contract, then the EVM will execute the contract and will attempt to call the function named in the data payload of your transaction. If there is no data in your transaction, the EVM will call a _fallback_ function and, if that function is payable, will execute it to determine what to do next. If there is no code in fallback function, then the effect of the transaction will be to increase the balance of the contract, exactly like a payment to a wallet. If there is no fallback function or non-payable fallback function, then transaction will be reverted. 

A contract can reject incoming payments by throwing an exception immediately when a function is called, or as determined by conditions coded in a function. If the function terminates successfully (without an exception), then the contract's state is updated to reflect an increase in the contract's ether balance.(((range="endofrange", startref="ix_06transactions-asciidoc7")))(((range="endofrange", startref="ix_06transactions-asciidoc6")))

[[data_EOA]]
==== Transmitting a Data Payload to an EOA or Contract

((("data payload, transmitting to EOAs and contracts", id="ix_06transactions-asciidoc8", range="startofrange")))((("EOA (Externally Owned Account)","transmitting data payload to", id="ix_06transactions-asciidoc9", range="startofrange")))((("smart contracts","transmitting data payload to", id="ix_06transactions-asciidoc10", range="startofrange")))((("transactions","transmitting data payload to EOAs and contracts", id="ix_06transactions-asciidoc11", range="startofrange")))When your transaction contains data, it is most likely addressed to a contract address. That doesn't mean you cannot send a data payload to an EOA&#x2014;that is completely valid in the Ethereum protocol. However, in that case, the interpretation of the data is up to the wallet you use to access the EOA. It is ignored by the Ethereum protocol. Most wallets also ignore any data received in a transaction to an EOA they control. In the future, it is possible that standards may emerge that allow wallets to interpret data the way contracts do, thereby allowing transactions to invoke functions running inside user wallets. The critical difference is that any interpretation of the data payload by an EOA is not subject to Ethereum's consensus rules, unlike a contract pass:[<span class="keep-together">execution</span>].

For now, let's assume your transaction is delivering data to a contract address. ((("contract invocation")))((("invocation")))In that case, the data will be interpreted by the EVM as a _contract invocation_. ((("function invocation")))Most contracts use this data more specifically as a _function invocation_, calling the named function and passing any encoded arguments to the function.

The data payload sent to an ABI-compatible contract (which you can assume all contracts are) is a hex-serialized encoding of:

A function selector:: The first 4 bytes of the Keccak-256 hash of the function's prototype. This allows the contract to unambiguously identify which function you wish to invoke.

The function arguments:: The function's arguments, encoded according to the rules for the various elementary types defined in the ABI specification.

In <<solidity_faucet_example>>, we defined a function for withdrawals:

[[withdraw_function_src]]
[source,solidity]
----
function withdraw(uint withdraw_amount) public {
----

((("prototype of a function")))The _prototype_ of a function is defined as the string containing the name of the function, followed by the data types of each of its arguments, enclosed in parentheses and separated by commas. The function name here is +withdraw+ and it takes a single argument that is a +uint+ (which is an alias for +uint256+), so the prototype of +withdraw+ would be:

[source,solidity]
----
withdraw(uint256)
----

Let's calculate the Keccak-256 hash of this string:

++++
<pre data-type="programlisting">
> <strong>web3.utils.sha3("withdraw(uint256)");</strong>
'0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f'
</pre>
++++

The first 4 bytes of the hash are +0x2e1a7d4d+. That's our "function selector" value, which will tell the contract which function we want to call.

Next, let's calculate a value to pass as the argument +withdraw_amount+. We want to withdraw 0.01 ether. Let's encode that to a hex-serialized big-endian unsigned 256-bit integer, denominated in wei:

++++
<pre data-type="programlisting">
> <strong>withdraw_amount = web3.utils.toWei(0.01, "ether");</strong>
'10000000000000000'
> <strong>withdraw_amount_hex = web3.utils.toHex(withdraw_amount);</strong>
'0x2386f26fc10000'
</pre>
++++

Now, we add the function selector to the amount (padded to 32 bytes):

----
2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000
----

That's the data payload for our transaction, invoking the +withdraw+ function and requesting 0.01 ether as the +withdraw_amount+(((range="endofrange", startref="ix_06transactions-asciidoc11")))(((range="endofrange", startref="ix_06transactions-asciidoc10")))(((range="endofrange", startref="ix_06transactions-asciidoc9")))(((range="endofrange", startref="ix_06transactions-asciidoc8"))).(((range="endofrange", startref="ix_06transactions-asciidoc5")))

[[contract_reg]]
=== Special Transaction: Contract Creation

((("contract creation transaction", id="ix_06transactions-asciidoc12", range="startofrange")))((("transactions","contract creation", id="ix_06transactions-asciidoc13", range="startofrange")))One special case that we should mention is a transaction that _creates a new contract_ on the blockchain, deploying it for future use. ((("zero address","contract creation")))Contract creation transactions are sent to a special destination address called the _zero address_; the +to+ field in a contract registration transaction contains the address +0x0+. This address represents neither an EOA (there is no corresponding private–public key pair) nor a contract. It can never spend ether or initiate a transaction. It is only used as a destination, with the special meaning "create this contract."

While the zero address is intended only for contract creation, it sometimes receives payments from various addresses. ((("ether burn")))There are two explanations for this: either it is by accident, resulting in the loss of ether, or it is an intentional _ether burn_ (deliberately destroying ether by sending it to an address from which it can never be spent). However, if you want to do an intentional ether burn, you should make your intention clear to the network and use the specially designated burn address instead:

[[burn_address]]
----
0x000000000000000000000000000000000000dEaD
----

[WARNING]
====
Any ether sent to the designated burn address will become unspendable and be lost forever.
====

A contract creation transaction need only contain a data payload that contains the compiled bytecode which will create the contract. The only effect of this transaction is to create the contract. You can include an ether amount in the +value+ field if you want to set the new contract up with a starting balance, but that is entirely optional. If you send a value (ether) to the contract creation address without a data payload (no contract), then the effect is the same as sending to a burn address&#x2014;there is no contract to credit, so the ether is lost.

As an example, we can create the _Faucet.sol_ contract used in <<intro_chapter>> by manually creating a transaction to the zero address with the contract in the data payload. The contract needs to be compiled into a bytecode representation. This can be done with the Solidity compiler:

++++
<pre data-type="programlisting" class="pagebreak-before">
$ <strong>solc --bin Faucet.sol</strong>

Binary:
6060604052341561000f57600080fd5b60e58061001d6000396000f30060606040526004361060...
</pre>
++++

The same information can also be obtained from the Remix online compiler.

Now we can create the transaction:

++++
<pre data-type="programlisting">
> <strong>src = web3.eth.accounts[0];</strong>
> <strong>faucet_code = \
  "0x6060604052341561000f57600080fd5b60e58061001d6000396000f300606...f0029";</strong>
> <strong>web3.eth.sendTransaction({from: src, to: 0, data: faucet_code, \
  gas: 113558, gasPrice: 200000000000});</strong>

"0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b"
</pre>
++++

It is good practice to always specify a +to+ parameter, even in the case of zero-address contract creation, because the cost of accidentally sending your ether to +0x0+ and losing it forever is too great. You should also specify a +gasPrice+ and +gasLimit+.

Once the contract is mined we can see it on the Etherscan block explorer, as shown in <<publish_contract_from_web3>>.

[[publish_contract_from_web3]]
.Etherscan showing the contract successfully mined
image::images/contract_published.png["Etherscan showing the contract successfully mined"]

We can look at the receipt of the transaction to get information about the contract:

++++
<pre data-type="programlisting">
> <strong>web3.eth.getTransactionReceipt( \
  "0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b");</strong>

{
  blockHash: "0x6fa7d8bf982490de6246875deb2c21e5f3665b4422089c060138fc3907a95bb2",
  blockNumber: 3105256,
  contractAddress: "0xb226270965b43373e98ffc6e2c7693c17e2cf40b",
  cumulativeGasUsed: 113558,
  from: "0x2a966a87db5913c1b22a59b0d8a11cc51c167a89",
  gasUsed: 113558,
  logs: [],
  logsBloom: \
    "0x00000000000000000000000000000000000000000000000000...00000",
  status: "0x1",
  to: null,
  transactionHash: \
    "0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b",
  transactionIndex: 0
}
</pre>
++++

This includes the address of the contract, which we can use to send funds to and receive funds from the contract as shown in the previous section:

++++
<pre data-type="programlisting">
> <strong>contract_address = "0xb226270965b43373e98ffc6e2c7693c17e2cf40b"</strong>
> <strong>web3.eth.sendTransaction({from: src, to: contract_address, \
  value: web3.utils.toWei(0.1, "ether"), data: ""});</strong>

"0x6ebf2e1fe95cc9c1fe2e1a0dc45678ccd127d374fdf145c5c8e6cd4ea2e6ca9f"

> <strong>web3.eth.sendTransaction({from: src, to: contract_address, value: 0, data: \
  "0x2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000"});</strong>

"0x59836029e7ce43e92daf84313816ca31420a76a9a571b69e31ec4bf4b37cd16e"
</pre>
++++

After a while, both transactions are visible on Etherscan, as shown in <<publish_contract_transactions>>.(((range="endofrange", startref="ix_06transactions-asciidoc13")))(((range="endofrange", startref="ix_06transactions-asciidoc12")))

[[publish_contract_transactions]]
.Etherscan showing the transactions for sending and receiving funds
image::images/published_contract_transactions.png["Etherscan showing the transactions for sending and receiving funds"]


[[digital_sign]]
=== Digital Signatures

((("digital signatures", id="ix_06transactions-asciidoc14", range="startofrange")))((("transactions","digital signatures and", id="ix_06transactions-asciidoc15", range="startofrange")))So far, we have not delved into any detail about digital signatures. In this section, we look at how digital signatures work and how they can be used to present proof of ownership of a private key without revealing that private key.

[[ecdsa]]
==== The Elliptic Curve Digital Signature Algorithm

((("digital signatures","ECDSA and")))((("Elliptic Curve Digital Signature Algorithm (ECDSA)","about")))The digital signature algorithm used in Ethereum is the _Elliptic Curve Digital Signature Algorithm_ (ECDSA). It's based on elliptic curve private–public key pairs, as described in <<elliptic_curve>>.

A digital signature serves three purposes in Ethereum (see the following sidebar). First, the signature proves that the owner of the private key, who is by implication the owner of an Ethereum account, has _authorized_ the spending of ether, or execution of a contract. ((("non-repudiation")))Secondly, it guarantees _non-repudiation_: the proof of authorization is undeniable. Thirdly, the signature proves that the transaction data has not been and _cannot be modified_ by anyone after the transaction has been signed.

[[digital_signature_definition]]
.Wikipedia's Definition of a Digital Signature
****
((("digital signatures","Wikipedia definition")))A _digital signature_ is a mathematical scheme for presenting the authenticity of digital messages or documents. A valid digital signature gives a recipient reason to believe that the message was created by a known sender (authentication), that the sender cannot deny having sent the message (non-repudiation), and that the message was not altered in transit (integrity).

_Source: https://en.wikipedia.org/wiki/Digital_signature_
****

[[digital_sign_work]]
==== How Digital Signatures Work

((("digital signatures","mechanism of operation")))A digital signature is a mathematical scheme that consists of two parts. The first part is an algorithm for creating a signature, using a private key (the signing key), from a message (which in our case is the transaction). The second part is an algorithm that allows anyone to verify the signature by only using the message and a public key.

[[digital_sign_create]]
===== Creating a digital signature

((("digital signatures","creating")))((("Elliptic Curve Digital Signature Algorithm (ECDSA)","signature creation")))In Ethereum's implementation of ECDSA, the "message" being signed is the transaction, or more accurately, the Keccak-256 hash of the RLP-encoded data from the transaction. The signing key is the EOA's private key. The result is the signature:

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <mrow>
      <mi>S</mi>
      <mi>i</mi>
      <mi>g</mi>
    </mrow>
    <mo>=</mo>
    <msub><mi>F</mi> <mrow><mi>s</mi><mi>i</mi><mi>g</mi></mrow> </msub>
    <mrow>
      <mo>(</mo>
      <msub><mi>F</mi> <mrow><mi>k</mi><mi>e</mi><mi>c</mi><mi>c</mi><mi>a</mi><mi>k</mi><mn>256</mn></mrow> </msub>
      <mrow>
        <mo>(</mo>
        <mi>m</mi>
        <mo>)</mo>
      </mrow>
      <mo>,</mo>
      <mi>k</mi>
      <mo>)</mo>
    </mrow>
  </mrow>
</math>
</div>
++++

where:

* _k_ is the signing private key.
* _m_ is the RLP-encoded transaction.
* _F_~_keccak256_~ is the Keccak-256 hash function.
* _F_~_sig_~ is the signing algorithm.
* _Sig_ is the resulting signature.

[[sign_function]]
The function _F_~_sig_~ produces a signature __Sig__ that is composed of two values, commonly referred to as _r_ and _s_:

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mrow>
    <mrow>
      <mi>S</mi>
      <mi>i</mi>
      <mi>g</mi>
    </mrow>
    <mo>=</mo>
    <mo>(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>)</mo>
  </mrow>
</math>
</div>
++++

[[verify_sign]]
==== Verifying the Signature

((("digital signatures","verifying")))To verify the signature, one must have the signature (_r_ and _s_), the serialized transaction, and the public key that corresponds to the private key used to create the signature. Essentially, verification of a signature means "only the owner of the private key that generated this public key could have produced this signature on this transaction."

The signature verification algorithm takes the message (i.e., a hash of the transaction for our usage), the signer's public key, and the signature (_r_ and _s_ values), and returns +true+ if the signature is valid for this message and public key.

[[ecdsa_math]]
==== ECDSA Math

((("digital signatures","ECDSA math", id="ix_06transactions-asciidoc16", range="startofrange")))((("Elliptic Curve Digital Signature Algorithm (ECDSA)","mathematics of", id="ix_06transactions-asciidoc17", range="startofrange")))As mentioned previously, signatures are created by a mathematical function _F_~_sig_~ that produces a signature composed of two values, _r_ and _s_. In this section we look at the function _F_~_sig_~ in more detail.

((("ephemeral private key")))The signature algorithm first generates an _ephemeral_ (temporary) private key in a cryptographically secure way. This temporary key is used in the calculation of the _r_ and _s_ values to ensure that the sender's actual private key can't be calculated by attackers watching signed transactions on the Ethereum network.

As we know from <<pubkey>>, the ephemeral private key is used to derive the corresponding (ephemeral) public key, so we have:

* A cryptographically secure random number _q_, which is used as the ephemeral private key
* The corresponding ephemeral public key _Q_, generated from _q_ and the elliptic curve generator point _G_

The _r_ value of the digital signature is then the _x_ coordinate of the ephemeral public key _Q_.

From there, the algorithm calculates the _s_ value of the signature, such that:

++++
<ul class="simplelist">
<li><em>s</em> &#8801; <em>q</em><sup>-1</sup> (<em>Keccak256</em>(<em>m</em>) + <em>r</em> * <em>k</em>)  &nbsp;  &nbsp; (<em>mod p</em>)</li>
</ul>
++++

where:

* _q_ is the ephemeral private key.
* _r_ is the _x_ coordinate of the ephemeral public key.
* _k_ is the signing (EOA owner's) private key.
* _m_ is the transaction data.
* _p_ is the prime order of the elliptic curve.

Verification is the inverse of the signature generation function, using the _r_ and _s_ values and the sender's public key to calculate a value _Q_, which is a point on the elliptic curve (the ephemeral public key used in signature creation). The steps are as follows:

1. Check all inputs are correctly formed
2. Calculate _w_ = __s__^-1^ _mod p_
3. Calculate _u~1~_ = __Keccak256__(__m__) * _w_ _mod p_
4. Calculate _u~2~_ = _r_ * _w_ _mod p_
5. Finally, calculate the point on the elliptic curve _Q_ &#8801; _u~1~_ * _G_ + _u~2~_ * _K_  {nbsp} {nbsp} (_mod p_)

where:

* _r_ and _s_ are the signature values.
* _K_ is the signer's (EOA owner's) public key.
* _m_ is the transaction data that was signed.
* _G_ is the elliptic curve generator point.
* _p_ is the prime order of the elliptic curve.

If the _x_ coordinate of the calculated point _Q_ is equal to _r_, then the verifier can conclude that the signature is valid.

Note that in verifying the signature, the private key is neither known nor revealed.

[TIP]
====
ECDSA is necessarily a fairly complicated piece of math; a full explanation is beyond the scope of this book. A number of great guides online take you through it step by step: search for "ECDSA explained" or try this one: http://bit.ly/2r0HhGB[].(((range="endofrange", startref="ix_06transactions-asciidoc17")))(((range="endofrange", startref="ix_06transactions-asciidoc16")))
====

[[tx_sign]]
==== Transaction Signing in Practice

((("digital signatures","signing in practice")))((("Elliptic Curve Digital Signature Algorithm (ECDSA)","transaction signing in practice")))((("transactions","signing in practice")))To produce a valid transaction, the originator must digitally sign the message, using the Elliptic Curve Digital Signature Algorithm. When we say "sign the transaction" we actually mean "sign the Keccak-256 hash of the RLP-serialized transaction data." The signature is applied to the hash of the transaction data, not the transaction itself.

To sign a transaction in Ethereum, the originator must:

1. Create a transaction data structure, containing nine fields: +nonce+, +gasPrice+, +gasLimit+, +to+, +value+, +data+, +chainID+, +0+, +0+.
2. Produce an RLP-encoded serialized message of the transaction data structure.
3. Compute the Keccak-256 hash of this serialized message.
4. Compute the ECDSA signature, signing the hash with the originating EOA's private key.
5. Append the ECDSA signature's computed +v+, +r+, and +s+ values to the transaction.

The special signature variable +v+ indicates two things: the chain ID and the recovery identifier to help the +ECDSArecover+ function check the signature. It is calculated as either one of 27 or 28, or as the chain ID doubled plus 35 or 36. For more information on the chain ID, see <<raw_tx_eip155>>. The recovery identifier (27 or 28 in the "old-style" signatures, or 35 or 36 in the full Spurious Dragon&#x2013;style transactions) is used to indicate the parity of the +y+ component of the public key (see <<sign_prefix>> for more details).


[NOTE]
====
((("Spurious Dragon")))At block #2,675,000 Ethereum implemented the "Spurious Dragon" hard fork, which, among other changes, introduced a new signing scheme that includes transaction replay protection (preventing transactions meant for one network being replayed on others). This new signing scheme is specified in EIP-155. This change affects the form of the transaction and its signature, so attention must be paid to the first of the three signature variables (i.e., +v+), which takes one of two forms and indicates the data fields included in the transaction message being hashed.
====


[[raw_tx]]
==== Raw Transaction Creation and Signing

((("EthereumJS")))((("transactions","raw transaction creation/signing")))In this section we'll create a raw transaction and sign it, using the +ethereumjs-tx+ library, which can be installed with npm. This demonstrates the functions that would normally be used inside a wallet, or an application that signs transactions on behalf of a user. The source code for this example is in the file __raw_tx_demo.js__ in the book's http://bit.ly/2yI2GL3[GitHub repository]:

[[raw_tx_demo_source]]
[source,javascript]
----
include::code/web3js/raw_tx/raw_tx_demo.js[]
----

[[raw_tx_demo_run]]
Running the example code produces the following results:

++++
<pre data-type="programlisting">
$ <strong>node raw_tx_demo.js</strong>
RLP-Encoded Tx: 0xe6808609184e72a0008303000094b0920c523d582040f2bcb1bd7fb1c7c1...
Tx Hash: 0xaa7f03f9f4e52fcf69f836a6d2bbc7706580adce0a068ff6525ba337218e6992
Signed Raw Transaction: 0xf866808609184e72a0008303000094b0920c523d582040f2bcb1...
</pre>
++++

[[raw_tx_eip155]]
==== Raw Transaction Creation with EIP-155

((("chain identifier")))((("EIP-155 Simple Replay Attack Protection standard")))((("transactions","raw transaction creation with EIP-155")))The EIP-155 "Simple Replay Attack Protection" standard specifies a replay-attack-protected transaction encoding, which includes a _chain identifier_ inside the transaction data, prior to signing. This ensures that transactions created for one blockchain (e.g., the Ethereum main network) are invalid on another blockchain (e.g., Ethereum Classic or the Ropsten test network). Therefore, transactions broadcast on one network cannot be _replayed_ on another, hence the name of the standard.

EIP-155 adds three fields to the main six fields of the transaction data structure, namely the chain identifier, +0+, and +0+. These three fields are added to the transaction data _before it is encoded and hashed_. They therefore change the transaction's hash, to which the signature is later applied. By including the chain identifier in the data being signed, the transaction signature prevents any changes, as the signature is invalidated if the chain identifier is modified. Therefore, EIP-155 makes it impossible for a transaction to be replayed on another chain, because the signature's validity depends on the chain identifier.


The chain identifier field takes a value according to the network the transaction is meant for, as outlined in <<chain_id_table>>.

[[chain_id_table]]
.Chain identifiers
[options="header"]
|======
| Chain | Chain ID
| Ethereum mainnet | 1
| Morden (obsolete), Expanse | 2
| Ropsten | 3
| Rinkeby | 4
| Rootstock mainnet | 30
| Rootstock testnet | 31
| Kovan | 42
| Ethereum Classic mainnet | 61
| Ethereum Classic testnet | 62
| Geth private testnets | 1337
|======

The resulting transaction structure is RLP-encoded, hashed, and signed. The signature algorithm is modified slightly to encode the chain identifier in the +v+ prefix too.

For more details, see http://bit.ly/2CQUgne[the EIP-155 specification].(((range="endofrange", startref="ix_06transactions-asciidoc15")))(((range="endofrange", startref="ix_06transactions-asciidoc14")))

[[sign_prefix]]
=== The Signature Prefix Value (v) and Public Key Recovery

((("digital signatures","signature prefix value (v) and public key recovery")))((("public key recovery")))((("transactions","signature prefix value (v) and public key recovery")))As mentioned in <<tx_struct>>, the transaction message doesn't include a "from" field. That's because the originator's public key can be computed directly from the ECDSA signature. Once you have the public key, you can compute the address easily. The process of recovering the signer's public key is called _public key recovery_.

Given the values +r+ and +s+ that were computed in <<ecdsa_math>>, we can compute two possible public keys.

First, we compute two elliptic curve points, _R_ and __R__^__'__^, from the _x_ coordinate +r+ value that is in the signature. There are two points because the elliptic curve is symmetric across the x-axis, so that for any value +x+ there are two possible values that fit the curve, one on each side of the x-axis.

From +r+ we also calculate __r__^-1^, which is the multiplicative inverse of +r+.

Finally, we calculate _z_, which is the _n_ lowest bits of the message hash, where _n_ is the order of the elliptic curve.

The two possible public keys are then:

++++
<ul class="simplelist">
<li><em>K</em><sub>1</sub> = <em>r</em><sup>&#x2013;1</sup> (<em>sR</em> &#x2013; <em>zG</em>)</li>
</ul>
++++

and:

++++
<ul class="simplelist">
<li><em>K</em><sub>2</sub> = <em>r</em><sup>&#x2013;1</sup> (<em>sR</em><sup>'</sup> &#x2013; <em>zG</em>)</li>
</ul>
++++

where:

* __K__~1~ and __K__~2~ are the two possibilities for the signer's public key.
* __r__^-1^ is the multiplicative inverse of the signature's +r+ value.
* _s_ is the signature's +s+ value.
* __R__ and __R__^'^ are the two possibilities for the ephemeral public key _Q_.
* _z_ is the __n__-lowest bits of the message hash.
* _G_ is the elliptic curve generator point.

To make things more efficient, the transaction signature includes a prefix value +v+, which tells us which of the two possible _R_ values is the ephemeral public key. If +v+ is even, then _R_ is the correct value. If +v+ is odd, then it is __R__^'^. That way, we need to calculate only one value for _R_ and only one value for _K_.

[[offline_sign]]
=== Separating Signing and Transmission (Offline Signing)

((("digital signatures","separating signing and transmission", id="ix_06transactions-asciidoc18", range="startofrange")))((("offline signing", id="ix_06transactions-asciidoc19", range="startofrange")))((("transactions","separating signing and transmission", id="ix_06transactions-asciidoc20", range="startofrange")))Once a transaction is signed, it is ready to transmit to the Ethereum network. The three steps of creating, signing, and broadcasting a transaction normally happen as a single operation, for example using +web3.eth.sendTransaction+. However, as you saw in <<raw_tx>>, you can create and sign the transaction in two separate steps. Once you have a signed transaction, you can then transmit it using +web3.eth.sendSignedTransaction+, which takes a hex-encoded and signed transaction and transmits it on the Ethereum network.

Why would you want to separate the signing and transmission of transactions? The most common reason is security. The computer that signs a transaction must have unlocked private keys loaded in memory. The computer that does the transmitting must be connected to the internet (and be running an Ethereum client). If these two functions are on one computer, then you have private keys on an online system, which is quite dangerous. Separating the functions of signing and transmitting and performing them on different machines (on an offline and an online device, respectively) is called _offline signing_ and is a common security practice.

<<offline_signing>> shows the process:

1. Create an unsigned transaction on the online computer where the current state of the account, notably the current nonce and funds available, can be retrieved.
2. Transfer the unsigned transaction to an "air-gapped" offline device for transaction signing, e.g., via a QR code or USB flash drive.
3. Transmit the signed transaction (back) to an online device for broadcast on the Ethereum blockchain, e.g., via QR code or USB flash drive.

[[offline_signing]]
.Offline signing of Ethereum transactions
image::images/offline_signing.png["Offline signing of Ethereum transactions"]

Depending on the level of security you need, your "offline signing" computer can have varying degrees of separation from the online computer, ranging from an isolated and firewalled subnet (online but segregated) to a completely offline system known as an _air-gapped_ system. ((("air-gapped system")))In an air-gapped system there is no network connectivity at all&#x2014;the computer is separated from the online environment by a gap of "air." To sign transactions you transfer them to and from the air-gapped computer using data storage media or (better) a webcam and QR code. Of course, this means you must manually transfer every transaction you want signed, and this doesn't scale.

While not many environments can utilize a fully air-gapped system, even a small degree of isolation has significant security benefits. For example, an isolated subnet with a firewall that only allows a message-queue protocol through can offer a much-reduced attack surface and much higher security than signing on the online system. ((("ZeroMQ (0MQ)")))Many companies use a protocol such as ZeroMQ (0MQ) for this purpose. With a setup like that, transactions are serialized and queued for signing. The queuing protocol transmits the serialized message, in a way similar to a TCP socket, to the signing computer. The signing computer reads the serialized transactions from the queue (carefully), applies a signature with the appropriate key, and places them on an outgoing queue. The outgoing queue transmits the signed transactions to a computer with an Ethereum client that dequeues them and transmits them.(((range="endofrange", startref="ix_06transactions-asciidoc20")))(((range="endofrange", startref="ix_06transactions-asciidoc19")))(((range="endofrange", startref="ix_06transactions-asciidoc18")))

[[tx_propagation]]
=== Transaction Propagation

((("flood routing")))((("node","transaction propagation")))((("propagation of transactions")))((("transactions","propagation of")))The Ethereum network uses a "flood routing" protocol. Each Ethereum client acts as a _node_ in a _peer-to-peer (P2P)_ network, which (ideally) forms a _mesh_ network. No network node is special: they all act as equal peers. We will use the term "node" to refer to an Ethereum client that is connected to and participates in the P2P network.

Transaction propagation starts with the originating Ethereum node creating (or receiving from offline) a signed transaction. The transaction is validated and then transmitted to all the other Ethereum nodes that are _directly_ connected to the originating node. ((("neighbor nodes")))On average, each Ethereum node maintains connections to at least 13 other nodes, called its _neighbors_. Each neighbor node validates the transaction as soon as they receive it. If they agree that it is valid, they store a copy and propagate it to all their neighbors (except the one it came from). As a result, the transaction ripples outwards from the originating node, _flooding_ across the network, until all nodes in the network have a copy of the transaction. Nodes can filter the messages they propagate, but the default is to propagate all valid transaction messages they receive.

Within just a few seconds, an Ethereum transaction propagates to all the Ethereum nodes around the globe. From the perspective of each node, it is not possible to discern the origin of the transaction. The neighbor that sent it to the node may be the originator of the transaction or may have received it from one of its neighbors. To be able to track the origins of transactions, or interfere with propagation, an attacker would have to control a significant percentage of all nodes. This is part of the security and privacy design of P2P networks, especially as applied to blockchain networks.

[[chain_record]]
=== Recording on the Blockchain

((("blockchain","recording transactions on")))((("miners")))((("mining farms")))((("transactions","recording on the blockchain")))While all the nodes in Ethereum are equal peers, some of them are operated by _miners_ and are feeding transactions and blocks to _mining farms_, which are computers with high-performance graphics processing units (GPUs). The mining computers add transactions to a candidate block and attempt to find a _proof of work_ that makes the candidate block valid. We will discuss this in more detail in <<consensus>>.

Without going into too much detail, valid transactions will eventually be included in a block of transactions and, thus, recorded in the Ethereum blockchain. Once mined into a block, transactions also modify the state of the Ethereum singleton, either by modifying the balance of an account (in the case of a simple payment) or by invoking contracts that change their internal state. These changes are recorded alongside the transaction, in the form of a transaction _receipt_, which may also include _events_. We will examine all this in much more detail in <<evm_chapter>>.

A transaction that has completed its journey from creation through signing by an EOA, propagation, and finally mining has changed the state of the singleton and left an indelible mark on the blockchain.

=== Multiple-Signature (Multisig) Transactions

((("multiple-signature (multisig) transactions")))((("transactions","multiple-signature")))If you are familiar with Bitcoin's scripting capabilities, you know that it is possible to create a Bitcoin multisig account which can only spend funds when multiple parties sign the transaction (e.g., 2 of 2 or 3 of 4 signatures). Ethereum's basic EOA value transactions have no provisions for multiple signatures; however, arbitrary signing restrictions can be enforced by smart contracts with any conditions you can think of, to handle the transfer of ether and tokens alike.

To take advantage of this capability, ether has to be transferred to a "wallet contract" that is programmed with the spending rules desired, such as multisignature requirements or spending limits (or combinations of the two). The wallet contract then sends the funds when prompted by an authorized EOA once the spending conditions have been satisfied. For example, to protect your ether under a multisig condition, transfer the ether to a multisig contract. Whenever you want to send funds to another account, all the required users will need to send transactions to the contract using a regular wallet app, effectively authorizing the contract to perform the final pass:[<span class="keep-together">transaction</span>].

These contracts can also be designed to require multiple signatures before executing local code or to trigger other contracts. The security of the scheme is ultimately determined by the multisig contract code.

The ability to implement multisignature transactions as a smart contract demonstrates the flexiblity of Ethereum. However, it is a double-edged sword, as the extra flexibility can lead to bugs that undermine the security of multisignature schemes. There are, in fact, a number of proposals to create a multisignature command in the EVM that removes the need for smart contracts, at least for the simple M-of-N multisignature schemes. This would be equivalent to Bitcoin's multisignature system, which is part of the core consensus rules and has proven to be robust and secure.

=== Conclusions

Transactions are the starting point of every activity in the Ethereum system. Transactions are the "inputs" that cause the Ethereum Virtual Machine to evaluate contracts, update balances, and more generally modify the state of the Ethereum blockchain. Next, we will work with smart contracts in a lot more detail and learn how to program in the Solidity contract-oriented language.(((range="endofrange", startref="ix_06transactions-asciidoc0")))

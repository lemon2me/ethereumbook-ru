[[wallets_chapter]]
== Кошельки

((("wallets", id="ix_05wallets-asciidoc0", range="startofrange")))Слово "кошелек" используется для описания нескольких разных вещей в Ethereum.

На высоком уровне кошелек - это программное приложение, которое служит основным пользовательским интерфейсом для Ethereum. Кошелек контролирует доступ к деньгам пользователя, управляет ключами и адресами, отслеживает баланс, а также создает и подписывает транзакции. Кроме того, некоторые кошельки Ethereum также могут взаимодействовать с контрактами, такими как токены ERC20.

((("wallets","defined")))В более узком смысле, с точки зрения программиста, слово _кошелек_ (_wallet_) относится к системе, используемой для хранения ключей пользователя и управления ими. В каждом кошельке есть компонент управления ключами. Для некоторых кошельков это все, что есть. Другие кошельки являются частью гораздо более широкой категории - браузеры, которые являются интерфейсами к децентрализованным приложениям на основе Ethereum, или приложениям (DApps), которые мы рассмотрим более подробно в разделе <<decentralized_applications_chap>>. Нет четких границ между различными категориями, которые объединяются под термином кошелек.

В этой главе мы рассмотрим кошельки как контейнеры для закрытых ключей и как системы для управления этими ключами.

[[wallet_tech_overview]]
=== Обзор технологии кошелька

((("wallets","technology overview", id="ix_05wallets-asciidoc1", range="startofrange")))В этом разделе мы кратко описываем различные технологии, используемые для создания удобных, безопасных и гибких кошельков Ethereum.

Одним из ключевых факторов при разработке кошельков является баланс между удобством и конфиденциальностью. Самый удобный кошелек Ethereum - это кошелек с одним закрытым ключом и адресом, который вы используете повторно для всего. К сожалению, такое решение является кошмаром для конфиденциальности, поскольку любой желающий может легко отслеживать и сопоставлять все ваши транзакции. Использование нового ключа для каждой транзакции лучше всего подходит для обеспечения конфиденциальности, но становится очень сложным в управлении. Правильного баланса достичь сложно, но именно поэтому хороший дизайн кошелька имеет первостепенное значение.

Распространенное заблуждение относительно Ethereum заключается в том, что кошельки Ethereum содержат эфир или токены. На самом деле, строго говоря, в кошельке хранятся только ключи. Эфир или другие токены записываются в блокчейне Ethereum. Пользователи управляют токенами в сети, подписывая транзакции с помощью ключей в своих кошельках. ((("keychains"))) В некотором смысле кошелек Ethereum - это _связка ключей_ (_keychain_). Сказав это, учитывая, что ключи, хранящиеся в кошельке, - это единственное, что необходимо для передачи эфира или токенов другим лицам, на практике это различие довольно несущественно. Где разница действительно имеет значение, так это в изменении своего мышления от работы с централизованной системой обычного банковского обслуживания (где только вы и банк можете видеть деньги на вашем счете, и вам нужно только убедить банк, что вы хотите перевести средства для совершения транзакции) к децентрализованной системе блокчейн-платформы (где каждый может видеть эфирный баланс учетной записи, хотя они, вероятно, не знают владельца учетной записи, и каждый должен быть убежден, что владелец хочет перевести средства для совершения транзакции). На практике это означает, что существует независимый способ проверить баланс счета, не нуждаясь в его кошельке. Более того, вы можете перенести управление своим счетом с вашего текущего кошелька на другой кошелек, если вам начинает не нравиться приложение wallet, которое вы начали использовать.

[NOTE]
====
Кошельки Ethereum содержат ключи, а не эфир или токены. Кошельки похожи на брелки, содержащие пары закрытых и открытых ключей. Пользователи подписывают транзакции с помощью закрытых ключей, тем самым доказывая, что они владеют эфиром. Эфир хранится в блокчейне.
====

Существует два основных типа кошельков, различающихся тем, связаны ли содержащиеся в них ключи друг с другом или нет.

((("nondeterministic (random) wallets", id="ix_05wallets-asciidoc2", range="startofrange")))((("random (nondeterministic) wallets", id="ix_05wallets-asciidoc3", range="startofrange")))((("wallets","nondeterministic", id="ix_05wallets-asciidoc4", range="startofrange")))Первый тип - это недетерминированный кошелек, где каждый ключ независимо генерируется из другого случайного числа. Ключи не связаны друг с другом. ((("JBOK wallets", seealso="nondeterministic (random) wallets")))Этот тип кошелька также известен как кошелек JBOK, от фразы "Just a Bunch of Keys" ("Просто связка ключей").

((("deterministic (seeded) wallets","defined")))((("wallets","deterministic")))Второй тип кошелька - это детерминированный кошелек, где все ключи получены из одного главного ключа, известного как _seed_. Все ключи в кошельках этого типа связаны друг с другом и могут быть сгенерированы повторно, если у одного из них есть исходное начальное значение. ((("key derivation methods")))Существует несколько различных методов получения ключей, используемых в детерминированных кошельках. Наиболее часто используемый метод вывода использует древовидную структуру, как описано в <<hd_wallets>>.

((("mnemonic code words")))((("seeds","mnemonic code words for")))Чтобы сделать детерминированные кошельки немного более защищенными от несчастных случаев с потерей данных, таких как кража вашего телефона или падение его в унитаз, исходные данные часто кодируются в виде списка слов (на английском или другом языке), которые вы можете записать и использовать в случае несчастного случая. Они известны как "мнемонические кодовые слова кошелька". Конечно, если кто-то получит ваши мнемонические кодовые слова, то он также может воссоздать ваш кошелек и таким образом получить доступ к вашему эфиру и смарт-контрактам. Поэтому будьте очень, очень осторожны со своим списком слов для восстановления! Никогда не храните его в электронном виде, в файле, на вашем компьютере или телефоне. Запишите его на бумаге и храните в надежном и надежном месте.

В следующих нескольких разделах каждая из этих технологий представлена на высоком уровне.


[[random_wallet]]
==== Недетерминированные (случайные) кошельки

В первом кошельке Ethereum (созданном для предварительной продажи Ethereum) в каждом файле кошелька хранился один случайно сгенерированный закрытый ключ. Такие кошельки заменяются детерминированными кошельками, потому что эти кошельки "старого образца" во многих отношениях уступают. Например, считается хорошей практикой избегать повторного использования адреса Ethereum в рамках обеспечения максимальной конфиденциальности при использовании Ethereum &#x2014; т.е. использовать новый адрес (для которого требуется новый закрытый ключ) каждый раз, когда вы получаете средства. Вы можете пойти дальше и использовать новый адрес для каждой транзакции, хотя это может дорого обойтись, если вы много работаете с токенами. Чтобы следовать этой практике, недетерминированный кошелек должен будет регулярно увеличивать свой список ключей, что означает, что вам нужно будет регулярно делать резервные копии. Если вы когда-нибудь потеряете свои данные (сбой диска, несчастный случай с алкоголем, кража телефона) до того, как вам удастся создать резервную копию своего кошелька, вы потеряете доступ к своим средствам и смарт-контрактам. С недетерминированными кошельками "типа 0" сложнее всего иметь дело, потому что они создают новый файл кошелька для каждого нового адреса "точно в срок".

((("keystore file")))Тем не менее, многие клиенты Ethereum (включая +geth+) используют файл _keystore_, который представляет собой файл в кодировке JSON, содержащий один (случайно сгенерированный) закрытый ключ, зашифрованный парольной фразой для дополнительной безопасности. Содержимое файла JSON выглядит следующим образом:

[[keystore_example]]
[source,json]
----
{
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
}
----

((("key derivation function (KDF)")))((("password stretching algorithm")))Формат хранилища ключей использует _функцию вывода ключей_ (_key derivation function_) (KDF), также известную как алгоритм растяжения пароля, который защищает от атак методом перебора, словаря и радужной таблицы. Проще говоря, закрытый ключ не шифруется непосредственно парольной фразой. Вместо этого кодовая фраза растягивается путем многократного ее хэширования. Функция хеширования повторяется для 262 144 раундов, которые можно увидеть в хранилище ключей JSON как параметр +crypto->kdfparams->n+. Злоумышленнику, пытающемуся взломать пароль методом перебора, пришлось бы применить 262 144 раунда хэширования для каждой попытки ввода пароля, что замедляет атаку настолько, что делает ее невозможной для паролей достаточной сложности и длины.

Существует ряд программных библиотек, которые могут считывать и записывать формат хранилища ключей, например библиотека JavaScript https://github.com/ethereumjs/keythereum[+keythereum+].

[TIP]
====
Использование недетерминированных кошельков не рекомендуется для чего-либо, кроме простых тестов. Они слишком громоздки, чтобы создавать резервные копии и использовать их для чего угодно, кроме самых простых ситуаций. Вместо этого используйте HD-кошелек на основе отраслевого стандарта с мнемоническим исходным кодом для резервного копирования. (((range="endofrange", startref="ix_05wallets-asciidoc4")))(((range="endofrange", startref="ix_05wallets-asciidoc3")))(((range="endofrange", startref="ix_05wallets-asciidoc2")))
====

[[deterministic_wallets]]
==== Детерминированные (Seeded) кошельки

((("deterministic (seeded) wallets","about")))((("wallets","deterministic")))Детерминированные или "seeded" кошельки - это кошельки, содержащие закрытые ключи, все из которые являются производными от одного главного ключа или seed. Начальное значение (seed) представляет собой случайно сгенерированное число, которое объединяется с другими данными, такими как номер индекса или "код цепочки" (см. <<extended_keys>>), для получения любого количества закрытых ключей. В детерминированном кошельке знание начального значения (seed) достаточно для восстановления всех производных ключей, и, следовательно, одной резервной копии во время создания достаточно для защиты всех средств и смарт-контрактов в кошельке. Начального значения также достаточно для экспорта или импорта кошелька, что позволяет легко переносить все ключи между различными реализациями кошелька.

Такая конструкция придает первостепенное значение безопасности seed, поскольку для получения доступа ко всему кошельку требуется только seed. С другой стороны, возможность сосредоточить усилия по обеспечению безопасности на одном фрагменте данных может рассматриваться как преимущество.

[[hd_wallets]]
==== Иерархические детерминированные кошельки (Hierarchical deterministic) (BIP-32/BIP-44)

((("Bitcoin improvement proposals (BIPs)","Hierarchical Deterministic Wallets (BIP-32/BIP-44)")))((("hierarchical deterministic wallets (BIP-32/BIP-44)")))Детерминированные кошельки были разработаны для того, чтобы упростить получение множества ключей из одного начального значения (seed). В настоящее время наиболее продвинутой формой детерминированного кошелька является _иерархический детерминированный_ (_hierarchical deterministic_ ) (HD) кошелек, определяемый биткойн http://bit.ly/2B2vQWs[стандартом _BIP-32_]. Кошельки HD содержат ключи, полученные в виде древовидной структуры, так что родительский ключ может выводить последовательность дочерних ключей, каждый из которых может выводить последовательность дочерних ключей и так далее. Эта древовидная структура проиллюстрирована на <<hd_wallets_figure>>.

[[hd_wallets_figure]]
.HD wallet: дерево ключей, сгенерированных из одного исходного seed
image::images/hd_wallet.png["HD wallet"]

HD-кошельки обладают несколькими ключевыми преимуществами по сравнению с более простыми детерминированными кошельками. Во-первых, древовидная структура может использоваться для выражения дополнительного организационного значения, например, когда определенная ветвь подразделов используется для приема входящих платежей, а другая ветвь используется для получения изменений от исходящих платежей. Ветви ключей также можно использовать в корпоративных настройках, распределяя различные ветви по отделам, дочерним компаниям, конкретным функциям или категориям учета.

Второе преимущество HD-кошельков заключается в том, что пользователи могут создавать последовательность открытых ключей, не имея доступа к соответствующим закрытым ключам. Это позволяет использовать HD-кошельки на небезопасном сервере или в режиме только для просмотра или приема, когда у кошелька нет закрытых ключей, на которые можно потратить средства.

[[mnemonic_codes]]
==== Seeds и мнемонические коды (BIP-39)

((("BIP-39 standard")))((("Bitcoin improvement proposals (BIPs)","Mnemonic Code Words (BIP-39)")))((("mnemonic code words","BIP-39")))((("seeds","mnemonic code words for", seealso="mnemonic code words")))((("wallets","mnemonic codes (BIP-39)")))Существует множество способов кодирования закрытого ключа для безопасного резервного копирования и извлечения. В настоящее время предпочтительным методом является использование последовательности слов, которые, будучи взяты вместе в правильном порядке, могут однозначно воссоздать закрытый ключ. Это иногда называют _mnemonic_, и этот подход был стандартизирован http://bit.ly/2OEMjUz[BIP-39]. Сегодня многие кошельки Ethereum (а также кошельки для других криптовалют) используют этот стандарт и могут импортировать и экспортировать исходные данные для резервного копирования и восстановления с помощью совместимых мнемоник.

Чтобы понять, почему этот подход стал популярным, давайте рассмотрим пример:

[[hex_seed_example]]
.Начальное значение (seed) для детерминированного кошелька в шестнадцатеричном формате
----
FCCF1AB3329FD5DA3DA9577511F8F137
----

[[mnemonic_seed_example]]
.Начальное значение (seed) для детерминированного кошелька из мнемоники из 12 слов
----
wolf juice proud gown wool unfair
wall cliff insect more detail hub
----

С практической точки зрения вероятность ошибки при записи шестнадцатеричной последовательности недопустимо высока. Напротив, со списком известных слов довольно легко иметь дело, главным образом потому, что существует высокий уровень избыточности в написании слов (особенно английских слов). Если бы "inzect" был записан случайно, при необходимости восстановления кошелька можно было бы быстро определить, что "inzect" не является допустимым английским словом и что вместо него следует использовать "insect". Мы говорим о записи представления начального значения, потому что это хорошая практика при управлении HD-кошельками: начальное значение необходимо для восстановления кошелька в случае потери данных (будь то в результате несчастного случая или кражи), поэтому сохранение резервной копии очень разумно. Однако исходные данные должны храниться в строгом секрете, поэтому следует тщательно избегать создания цифровых резервных копий; отсюда и предыдущий совет создавать резервные копии с помощью ручки и бумаги.

Таким образом, использование списка слов восстановления для кодирования seed для HD-кошелька обеспечивает самый простой способ безопасного экспорта, расшифровки, записи на бумаге, чтения без ошибок и импорта набора закрытых ключей в другой кошелек.(((range="endofrange", startref="ix_05wallets-asciidoc1")))


[[wallet_best_practices]]
=== Лучшие практики кошелька

((("wallets","best practices for", id="ix_05wallets-asciidoc5", range="startofrange")))По мере развития технологии криптовалютных кошельков появились определенные общие отраслевые стандарты, которые делают кошельки широко совместимыми, простыми в использовании, безопасными и гибкими. Эти стандарты также позволяют кошелькам получать ключи для нескольких различных криптовалют, все из одной мнемоники. Этими общими стандартами являются:

* Мнемонические кодовые слова, основанные на BIP-39
* HD кошельки, основанные на BIP-32
* Многофункциональная структура HD-кошелька, основанная на BIP-43
* Мультивалютные и мультиаккаунтные кошельки, основанные на BIP-44

Эти стандарты могут измениться или устареть в результате будущих разработок, но на данный момент они образуют набор взаимосвязанных технологий, которые стали стандартом кошелька de facto для большинства блокчейн-платформ и их криптовалют.

Стандарты были приняты широким спектром программных и аппаратных кошельков, что делает все эти кошельки совместимыми. Пользователь может экспортировать мнемонику, сгенерированную в одном из этих кошельков, и импортировать ее в другой кошелек, восстановив все ключи и адреса.

Некоторые примеры программных кошельков, поддерживающих эти стандарты, включают (перечислены в алфавитном порядке) Jaxx, MetaMask, MyCrypto и MyEtherWallet (MEW). ((("hardware wallets")))Примерами аппаратных кошельков, поддерживающих эти стандарты, являются Keepkey, Ledger и Trezor.

В следующих разделах подробно рассматривается каждая из этих технологий.

[TIP]
====
Если вы внедряете кошелек Ethereum, он должен быть построен как HD-кошелек с начальным значением (seed), закодированным в виде мнемонического кода для резервного копирования, в соответствии со стандартами BIP-32, BIP-39, BIP-43 и BIP-44, как описано в следующих разделах.
====

[[bip39]]
[[mnemonic_code_words]]
=== Мнемонические кодовые слова (BIP-39)

((("BIP-39 standard", id="ix_05wallets-asciidoc6", range="startofrange")))((("Bitcoin improvement proposals (BIPs)","Mnemonic Code Words (BIP-39)", id="ix_05wallets-asciidoc7", range="startofrange")))((("mnemonic code words","BIP-39", id="ix_05wallets-asciidoc8", range="startofrange")))((("wallets","mnemonic codes (BIP-39)", id="ix_05wallets-asciidoc9", range="startofrange")))Мнемонические кодовые слова - это последовательности слов, которые кодируют случайное число, используемое в качестве seed для получения детерминированного кошелька. Последовательности слов достаточно, чтобы воссоздать seed, а оттуда воссоздать кошелек и все производные ключи. Приложение кошелька, которое реализует детерминированные кошельки с мнемоническими словами, покажет пользователю последовательность из 12-24 слов при первом создании кошелька. Эта последовательность слов является резервной копией кошелька и может быть использована для восстановления и повторного создания всех ключей в том же или любом совместимом приложении кошелька. Как мы объясняли ранее, мнемонические списки слов облегчают пользователям резервное копирование кошельков, поскольку их легко читать и правильно pass:[<span class="keep-together">расшифровывать</span>].

[NOTE]
====
((("brainwallets, mnemonic words vs.")))Мнемонические слова часто путают с "мозговыми кошельками" (brainwallet). Это не одно и то же. Основное отличие заключается в том, что brainwallet состоит из слов, выбранных пользователем, в то время как мнемонические слова создаются кошельком случайным образом и представляются пользователю. Это важное различие делает мнемонические слова гораздо более безопасными, потому что люди - очень плохие источники случайности. Возможно, что еще более важно, использование термина "мозговой кошелек" предполагает, что слова нужно запоминать, что является ужасной идеей и рецептом отсутствия резервной копии, когда она вам нужна.
====

Мнемонические коды определены в BIP-39. Обратите внимание, что BIP-39 является одной из реализаций стандарта мнемонического кода. Существует другой стандарт, _с другим набором слов_, используемый биткойн-кошельком Electrum и предшествующий BIP-39. BIP-39 был предложен компанией, разработавшей аппаратный кошелек Trezor, и несовместим с реализацией Electrum. Тем не менее, BIP-39 в настоящее время получил широкую отраслевую поддержку в десятках совместимых реализаций и должен рассматриваться как фактический отраслевой стандарт. Кроме того, BIP-39 можно использовать для создания мультивалютных кошельков, поддерживающих Ethereum, в то время как seeds Electrum не могут.

BIP-39 определяет создание мнемонического кода и seed, которые мы описываем здесь в девять шагов. Для наглядности процесс разделен на две части: шаги с 1 по 6 показаны в <<generating_mnemonic_words>>, а шаги с 7 по 9 показаны в <<mnemonic_to_seed>>.

[[generating_mnemonic_words]]
===== Генерация мнемонических слов

((("BIP-39 standard","generating code words with")))((("checksum","in mnemonic code word generation")))((("mnemonic code words","generating")))Мнемонические слова генерируются кошельком автоматически с использованием стандартизированного процесса, определенного в BIP-39. Кошелек начинается с источника энтропии, добавляет контрольную сумму, а затем сопоставляет энтропию со списком слов:

1. Создайте криптографически случайную последовательность +S+ от 128 до 256 бит.
2. Создайте контрольную сумму для +S+, взяв первую часть (32 бита) хэша SHA-256 от ++S++.
3. Добавьте контрольную сумму в конец случайной последовательности +S+.
4. Разделите конкатенацию последовательности и контрольной суммы на секции по 11 бит.
5. Сопоставьте каждое 11-битное значение со словом из предопределенного словаря из 2048 слов.
6. Создайте мнемонический код из последовательности слов, соблюдая порядок.

<<generating_entropy_and_encoding>> показывает, как энтропия используется для генерации мнемонических слов.

<<table_bip39_entropy>> показывает взаимосвязь между размером энтропийных данных и длиной мнемонических кодов в словах.

[[table_bip39_entropy]]
.Мнемонические коды: энтропия и длина слова
[options="header"]
|=======
|Энтропия (биты) | Контрольная сумма (биты) | Энтропия *+* контрольная сумма (биты) | Мнемоническая длина (слова)
| 128 | 4 | 132 | 12
| 160 | 5 | 165 | 15
| 192 | 6 | 198 | 18
| 224 | 7 | 231 | 21
| 256 | 8 | 264 | 24
|=======

[[generating_entropy_and_encoding]]
[role="smallerseventy"]
.Генерация энтропии и кодирование в виде мнемонических слов
image::images/bip39-part1.png["Generating entropy and encoding as mnemonic words"]

[[mnemonic_to_seed]]
===== От мнемоники к seed

((("BIP-39 standard","deriving seed from mnemonic words")))((("seeds","deriving from mnemonic code words")))Мнемонические слова представляют энтропию длиной от 128 до 256 бит. Затем энтропия используется для получения более длинного (512-битного) начального значения с помощью функции растяжения ключа ((("PBKDF2 function")))PBKDF2. Полученное начальное значение используется для создания детерминированного кошелька и получения его ключей.

((("key-stretching function")))((("salts")))Функция растяжения ключа принимает два параметра: мнемоническое значение и _соль_ (_salt_). Цель соли в функции растяжения ключа состоит в том, чтобы затруднить создание таблицы поиска, позволяющей атаковать методом перебора. В стандарте BIP-39 соль имеет другое назначение: она позволяет вводить кодовую фразу, которая служит дополнительным фактором безопасности, защищающим seed, как мы более подробно опишем в <<mnemonic_passphrase>>.

Процесс, описанный на этапах с 7 по 9, продолжается с процесса, описанного в предыдущем разделе:

[start=7]
7. Первым параметром функции растяжения ключа PBKDF2 является _мнемонический код_ (_mnemonic_), созданный на шаге 6.
8. Вторым параметром функции растяжения ключа PBKDF2 является _соль_ (_salt_). Соль состоит из строковой константы +"мнемоники"+ объединенной с необязательной парольной фразой, предоставленной пользователем.
9. PBKDF2 растягивает мнемонические и солевые параметры, используя 2048 раундов хеширования с помощью алгоритма HMAC-SHA512, получая в качестве конечного результата 512-битное значение. Это 512-битное значение является seed.

<<mnemonic_to_seed_figure>> показывает, как мнемоника используется для создания начального значения (seed).

[[mnemonic_to_seed_figure]]
.От мнемоники к seed
image::images/bip39-part2.png["From mnemonic to seed"]

[NOTE]
====
Функция растяжения ключа с ее 2048 раундами хэширования является довольно эффективной защитой от атак методом перебора мнемоники или парольной фразы. Это делает дорогостоящим (в вычислениях) перепробование более нескольких тысяч парольных фраз и мнемонических комбинаций, в то время как число возможных производных seeds огромно (2^512^ или около 10^154^) &#x2014; намного больше, чем количество атомов в видимой вселенной (около 10^80^).
====

Таблицы pass:[<a data-type="xref" data-xrefstyle="select:labelnumber" href="#mnemonic_128_no_pass">#mnemonic_128_no_pass</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="#mnemonic_128_w_pass">#mnemonic_128_w_pass</a>, и <a data-type="xref" data-xrefstyle="select:labelnumber" href="#mnemonic_256_no_pass">#mnemonic_256_no_pass</a>] показывают несколько примеров мнемонических кодов и seeds, которые они производят.

[[mnemonic_128_no_pass]]
.128-битный энтропийный мнемонический код, без кодовой фразы, получившийся seed
[cols="h,"]
|=======
| *Энтропия на вход (128 бит)*| +0c1e24e5917779d297e14d45f14e1a1a+
| *Мнемоника (12 слов)* | +army van defense carry jealous true garbage claim echo media make crunch+
| *Кодовая фраза*| (отсутствует)
| *Seed  (512 бит)* | +5b56c417303faa3fcba7e57400e120a0ca83ec5a4fc9ffba757fbe63fbd77a89a1a3be4c67196f57c39+
+a88b76373733891bfaba16ed27a813ceed498804c0570+
|=======

[[mnemonic_128_w_pass]]
.128-битный энтропийный мнемонический код, с кодовой фразой, получившийся seed
[cols="h,"]
|=======
| *Энтропия на вход (128 бит)*| +0c1e24e5917779d297e14d45f14e1a1a+
| *Мнемоника (12 слов)* | +army van defense carry jealous true garbage claim echo media make crunch+
| *Кодовая фраза*| SuperDuperSecret
| *Seed  (512 бит)* | +3b5df16df2157104cfdd22830162a5e170c0161653e3afe6c88defeefb0818c793dbb28ab3ab091897d0+
+715861dc8a18358f80b79d49acf64142ae57037d1d54+
|=======

[role="pagebreak-before"]
[[mnemonic_256_no_pass]]
.256-битный энтропийный мнемонический код, без кодовой фразы, получившийся seed
[cols="h,"]
|=======
| *Энтропия на вход (256 бит)* | +2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c+
| *Мнемоника (24 слов)* | +cake apple borrow silk endorse fitness top denial coil riot stay wolf
luggage oxygen faint major edit measure invite love trap field dilemma oblige+
| *Кодовая фраза*| (отсутствует)
| *Seed (512 бит)* | +3269bce2674acbd188d4f120072b13b088a0ecf87c6e4cae41657a0bb78f5315b33b3a04356e53d062e5+
+5f1e0deaa082df8d487381379df848a6ad7e98798404+
|=======

[[mnemonic_passphrase]]
===== Опциональная кодовая фраза в BIP-39

((("BIP-39 standard","optional passphrase with")))((("mnemonic code words","optional passphrase in BIP-39")))((("passphrases")))((("seeds","optional passphrase with")))Стандарт BIP-39 позволяет использовать необязательную кодовую фразу при выводе начального значения. Если кодовая фраза не используется, мнемоника растягивается с помощью соли, состоящей из постоянной строки +"мнемоники"+, создавая определенное 512-битное начальное значение из любой заданной мнемоники. Если используется кодовая фраза, функция растяжения создает другой seed из той же мнемоники. На самом деле, учитывая одну мнемонику, каждая возможная кодовая фраза приводит к другому seed. По сути, не существует "неправильной" парольной фразы. Все парольные фразы действительны, и все они ведут к разным seeds, образуя обширный набор возможных неинициализированных кошельков. Набор возможных кошельков настолько велик (2^512^), что нет практической возможности перебора или случайного угадывания используемого кошелька, если кодовая фраза имеет достаточную сложность и длину.

[TIP]
====
В BIP-39 нет "неправильных" парольных фраз. Каждая кодовая фраза ведет к какому-то кошельку, который, если он не использовался ранее, будет пустым.
====

Необязательная кодовая фраза создает две важные функции:

* Второй фактор (что-то запомненное), который делает мнемонику бесполезной сама по себе, защищая мнемонические резервные копии от компрометации вором.

* ((("duress wallet")))((("wallets","duress wallet")))Форма правдоподобного отрицания или "принудительного кошелька" (duress wallet), когда выбранная кодовая фраза ведет к кошельку с небольшим количеством средств, используемая для отвлечения злоумышленника от "реального" кошелька, который содержит большую часть средств.

[role="pagebreak-before"]
Однако важно отметить, что использование парольной фразы также сопряжено с риском потери:

* Если владелец кошелька недееспособен или мертв, и никто другой не знает кодовую фразу, seed фраза бесполезна, и все средства, хранящиеся в кошельке, теряются навсегда.

* И наоборот, если владелец создает резервную копию ключевой фразы в том же месте, что и seed фразу, это сводит на нет цель второго фактора.

Хотя кодовые фразы очень полезны, их следует использовать только в сочетании с тщательно спланированным процессом резервного копирования и восстановления, учитывая возможность того, что наследники, пережившие владельца, смогут восстановить криптовалюту.
[[working_mnemonic_codes]]
===== Работа с мнемоническими кодами

((("BIP-39 standard","libraries")))((("BIP-39 standard","working with mnemonic codes")))BIP-39 реализован как библиотека на многих различных языках программирования. Например:

https://github.com/trezor/python-mnemonic[python-mnemonic]:: Эталонная реализация стандарта командой SatoshiLabs, предложившей BIP-39, на языке Python

https://github.com/ConsenSys/eth-lightwallet[ConsenSys/eth-lightwallet]:: Легкий кошелек JS Ethereum для узлов и браузера (с BIP-39)

https://www.npmjs.com/package/bip39[npm/bip39]:: Реализация биткойна BIP-39 на JavaScript: мнемонический код для генерации детерминированных ключей

Существует также генератор BIP-39, реализованный на отдельной веб-странице (<<a_bip39_generator_as_a_standalone_web_page>>), который чрезвычайно полезен для тестирования и экспериментов. https://iancoleman.io/bip39/[Конвертер мнемонического кода] генерирует мнемоники, seeds и расширенные закрытые ключи. Его можно использовать в автономном режиме в браузере или получить доступ к нему онлайн.(((range="endofrange", startref="ix_05wallets-asciidoc9")))(((range="endofrange", startref="ix_05wallets-asciidoc8")))(((range="endofrange", startref="ix_05wallets-asciidoc7")))(((range="endofrange", startref="ix_05wallets-asciidoc6")))

[[a_bip39_generator_as_a_standalone_web_page]]
.Генератор BIP-39 в качестве отдельной веб-страницы
image::images/bip39_web.png["BIP-39 generator web-page"]

[[create_hd_wallet]]
==== Создание HD-кошелька из seed

((("hierarchical deterministic wallets (BIP-32/BIP-44)","creating from root seed")))((("root seeds, creating HD wallets from")))((("wallets","creating HD wallets from root seed")))HD-кошельки создаются из одного _root seed_, который представляет собой 128-, 256- или 512-битное случайное число. Чаще всего это начальное значение генерируется из мнемоники, как описано в предыдущем разделе.

Каждый ключ в HD-кошельке детерминированно выводится из этого root seed, что позволяет воссоздать весь HD-кошелек из этого seed в любом совместимом HD-кошельке. Это позволяет легко экспортировать, создавать резервные копии, восстанавливать и импортировать HD-кошельки, содержащие тысячи или даже миллионы ключей, передавая только мнемонику, из которой получено root seed.

[[bip32_bip43_44]]
==== HD Кошельки (BIP-32) и Paths (BIP-43/44)

((("Bitcoin improvement proposals (BIPs)","Multipurpose HD Wallet Structure (BIP-43)", id="ix_05wallets-asciidoc10", range="startofrange")))((("hierarchical deterministic wallets (BIP-32/BIP-44)","HD wallets (BIP-32) and paths (BIP-43/44)", id="ix_05wallets-asciidoc11", range="startofrange")))Большинство HD-кошельков следуют ((("BIP-32 standard","HD wallets and", id="ix_05wallets-asciidoc12", range="startofrange")))стандарту BIP-32, который фактически стал отраслевым стандартом для детерминированной генерации ключей.

Мы не будем обсуждать здесь все детали BIP-32, только компоненты, необходимые для понимания того, как он используется в кошельках. Основным важным аспектом являются древовидные иерархические связи, которые могут быть у производных ключей, как вы можете видеть в <<hd_wallets_figure>>. Также важно понимать идеи _расширенных ключей_ (_extended keys_) и _усиленных ключей_ (_hardened keys_), которые объясняются в следующих разделах.

Существуют десятки совместимых реализаций BIP-32, предлагаемых во многих программных библиотеках. Они в основном предназначены для биткойн-кошельков, которые реализуют адреса по-другому, но используют ту же реализацию получения ключей, что и кошельки Ethereum, совместимые с BIP-32. Используйте одну из реализаций https://github.com/ConsenSys/eth-lightwallet[разработаных для Ethereum] или адаптируйте какую-либо из Биткойна, добавив библиотеку кодирования адресов Ethereum.

Существует также генератор BIP-32, реализованный в виде http://bip32.org/[отдельной веб-страницы], которая очень полезна для тестирования и экспериментов с BIP-32.

[WARNING]
====
Генератор BIP-32 не является сайтом HTTPS. Это должно напомнить вам, что использование этого инструмента небезопасно. Это только для тестирования. Вы не должны использовать ключи, созданные этим сайтом, с реальными средствами.
====

[[extended_keys]]
===== Расширенные открытые и закрытые ключи

((("BIP-32 standard","extended public and private keys")))((("extended keys")))((("hierarchical deterministic wallets (BIP-32/BIP-44)","extended public and private keys")))((("keys","extended")))В терминологии BIP-32 ключи могут быть "расширены" (extended). При правильных математических операциях эти расширенные "родительские" ключи могут использоваться для получения "дочерних" ключей, создавая таким образом иерархию ключей и адресов, описанную ранее. Родительский ключ не обязательно должен находиться в верхней части дерева. Его можно выбрать из любого места древовидной иерархии.((("chain code"))) Расширение ключа включает в себя взятие самого ключа и добавление к нему специальной последователбности – _цепочки кода_ (_chain code_). Такая цепочка это 256-битная двоичная строка, которая смешивается с каждым ключом для получения дочерних ключей.

((("private keys","extended")))Если ключ является закрытым ключом, он становится _расширенным закрытым ключом_ (_extended private key_) с pass:[<span class="keep-together">префикс</span>] +xprv+:

[[xprv_example]]
----
xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8i...
----

((("public keys","extended")))_Расширенный открытый ключ_ (_extended public key_) отличается префиксом +xpub+:

[[xpub_example]]
----
xpub661MyMwAqRbcEnKbXcCqD2GT1di5zQxVqoHPAgHNe8dv5JP8gWmDproS6kFHJnLZd23tWevhdn...
----

Очень полезной характеристикой HD-кошельков является возможность получения дочерних открытых ключей из родительских открытых ключей, не имея закрытых ключей. Это дает нам два способа получения дочернего открытого ключа: либо непосредственно из дочернего закрытого ключа, либо из родительского открытого ключа.

Таким образом, расширенный открытый ключ можно использовать для получения всех открытых ключей (и только открытых ключей) в этой ветви структуры HD wallet.

Этот способ можно использовать для создания очень безопасных развертываний только с открытым ключом, когда сервер или приложение имеют копию расширенного открытого ключа, но вообще не имеют закрытых ключей. Такое развертывание может создать бесконечное количество открытых ключей и адресов Ethereum, но не может потратить деньги, отправленные на эти адреса. Между тем, на другом, более защищенном сервере расширенный закрытый ключ может извлекать все соответствующие закрытые ключи для подписания транзакций и расходования денег.

Одним из распространенных применений этого метода является установка расширенного открытого ключа на веб-сервере, который обслуживает приложение электронной коммерции. Веб-сервер может использовать функцию получения открытого ключа для создания нового адреса Ethereum для каждой транзакции (например, для корзины покупок клиента) и не будет иметь никаких закрытых ключей, которые были бы уязвимы для кражи. Без HD-кошельков единственный способ сделать это - сгенерировать тысячи адресов Ethereum на отдельном защищенном сервере, а затем предварительно загрузить их на сервер электронной коммерции. Такой подход громоздок и требует постоянного обслуживания, чтобы гарантировать, что на сервере не заканчиваются ключи, поэтому предпочтение отдается использованию расширенных открытых ключей из HD кошельков.

((("hardware wallets")))Другим распространенным применением этого решения является ((("cold-storage wallets")))((("wallets","cold-storage wallets")))холодные или аппаратные кошельки. В этом случае расширенный закрытый ключ может храниться в аппаратном кошельке, в то время как расширенный открытый ключ может храниться в сети. Пользователь может создавать адреса "получения" по своему желанию, в то время как закрытые ключи надежно хранятся в автономном режиме. Чтобы потратить средства, пользователь может использовать расширенный закрытый ключ в автономном подписывающем клиенте Ethereum или подписывать транзакции на аппаратном устройстве кошелька.

[[hardened_child_key]]
===== Усиленный вывод дочернего ключа

((("child private keys")))((("hardened derivation","for child private keys")))((("hierarchical deterministic wallets (BIP-32/BIP-44)","hardened child key derivation")))((("hierarchical deterministic wallets (BIP-32/BIP-44)","index numbers for normal/hardened derivation")))((("index numbers, for normal/hardened derivation")))((("private keys","hardened child key derivation")))Возможность получения ветви открытых ключей из расширенного открытого ключа, или _xpub_, очень полезна, но сопряжена с потенциальным риском. Доступ к xpub не дает доступа к дочерним закрытым ключам. Однако, поскольку xpub содержит последовательность кода (chain code) (используемый для получения дочерних открытых ключей из родительского открытого ключа), если дочерний закрытый ключ известен или каким-то образом утек, его можно использовать вместе с цепочкой кода для получения всех других дочерних закрытых ключей. Одна утечка дочернего закрытого ключа вместе с chain code родительской цепочки раскрывает все закрытые ключи всех дочерних элементов. Хуже того, дочерний закрытый ключ вместе с родительским chain code может быть использован для вывода родительского закрытого ключа.

Чтобы противостоять этому риску, кошельки HD используют альтернативную функцию деривации, называемую _усиленный вывод_ (_hardened derivation_), которая "разрывает" связь между родительским открытым ключом и дочерним chain code. Функция защищенного вывода использует родительский закрытый ключ для получения дочернего chain code вместо родительского открытого ключа. Это создает "фаервол" в последовательности родитель/потомок, с chain code, который нельзя использовать для компрометации родительского или родственного закрытого ключа.

Проще говоря, если вы хотите использовать удобство xpub для получения ветвей открытых ключей, не подвергая себя риску утечки кода цепочки, вы должны получить его от защищенного (hardened) родителя, а не от обычного родителя. Наилучшая практика заключается в том, чтобы дочерние элементы мастер-ключей уровня 1 всегда производились с помощью защищенной деривации, чтобы предотвратить компрометацию мастер-ключей.

[[index_number]]
===== Индексные номера для нормального и усиленного вывода

((("hardened derivation","index numbers for")))Очевидно, что желательно иметь возможность извлекать более одного дочернего ключа из данного родительского ключа. Для управления этим используется индексный номер. Каждый индексный номер в сочетании с родительским ключом с помощью специальной функции вывода дочерних элементов дает другой дочерний ключ. Номер индексы, используемый в функции вывода BIP-32 от родителя к потомку, представляет собой 32-разрядное целое число. Чтобы легко отличать ключи, полученные с помощью обычной (не усленной) функции деривации, от ключей, полученных с помощью усиленной деривации, этот номер индекса разделен на два диапазона. Индексные числа от 0 до 2^31^&#x2013;1 (от +0x0+ до +0x7FFFFFFF+) используются только для нормального вывода. Индексные числа от 2^31^ до 2^32^&#x2013;1 (от +0x80000000+ до +0xFFFFFFFF+) используются только для усиленного вывода ключей. Следовательно, если номер индекса меньше 2^31^, дочерний элемент является нормальным, тогда как если номер индекса равен или превышает 2^31^, дочерний элемент является усиленным.

Чтобы облегчить чтение и отображение номеров индексов, номера индексов для дочерних элементов отображаются, начиная с нуля, но с простым символом. Таким образом, первый обычный дочерний ключ отображается как +0+, тогда как первый защищенный дочерний ключ (индекс +0x80000000+) отображается как 0&#x27;. Затем последовательно второй защищенный ключ будет иметь индекс +0x80000001+ и будет отображаться как 1&#x27; и так далее. Когда вы видите индекс HD wallet i&#x27;, это означает 2^31^ pass:[+] ++i++.(((range="endofrange", startref="ix_05wallets-asciidoc12")))

[[hd_wallet_path]]
===== Идентификатор ключа HD-кошелька (путь)

((("hierarchical deterministic wallets (BIP-32/BIP-44)","key identifier")))((("keys","path naming convention")))Ключи в HD-кошельке идентифицируются с использованием соглашения об именовании "путь", при этом каждый уровень дерева разделяется символом косой черты (/) (см. <<hd_path_table>>). Закрытые ключи, полученные из главного закрытого ключа, начинаются с +m+. Открытые ключи, полученные из главного открытого ключа, начинаются с +M+. Следовательно, первый дочерний закрытый ключ главного закрытого ключа равен +m/0+. Первый дочерний открытый ключ равен +M/0+. Второму внуку первого ребенка +m/0/1+ , и так далее.

"Родословная" ключа считывается справа налево, пока вы не дойдете до главного ключа, из которого он был получен. Например, идентификатор +m/x/y/z+ описывает ключ, который является ++z++-м дочерним элементом ключа +m/x/y+, который является ++y++-м дочерним элементом ключа +m/x+, который является ++x++-м ребенок +m+.

[[hd_path_table]]
.HD wallet path examples
[options="header"]
|=======
|HD path | Key described
| +m/0+ | The first (+0+) child private key of the master private key (+m+)
| +m/0/0+ | The first grandchild private key of the first child (+m/0+)
| +m/0'/0+ | The first normal grandchild of the first _hardened_ child (+m/0'+)
| +m/1/0+ | The first grandchild private key of the second child (+m/1+)
| +M/23/17/0/0+ | The first great-great-grandchild public key of the first great-grandchild of the 18th grandchild of the pass:[<span class="keep-together">24th child</span>]
|=======

[[navigating_hd_wallet_tree]]
===== Навигация по древовидной структуре HD wallet

((("hierarchical deterministic wallets (BIP-32/BIP-44)","tree structure")))((("tree structure, navigating")))Древовидная структура HD wallet чрезвычайно гибка. Оборотной стороной этого является то, что он также допускает неограниченную сложность: каждый родительский расширенный ключ может иметь 4 миллиарда дочерних элементов: 2 миллиарда обычных дочерних элементов и 2 миллиарда усиленных дочерних элементов. У каждого из этих детей может быть еще 4 миллиарда детей, и так далее. Дерево может быть настолько глубоким, насколько вы хотите, с потенциально бесконечным числом поколений. При всем этом потенциале ориентироваться на этих очень больших деревьях может быть довольно сложно.

Два BIP'а предлагают способ управления этой потенциальной сложностью путем создания стандартов для структуры деревьев HD wallet. ((("BIP-43 standard")))BIP-43 предлагает использовать первый усиленный дочерний индекс в качестве специального идентификатора, который обозначает "назначение" древовидной структуры. Основываясь на BIP-43, HD-кошелек должен использовать только одну ветвь дерева уровня 1, при этом номер индекса определяет назначение кошелька, идентифицируя структуру и пространство имен остальной части дерева. Более конкретно, HD-кошелек, использующий только филиал m/i&#x27;/..., предназначен для обозначения конкретной цели, и эта цель идентифицируется индексом +i+..

((("BIP-44 standard")))Расширяя эту спецификацию, BIP-44 предлагает мультивалютную структуру мультиаккаунтов, обозначаемую установкой номера "цели" на +44'+. Все кошельки HD, следующие структуре BIP-44, идентифицируются тем фактом, что они используют только одну ветвь дерева: +m/44'/*+.

BIP-44 определяет структуру как состоящую из пяти предопределенных уровней дерева:

[[bip44_tree]]
-----
m / цель'(purpose) / тип монет'(coin_type) / аккаунт'(account) / изменение(change) / адресный индекс(address_index)
-----

Первый уровень, purpose&#x27;, всегда устанавливается на 44&#x27;. Второй уровень, coin_type&#x27;, определяет тип криптовалютной монеты, позволяя создавать мультивалютные HD-кошельки, где каждая валюта имеет свое собственное поддерево под вторым уровнем. Существует несколько валют, определенных в документе стандартов, называемом https://github.com/satoshilabs/slips/blob/master/slip-0044.md[SLIP0044]; например, Ethereum равен m/44&#x27;/60&#x27;, Ethereum Classic равен m/44&#x27;/61&#x27;, Биткоин равен m/44&#x27;/0&#x27;, а тестовая сеть для всех валют - m/44&#x27;/1&#x27;.

Третий уровень дерева - account&#x27;, который позволяет пользователям разделять свои кошельки на отдельные логические субсчета для бухгалтерских или организационных целей. Например, HD-кошелек может содержать два "аккаунта" Ethereum: m/44&#x27;/60&#x27;/0&#x27; и m/44&#x27;/60&#x27;/1&#x27;. Каждая учетная запись является корнем своего собственного поддерева.

Поскольку BIP-44 изначально был создан для Биткоина, он содержит "причуду", которая не имеет отношения к миру Ethereum. На четвертом уровне пути, +change+, HD-кошелек имеет два поддерева: одно для создания адресов получения и одно для создания адресов изменения. В Ethereum используется только путь "получения", так как нет необходимости менять адрес, как в биткойне. Обратите внимание, что в то время как на предыдущих уровнях использовалась усиленная деривация, на этом уровне используется обычная деривация. Это делается для того, чтобы позволить уровню дерева для аккаунтов (account&#x27;) экспортировать расширенные открытые ключи для использования в незащищенной среде. Используемые адреса выводятся HD wallet как дочерние элементы четвертого уровня, что делает пятый уровень дерева +address_index+. Например, третьим получающим адресом для платежей Ethereum в основной учетной записи будет M/44&#x27;/60&#x27;/0&#x27;/0/2. <<bip44_path_examples>> показано еще несколько примеров(((range="endofrange", startref="ix_05wallets-asciidoc11")))(((range="endofrange", startref="ix_05wallets-asciidoc10"))).(((range="endofrange", startref="ix_05wallets-asciidoc5")))

[[bip44_path_examples]]
.Примеры структуры HD-кошелька BIP-44
[options="header"]
|=======
|HD путь | Описание ключа
| M/44&#x27;/60&#x27;/0&#x27;/0/2 | Третий получающий открытый ключ для основной учетной записи Ethereum
| M/44&#x27;/0&#x27;/3&#x27;/1/14 | Открытый ключ 15-го изменения адреса для 4-го Биткойн-счета
| m/44&#x27;/2&#x27;/0&#x27;/0/1 | Второй закрытый ключ в основной учетной записи Litecoin для подписания транзакций
|=======

=== Заключение

Кошельки являются основой любого пользовательского блокчейн-приложения. Они позволяют пользователям управлять набором ключей и адресов. Кошельки также позволяют пользователям показывать свое владение эфиром и разрешать транзакции, применяя цифровые подписи, как мы увидим в <<tx_chapter>>.(((range="endofrange", startref="ix_05wallets-asciidoc0")))

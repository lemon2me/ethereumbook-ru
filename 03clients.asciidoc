[[ethereum_clients_chapter]]
== Клиенты Ethereum

((("clients, Ethereum", id="ix_03clients-asciidoc0", range="startofrange")))Клиент Ethereum - это программное приложение, которое реализует спецификацию Ethereum и взаимодействует по одноранговой сети с другими клиентами Ethereum. Различные клиенты Ethereum _взаимодействуют_ (_interoperate_), если они соответствуют эталонной спецификации и стандартизированным протоколам связи. Хотя эти разные клиенты реализуются разными командами и на разных языках программирования, все они "говорят" по одному и тому же протоколу и следуют одним и тем же правилам. Таким образом, все они могут использоваться для работы и взаимодействия с одной и той же сетью Ethereum.

Ethereum - это проект с открытым исходным кодом, и исходный код для всех основных клиентов доступен по лицензиям с открытым исходным кодом (например, LGPL v3.0), который можно бесплатно скачать и использовать для любых целей. Однако _Open source_ означает нечто большее, чем просто бесплатное использование. Это также означает, что Ethereum разрабатывается открытым сообществом добровольцев и может быть изменен кем угодно. Больше глаз означает более надежный код.

((("Yellow Paper specification")))Ethereum определяется формальной спецификацией, называемой "Yellow Paper" (см. <<references>>).

((("Bitcoin","Ethereum definition compared to")))Это отличается, например, от биткойна, который не определен каким-либо формальным образом. Там, где "спецификация" Биткойна является эталонной реализацией Bitcoin Core, спецификация Ethereum задокументирована в документе, который сочетает в себе английскую и математическую (формальную) спецификацию. Эта официальная спецификация, в дополнение к различным предложениям по улучшению Ethereum, определяет стандартное поведение Ethereum pass:[<span class="keep-together">клиена</span>]. Yellow Paper периодически обновляется по мере внесения серьезных изменений вo pass:[<span class="keep-together">Ethereum</span>].

В результате четкой формальной спецификации Ethereum существует ряд независимо разработанных, но совместимых программных реализаций клиента Ethereum. Ethereum имеет большее разнообразие реализаций, работающих в сети, чем любой другой блокчейн, что обычно считается хорошей вещью. Действительно, он, например, зарекомендовал себя как отличный способ защиты от атак в сети, потому что использование стратегии реализации конкретного клиента просто доставляет неудобства разработчикам, пока они исправляют эксплойт, в то время как другие клиенты поддерживают работу сети практически без изменений.

=== Сети Ethereum

((("clients, Ethereum","Ethereum-based networks and", id="ix_03clients-asciidoc1", range="startofrange")))((("networks (Ethereum)","clients and", id="ix_03clients-asciidoc2", range="startofrange")))Существует множество сетей на базе Ethereum, которые в значительной степени соответствуют формальной спецификации, определенной в Yellow Paper Ethereum, но которые могут взаимодействовать, а могут и не взаимодействовать друг с другом.

Среди этих сетей, основанных на Ethereum есть Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin и многие другие. Несмотря на то, что эти сети в основном совместимы на уровне протокола, они часто имеют функции или атрибуты, которые требуют от разработчиков клиентского программного обеспечения Ethereum внесения небольших изменений для поддержки каждой сети. Из-за этого не каждая версия клиентского программного обеспечения Ethereum запускает каждый блокчейн на основе Ethereum.

В настоящее время существует шесть основных реализаций протокола Ethereum, написанных на шести разных языках:

* Parity, написанная на Rust
* Geth, написанная на языке Gо
* +cpp-ethereum+, написанный на Cpass:[++]
* +pyethereum+, написанный на Python
* Mantis, написанный на Scala
* Harmony, написанный на Java

В этом разделе мы рассмотрим два наиболее распространенных клиента - Parity и Geth. Мы покажем, как настроить узел с использованием каждого клиента, и рассмотрим некоторые из их параметров командной строки и интерфейсов прикладного программирования (API).

[[full_node_importance]]
==== Должен ли я запустить Полный узел?

((("full node","Ethereum-based networks and", id="ix_03clients-asciidoc3", range="startofrange")))((("networks (Ethereum)","full nodes and", id="ix_03clients-asciidoc4", range="startofrange")))Работоспособность, отказоустойчивость и устойчивость к цензуре блокчейнов зависят от того, что они имеют множество независимо управляемых и географически распределенных полных узлов. Каждый полный узел может помочь другим новым узлам получить данные блока для начальной загрузки их работы, а также предложить оператору авторитетную и независимую проверку всех транзакций и контрактов.

Однако запуск полного узла потребует затрат на аппаратные ресурсы и пропускную способность. Полный узел может загружать до 300 ГБ данных (по состоянию на март 2021 года, в зависимости от конфигурации клиента) и сохранять их на локальном жестком диске. Эта нагрузка на данные растет довольно быстро каждый день по мере добавления новых транзакций и блоков. Мы обсуждаем эту тему более подробно в разделе <<требования>>.

Полноценный узел, работающий в живой сети _mainnet_, не является необходимым для разработки Ethereum. Вы можете делать почти все, что вам нужно, с узлом _testnet_ (который соединяет вас с одним из небольших публичных тестовых блокчейнов), с локальным частным блокчейном, таким как Ganache, или с облачным клиентом Ethereum, предлагаемым поставщиком услуг, таким как Infura.

У вас также есть возможность запустить _удаленный_ (_remote_) клиент, который не хранит локальную копию блокчейна и не проверяет блоки и транзакции. Эти клиенты предлагают функциональность кошелька и могут создавать и транслировать транзакции. Удаленные клиенты могут использоваться для подключения к существующим сетям, таким как ваш собственный полный узел, общедоступному блокчейну, общедоступной или разрешенной тестовой сети (proof-of-authority) или к частному локальному блокчейну. На практике вы, скорее всего, будете использовать удаленный клиент, такой как MetaMask, Emerald Wallet, pass:[<span class="keep-together">MyEtherWallet</span>], oили My Crypto как удобный способ переключения между всеми различными вариантами узлов.

((("remote clients","wallet compared to")))((("wallets","remote clients compared to")))Термины "удаленный клиент" (remote client) и "кошелек" (wallet) используются взаимозаменяемо, хотя и имеют некоторые различия. Обычно удаленный клиент предлагает API (например, web3.js API) в дополнение к функциональности транзакций кошелька.

((("light/lightweight client")))Не путайте концепцию удаленного кошелька в Ethereum с концепцией легкого клиента (который аналогичен упрощенному клиенту проверки платежей в Биткойне). Клиенты Light проверяют заголовки блоков и используют доказательства Merkle для проверки включения транзакций в блокчейн и определения их последствий, обеспечивая им уровень безопасности, аналогичный полному узлу. И наоборот, удаленные клиенты Ethereum не проверяют заголовки блоков или транзакции. Они полностью доверяют полноценному клиенту, который предоставит им доступ к блокчейну, и, следовательно, теряют значительные гарантии безопасности и анонимности. Вы можете устранить эти проблемы, используя полноценный клиент, который вы запускаете самостоятельно.

[[full_node_adv_disadv]]
==== Преимущества и недостатки полного узла

((("full node","advantages/disadvantages")))Выбор для запуска полного узла помогает в работе сетей, к которым вы его подключаете, но также влечет за собой некоторые незначительные или умеренные затраты для вас. Давайте рассмотрим некоторые преимущества и недостатки.

*Преимущества:*

* Поддерживает отказоустойчивость и устойчивость к цензуре сетей, основанных на Ethereum
* Авторитетно проверяет все транзакции
* Может взаимодействовать с любым контрактом на публичном блокчейне без посредника
* Может напрямую внедрять контракты в публичный блокчейн без посредника
* Может запрашивать (только для чтения) статус блокчейна (учетные записи, контракты и т.д.) в автономном режиме
* Может запрашивать блокчейн, не сообщая третьей стороне информацию, которую вы читаете

*Недостатки:*

* Требует значительных и растущих аппаратных средств и ресурсов полосы пропускания
* Может потребоваться несколько дней для полной синхронизации при первом запуске
* Необходимо поддерживать, обновлять и поддерживать в режиме онлайн, чтобы оставаться синхронизированным(((диапазон ="endofrange", startref="ix_03clients-asciidoc4")))(((диапазон ="endofrange", startref="ix_03clients-asciidoc3")))

[[pub_test_adv_disadv]]
==== Преимущества и недостатки общедоступной тестовой сети (public testnet)

((("networks (Ethereum)","public testnet advantages/disadvantages")))((("public testnets")))((("testnet","public")))Независимо от того, решите вы запустить полный узел или нет, вы, вероятно, захотите запустить общедоступный узел testnet. Давайте рассмотрим некоторые преимущества и недостатки использования общедоступной тестовой сети.

*Преимущества:*

* Узлу тестовой сети требуется синхронизировать и хранить значительно меньше данных по сравнению с основной сетью - около 75 ГБ в зависимости от сети.
* Узел testnet может полностью синхронизироваться за гораздо меньшее время.
* Для развертывания контрактов или совершения транзакций требуется тестовый эфир, который не имеет никакой ценности и может быть приобретен бесплатно из нескольких "кранов".
* Тестовые сети - это публичные блокчейны со многими другими пользователями и контрактами, работающие "вживую".

*Недостатки:*

* Вы не можете использовать "реальные" деньги в тестовой сети; она работает на тестовом эфире. Следовательно, вы не можете протестировать безопасность против реальных противников, поскольку на карту ничего не поставлено.
* Существуют некоторые аспекты публичного блокчейна, которые вы не можете реально протестировать в тестовой сети. Например, плата за транзакцию, хотя и необходима для отправки транзакций, не учитывается в тестовой сети, поскольку gas является бесплатным. Кроме того, тестовые сети не испытывают перегрузки сети, как это иногда происходит в общедоступной основной сети.

[[localtest_adv_dis]]
==== Преимущества и недостатки локальной симуляции блокчейна

((("Ganache","advantages/disadvantages")))((("local blockchain simulation")))((("networks (Ethereum)","local blockchain simulation advantages/disadvantages")))((("private blockchain")))((("single-instance private blockchain")))Для многих целей тестирования лучшим вариантом является запуск частного блокчейна с одним экземпляром. Ganache (ранее называвшийся +testrpc+) - одна из самых популярных локальных симуляций блокчейна, с которой вы можете взаимодействовать без каких-либо других участников. Он разделяет многие преимущества и недостатки общедоступной тестовой сети, но также имеет некоторые отличия.

*Преимущества:*

* Нет синхронизации и почти нет данных на диске; вы добываете первый блок самостоятельно
* Нет необходимости получать тестовый эфир; Ganache инициализируется учетными записями, которые уже содержат эфир для тестирования
* Никаких других пользователей, только вы
* Никаких других контрактов, только те, которые вы развертываете после его запуска, если только вы не используете возможность разветвления существующего узла Ethereum.

*Недостатки:*

* Отсутствие других пользователей означает, что он ведет себя не так, как публичный блокчейн. Нет конкуренции за пространство транзакций или последовательность pass:[<span class="keep-together">транзакций</span>].
* Отсутствие других майнеров, кроме вас, означает, что майнинг более предсказуем; следовательно, вы не можете протестировать некоторые сценарии, которые происходят в общедоступном блокчейне.
* Если вы разветвляете существующий узел Ethereum, он должен быть архивным узлом, чтобы вы могли взаимодействовать с состоянием из блоков, которые могли быть удалены в противном случае

(((range="endofrange", startref="ix_03clients-asciidoc2")))(((range="endofrange", startref="ix_03clients-asciidoc1")))


[[running_client]]
=== Запуск клиента Ethereum

((("clients, Ethereum","running", id="ix_03clients-asciidoc5", range="startofrange")))Если у вас есть время и ресурсы, вы должны попытаться запустить полный узел, даже если только для того, чтобы узнать больше об этом процессе. В этом разделе мы расскажем, как загрузить, скомпилировать и запустить клиенты Ethereum Parity и Geth. Это требует некоторого знакомства с использованием интерфейса командной строки в вашей операционной системе. Стоит установить эти клиенты, независимо от того, решите ли вы запускать их как полные узлы, как узлы тестовой сети или как клиенты для локального частного блокчейна.

[[requirements]]
==== Требования к оборудованию для полного узла

((("clients, Ethereum","full node hardware requirements")))((("full node","hardware requirements")))Прежде чем мы начнем, вы должны убедиться, что у вас есть компьютер с достаточными ресурсами для запуска полного узла Ethereum. Вам потребуется не менее 300 ГБ дискового пространства для хранения полной копии блокчейна Ethereum. Если вы также хотите запустить полный узел в тестовой сети Ethereum, вам потребуется как минимум дополнительные 75 ГБ. Загрузка 375 ГБ данных блокчейна может занять много времени, поэтому рекомендуется использовать быстрое подключение к Интернету.

Синхронизация блокчейна Ethereum требует очень больших затрат на ввод-вывод (I/O). Лучше всего иметь твердотельный накопитель (SSD). Если у вас есть механический жесткий диск (HDD), вам потребуется не менее 8 ГБ оперативной памяти для использования в качестве кэша. В противном случае вы можете обнаружить, что ваша система работает слишком медленно, чтобы поддерживать полную синхронизацию.

*Минимальные требования:*

* Процессор с 2+ ядрами
* Не менее 300 ГБ свободного места для хранения
* Минимум 4 ГБ оперативной памяти с SSD, 8 ГБ+, если у вас HDD
* Интернет-соединение со скоростью 8 Мбит/сек

Это минимальные требования для синхронизации полной (но сокращенной) копии блокчейна на основе Ethereum.

На момент написания кодовая база Parity требует меньших ресурсов, поэтому, если вы работаете с ограниченным оборудованием, вы, вероятно, увидите лучшие результаты при использовании Parity.

Если вы хотите выполнить синхронизацию за разумное время и сохранить все инструменты разработки, библиотеки, клиенты и цепочки блоков, которые мы обсуждаем в этой книге, вам понадобится более производительный компьютер.

*Рекомендуемые технические характеристики:*

* Быстрый процессор с более чем 4 ядрами
* 16 ГБ+ оперативной памяти
* Быстрый твердотельный накопитель со свободным пространством не менее 500 ГБ
* Загрузка интернет-сервиса со скоростью более 25 Мбит/сек

Трудно предсказать, как быстро увеличится размер блокчейна и когда потребуется больше места на диске, поэтому рекомендуется проверить последний размер блокчейна перед началом синхронизации.

[NOTE]
====
Требования к размеру диска, перечисленные здесь, предполагают, что вы будете запускать узел с настройками по умолчанию, где блокчейн "очищен" от старых данных о состоянии. Если вместо этого вы запустите полный "архивный" узел, где все состояние хранится на диске, скорее всего, потребуется более 1 ТБ дискового пространства.
====

Эти ссылки предоставляют актуальные оценки размера блокчейна:

* https://bitinfocharts.com/ethereum/[Ethereum]

* https://bitinfocharts.com/ethereum%20classic/[Ethereum Classic]

[[sw_reqs]]
==== Требования к программному обеспечению для создания и запуска Клиента (узла)

((("clients, Ethereum","software requirements for building/running", id="ix_03clients-asciidoc6", range="startofrange")))В этом разделе рассматривается клиентское программное обеспечение Parity и Geth. Это также предполагает, что вы используете Unix-подобную среду командной строки. В примерах показаны команды и выходные данные в том виде, в каком они отображаются в операционной системе Ubuntu GNU/Linux, работающей под управлением оболочки bash (среда выполнения командной строки).

Как правило, каждый блокчейн будет иметь свою собственную версию Geth, в то время как Parity обеспечивает поддержку нескольких блокчейнов на базе Ethereum (Ethereum, Ethereum Classic, pass:[<span class="keep-together">Ellaism</span>], Expanse, Musicoin) одним и тем же клиентом.

[TIP]
=====
((("$ symbol")))((("command-line interface")))((("shell commands")))((("terminal applications")))Во многих примерах в этой главе мы будем использовать интерфейс командной строки операционной системы (также известный как "оболочка"), доступ к которому осуществляется через "терминальное" приложение. Оболочка отобразит приглашение; вы вводите команду, и оболочка отвечает некоторым текстом и новым приглашением для вашей следующей команды. Приглашение может выглядеть по-разному в вашей системе, но в следующих примерах оно обозначается символом +$+. В примерах, когда вы видите текст после символа +$+, не вводите символ +$+, а введите команду сразу после него (выделена жирным шрифтом), затем нажмите Enter, чтобы выполнить команду. В примерах строки под каждой командой представляют собой ответы операционной системы на эту команду. Когда вы увидите следующий префикс +$+, вы будете знать, что это новая команда, и вам следует повторить процесс.
=====

Прежде чем мы начнем, вам, возможно, потребуется установить некоторое программное обеспечение. Если вы никогда не занимались разработкой программного обеспечения на компьютере, который используете в данный момент, вам, вероятно, потребуется установить некоторые базовые инструменты. Для следующих примеров вам нужно будет установить +git+, систему управления исходным кодом; +golang+, язык программирования Go и стандартные библиотеки; и Rust, язык системного программирования.

((("git")))Git можно установить, следуя инструкциям по адресу https://git-scm.com[].

((("Go", seealso="Geth (Go-Ethereum)")))Go можно установить, следуя инструкциям по адресу https://golang.org[], или https://github.com/golang/go/wiki/Ubuntu[] если вы используете Ubuntu.

[NOTE]
=====
((("Geth (Go-Ethereum)")))Требования к Geth различаются, но если вы придерживаетесь версии Go 1.13 или выше, вы сможете скомпилировать большинство версий Geth. Конечно, вы всегда должны обращаться к документации для выбранного вами варианта Geth.

Версия +golang+, установленная в вашей операционной системе или доступная из системного менеджера пакетов, может быть значительно старше 1.13. Если это так, удалите его и установите последнюю версию с https://golang.org/[].
=====

((("Rust")))Rust можно установить, следуя инструкциям по адресу https://www.rustup.rs/[].

[NOTE]
=====
Для Parity требуется Rust версии 1.27 или выше.
=====

((("Parity","libraries for")))Для Parity также требуются некоторые программные библиотеки, такие как OpenSSL и +libudev+. Чтобы установить их в системе, совместимой с Ubuntu или Debian GNU/Linux, используйте следующюю pass:[<span class="keep-together">команду</span>]:

++++
<pre data-type="programlisting">
$ <strong>sudo apt-get install openssl libssl-dev libudev-dev cmake clang</strong>
</pre>
++++

Для других операционных систем используйте диспетчер пакетов вашей операционной системы или следуйте инструкциям https://github.com/paritytech/parity/wiki/Setup[Вики-инструкции] для установки необходимых библиотек.

Теперь, когда у вас установлены +git+, +golang+, Rust и необходимые библиотеки, давайте приступим к работе!

[[parity]]
==== Parity

((("clients, Ethereum","Parity and")))((("Parity","basics")))Parity - это реализация полноузлового клиента Ethereum и браузера DApp. Он был написан "с нуля" на Rust, языке системного программирования, с целью создания модульного, безопасного и масштабируемого клиента Ethereum. Parity разработан британской компанией Parity Tech и выпущен под лицензией свободного программного обеспечения GPLv3.

[NOTE]
=====
Один из авторов этой книги, доктор Гэвин Вуд, является основателем Parity Tech и написал большую часть Parity client. На долю Parity приходится около 25% установленной клиентской базы Ethereum.
=====

Чтобы установить Parity, вы можете использовать менеджер пакетов Rust +cargo+ или загрузить исходный код с GitHub. Менеджер пакетов также загружает исходный код, так что между этими двумя вариантами нет большой разницы. В следующем разделе мы покажем вам, как самостоятельно загрузить и скомпилировать Parity.

[[install_parity]]
===== Установка Parity

((("Parity","installing")))https://wiki.parity.io/Setup[Parity Wiki] предлагает инструкции по созданию Parity в различных средах и контейнерах. Мы покажем вам, как создать Parity из исходного кода. Это предполагает, что вы уже установили Rust с помощью +rust up+ (см. <<sw_reqs>>).

Во-первых, получите исходный код с GitHub:

++++
<pre data-type="programlisting">
$ <strong>git clone https://github.com/paritytech/parity</strong>
</pre>
++++

Затем перейдите в каталог _parity_ и используйте +cargo+ для сборки исполняемого файла:

++++
<pre data-type="programlisting">
$ <strong>cd parity</strong>
$ <strong>cargo install --path .</strong>
</pre>
++++

Если все пойдет хорошо, вы должны увидеть что-то вроде:

++++
<pre data-type="programlisting">
$ <strong>cargo install --path .</strong>
Installing parity-ethereum v2.7.0 (/root/parity)
Updating crates.io index
Updating git repository `https://github.com/paritytech/rust-ctrlc.git`
Updating git repository `https://github.com/paritytech/app-dirs-rs`   Updating git repository

 [...]

Compiling parity-ethereum v2.7.0 (/root/parity)
Finished release [optimized] target(s) in 10m 16s
Installing /root/.cargo/bin/parity
Installed package `parity-ethereum v2.7.0 (/root/parity)` (executable `parity`)
$
</pre>
++++

Попробуйте запустить +parity+, чтобы проверить, установлена ли она, вызвав опцию +--version+:

++++
<pre data-type="programlisting">
$ <strong>parity --version</strong>
Parity Ethereum Client.
  version Parity-Ethereum/v2.7.0-unstable-b69a33b3a-20200124/x86_64-unknown-linux-gnu/rustc1.40.0
Copyright 2015-2020 Parity Technologies (UK) Ltd.
License GPLv3+: GNU GPL version 3 or later <ulink url="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</ulink>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

By Wood/Paronyan/Kotewicz/Drwięga/Volf/Greeff
   Habermeier/Czaban/Gotchac/Redman/Nikolsky
   Schoedon/Tang/Adolfsson/Silva/Palm/Hirsz et al.
$
</pre>
++++

Отлично! Теперь, когда Parity установлен, вы можете синхронизировать блокчейн и начать работу с некоторыми базовыми параметрами командной строки.

[[go_ethereum_geth]]
==== Go-Ethereum (Geth)

((("clients, Ethereum","Geth and", id="ix_03clients-asciidoc7", range="startofrange")))((("Geth (Go-Ethereum)","basics", id="ix_03clients-asciidoc8", range="startofrange")))Geth - это реализация на языке Go, которая активно разрабатывается Ethereum Foundation, поэтому считается "официальной" реализацией клиента Ethereum. Как правило, каждый блокчейн, основанный на Ethereum, будет иметь свою собственную реализацию Geth. Если вы используете Geth, то вам нужно убедиться, что вы выбрали правильную версию для своего блокчейна, используя одну из следующих ссылок на репозиторий:


* https://github.com/ethereum/go-ethereum[Ethereum] (или https://geth.ethereum.org/)

* https://github.com/etclabscore/go-ethereum[Ethereum Classic]

* https://github.com/ellaism/go-ellaism[Ellaism]

* https://github.com/expanse-org/go-expanse[Expanse]

* https://github.com/Musicoin/go-musicoin[Musicoin]

* https://github.com/ubiq/go-ubiq[Ubiq]

[NOTE]
=====
Вы также можете пропустить эти инструкции и установить предварительно скомпилированный двоичный файл для выбранной вами платформы. Предварительно скомпилированные версии намного проще в установке, и их можно найти в разделе "релизы" любого из перечисленных здесь репозиториев. Однако вы можете узнать больше, самостоятельно загрузив и скомпилировав программное обеспечение.
=====

[[cloning_repo]]
===== Клонирование репозитория

((("Geth (Go-Ethereum)","cloning Git repo for")))Первый шаг - клонировать репозиторий Git, чтобы получить копию исходного кода.

Чтобы создать локальный клон выбранного вами репозитория, используйте команду +git+ следующим образом в вашем домашнем каталоге или в любом каталоге, который вы используете для разработки:

++++
<pre data-type="programlisting">
$ <strong>git clone &lt;Repository Link&gt;</strong>
</pre>
++++

Вы должны увидеть отчет о ходе выполнения по мере копирования хранилища в вашу локальную систему:

[[cloning_status]]
----
Cloning into 'go-ethereum'...
remote: Enumerating objects: 86915, done.
remote: Total 86915 (delta 0), reused 0 (delta 0), pack-reused 86915
Receiving objects: 100% (86915/86915), 134.73 MiB | 29.30 MiB/s, done.
Resolving deltas: 100% (57590/57590), done.
----

Отлично! Теперь, когда у вас есть локальная копия Geth, вы можете скомпилировать исполняемый файл для своей платформы.

[[build_geth_src]]
===== Создание Geth из исходного кода

((("Geth (Go-Ethereum)","building from source code")))Чтобы создать Geth, перейдите в каталог, в который был загружен исходный код, и используйте команду +make+:

++++
<pre data-type="programlisting">
$ <strong>cd go-ethereum</strong>
$ <strong>make geth</strong>
</pre>
++++

Если все пойдет хорошо, вы увидите, как компилятор Go создает каждый компонент до тех пор, пока он не создаст исполняемый файл +geth+:

[[making_geth_status]]
----
build/env.sh go run build/ci.go install ./cmd/geth
>>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=58a1e13e6dd7f52a1d...
github.com/ethereum/go-ethereum/common/hexutil
github.com/ethereum/go-ethereum/common/math
github.com/ethereum/go-ethereum/crypto/sha3
github.com/ethereum/go-ethereum/rlp
github.com/ethereum/go-ethereum/crypto/secp256k1
github.com/ethereum/go-ethereum/common
[...]
github.com/ethereum/go-ethereum/cmd/utils
github.com/ethereum/go-ethereum/cmd/geth
Done building.
Run "build/bin/geth" to launch geth.
$
----

Давайте убедимся, что +geth + работает, фактически не запуская его.:

++++
<pre data-type="programlisting">
$ <strong>./build/bin/geth version</strong>

Geth
Version: 1.9.11-unstable
Git Commit: 0b284f6c6cfc6df452ca23f9454ee16a6330cb8e
Git Commit Date: 20200123
Architecture: amd64
Protocol Versions: [64 63]
Go Version: go1.13.4
Operating System: linux
[...]
</pre>
++++

Ваша команда +geth version+ может отображать несколько иную информацию, но вы должны увидеть отчет о версии, очень похожий на тот, который показан здесь.

В следующих разделах объясняется проблема с первоначальной синхронизацией блокчейна Ethereum(((range="endofrange", startref="ix_03clients-asciidoc6"))).(((range="endofrange", startref="ix_03clients-asciidoc5")))


[[first_sync]]
=== Первая синхронизация блокчейнов на базе Ethereum

((("blockchain","first synchronization of", id="ix_03clients-asciidoc9", range="startofrange")))((("clients, Ethereum","first synchronization of Ethereum-based blockchains", id="ix_03clients-asciidoc10", range="startofrange")))((("first synchronization","of Ethereum-based blockchains", id="ix_03clients-asciidoc11", range="startofrange")))Традиционно при синхронизации блокчейна Ethereum ваш клиент загружал и проверял каждый блок и каждую транзакцию с самого начала &#x2014; т.е. с блока genesis.

Хотя таким образом можно полностью синхронизировать блокчейн, этот тип синхронизации займет очень много времени и требует больших ресурсов (для этого потребуется гораздо больше оперативной памяти и действительно займет очень много времени, если у вас нет быстрого хранилища).

Многие блокчейны на базе Ethereum стали жертвами атак типа "отказ в обслуживании" (DoS) в конце 2016 года. Затронутые блокчейны будут иметь тенденцию к медленной синхронизации при выполнении полной синхронизации.

Например, в Ethereum новый клиент будет быстро прогрессировать, пока не достигнет блока 2,283,397. Этот блок был заминирован 18 сентября 2016 года и знаменует собой начало DoS-атак. Начиная с этого блока и заканчивая блоком 2 700 031 (26 ноября 2016 года) проверка транзакций становится чрезвычайно медленной, требует много памяти и ввода-вывода. Это приводит к тому, что время проверки превышает 1 минуту на блок. Ethereum внедрил серию обновлений с использованием хардфорков для устранения основных уязвимостей, которые были использованы в DoS-атаках. Эти обновления также очистили блокчейн, удалив около 20 миллионов пустых учетных записей, созданных в результате спам-транзакций.

Если вы синхронизируетесь с полной проверкой, ваш клиент будет замедляться, и может потребоваться несколько дней, а возможно, и больше, для проверки блоков, затронутых DoS-атаками.

((("fast synchronization")))К счастью, большинство клиентов Ethereum по умолчанию теперь выполняют "быструю" синхронизацию, которая пропускает полную проверку транзакций до тех пор, пока она не будет синхронизирована с концом блокчейна, а затем возобновляет полную проверку.

Geth выполняет быструю синхронизацию по умолчанию для Ethereum. Возможно, вам потребуется обратиться к конкретным инструкциям для другой выбранной цепочки Ethereum.

Parity также выполняет быструю синхронизацию по умолчанию.

[NOTE]
=====
Geth может выполнять быструю синхронизацию только при запуске с пустой базой данных блоков. Если вы уже начали синхронизацию без быстрого режима, Geth не сможет переключиться. Быстрее удалить каталог данных блокчейна и начать быструю синхронизацию с самого начала, чем продолжать синхронизацию с полной проверкой. Будьте осторожны, чтобы не удалить какие-либо кошельки при удалении данных блокчейна!
=====

==== Запуск Geth или Parity

((("first synchronization","Geth or Parity for")))((("Geth (Go-Ethereum)","for first synchronization")))((("Parity","for first synchronization")))Теперь, когда вы понимаете проблемы "первой синхронизации", вы готовы запустить клиент Ethereum и синхронизировать блокчейн. Как для Geth, так и для Parity вы можете использовать опцию +--help+, чтобы просмотреть все параметры конфигурации. Настройки по умолчанию обычно разумны и подходят для большинства применений. Выберите способ настройки любых дополнительных параметров в соответствии с вашими потребностями, затем запустите Geth или Parity для синхронизации цепочки. Затем ждите...

[TIP]
====
Синхронизация блокчейна Ethereum займет от половины дня в очень быстрой системе с большим объемом оперативной памяти до нескольких дней в более медленной системе.
====

[[json_rpc]]
==== Интерфейс JSON-RPC

((("clients, Ethereum","and JSON-RPC API", id="ix_03clients-asciidoc12", range="startofrange")))((("first synchronization","and JSON-RPC API", id="ix_03clients-asciidoc13", range="startofrange")))((("JSON-RPC API", id="ix_03clients-asciidoc14", range="startofrange")))Клиенты Ethereum предлагают интерфейс прикладного программирования (API) и набор команд удаленного вызова процедур (Remote Procedure Call) (RPC), которые кодируются в виде JSON. Вы увидите, что это называется _JSON-RPC API_. По сути, API JSON-RPC - это интерфейс, который позволяет нам писать программы, использующие клиент Ethereum для _доступа_ (_gateway_) к сети Ethereum и блокчейну.

Обычно интерфейс RPC предлагается как HTTP-сервис на порту 8545. По соображениям безопасности по умолчанию разрешено принимать соединения только с localhost (IP-адрес вашего собственного компьютера, который равен 127.0.0.1).

Чтобы получить доступ к API JSON-RPC, вы можете использовать специализированную библиотеку (написанную на выбранном вами языке программирования), которая предоставляет вызовы функций-заглушек "stub", соответствующие каждой доступной команде RPC, или вы можете вручную создавать HTTP-запросы и отправлять/получать запросы в кодировке JSON. Вы даже можете использовать общий HTTP-клиент командной строки, например +curl+, для вызова интерфейса RPC. Давайте попробуем это сделать. Сначала убедитесь, что у вас запущен Geth, настроенный с помощью --rpc для разрешения HTTP-доступа к интерфейсу RPC, затем переключитесь на новое окно терминала (например, с помощью Ctrl-Shift-N или Ctrl-Shift-T в существующем окне терминала), как показано здесь:

++++
<pre data-type="programlisting">
$ <strong>curl -X POST -H "Content-Type: application/json" --data \
  '{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}' \
  http://localhost:8545</strong>

{"jsonrpc":"2.0","id":1,
"result":"Geth/v1.9.11-unstable-0b284f6c-20200123/linux-amd64/go1.13.4"}
</pre>
++++

В этом примере мы используем +curl+ для установления HTTP-соединения с адресом _http://localhost:8545_. Мы уже запустили +geth+, который предлагает API JSON-RPC в качестве HTTP-сервиса на порту 8545. Мы инструктируем +curl+ использовать команду HTTP +POST+ и идентифицировать содержимое как тип +application/json+. Наконец, мы передаем запрос в кодировке JSON в качестве компонента +data+ нашего HTTP-запроса. Большая часть нашей командной строки - это просто настройка +curl+ для правильного установления HTTP-соединения. Интересная часть - это фактическая команда JSON-RPC, которую мы выдаем:

[[JSON_RPC_command]]
----
{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}
----

Запрос JSON-RPC форматируется в соответствии с https://www.jsonrpc.org/specification[Спецификация JSON-RPC 2.0]. Каждый запрос содержит четыре элемента:

++jsonrpc++:: Версия протокола JSON-RPC. Она должна быть только ++"2.0"++.

++method++:: Имя вызываемого метода.

++params++:: Структурированное значение, содержащее значения параметров, которые будут использоваться во время вызова метода. Этот элемент может быть пропущен.

++id++:: Идентификатор, установленный клиентом, который должен содержать +String+, +Number+ или +NULL+ значение, если оно включено. Сервер должен ответить с тем же значением в объекте ответа, если он включен. Этот элемент используется для сопоставления контекста между двумя объектами.

[TIP]
====
((("batching")))Параметр +id+ используется в основном, когда вы выполняете несколько запросов в одном вызове JSON-RPC, практика называется _batching_. Пакетирование используется, чтобы избежать накладных расходов на новое HTTP- и TCP-соединение для каждого запроса. Например, в контексте Ethereum мы бы использовали пакетную обработку, если бы хотели получить тысячи транзакций по одному HTTP-соединению. При пакетной обработке вы устанавливаете другой +id+ для каждого запроса, а затем сопоставляете его с +id+ в каждом ответе от сервера JSON-RPC. Самый простой способ реализовать это - использовать счетчик для значений +id+ и увеличивать его значение для каждого запроса.
====


Ответ, который мы получаем, таков:

----
{"jsonrpc":"2.0","id":1,
"result":"Geth/v1.9.11-unstable-0b284f6c-20200123/linux-amd64/go1.13.4"}
----

Это говорит нам о том, что API JSON-RPC обслуживается клиентом Geth версии 1.9.11.

Давайте попробуем что-нибудь более интересное. В следующем примере мы запрашиваем у API JSON-RPC текущую цену на газ в wei:

++++
<pre data-type="programlisting">
$ <strong>curl -X POST -H "Content-Type: application/json" --data \
  '{"jsonrpc":"2.0","method":"eth_gasPrice","params":[],"id":4213}' \
  http://localhost:8545</strong>

{"jsonrpc":"2.0","id":4213,"result":"0x430e23400"}
</pre>
++++

Ответ, +0x430e23400+, сообщает нам, что текущая цена на газ составляет 18 гвей (гигавэй или миллиард вей). Если вы, как и мы, не мыслите в шестнадцатеричном формате, вы можете преобразовать его в десятичный в командной строке с помощью небольшого bash-fu:

++++
<pre data-type="programlisting">
$ <strong>echo $((0x430e23400))</strong>

18000000000
</pre>
++++

Полный API JSON-RPC можно изучить на https://github.com/ethereum/wiki/wiki/JSON-RPC[Ethereum wiki].

[[parity_compatibility_mode]]
===== Parity: режим совместимости с Geth

У Parity есть специальный "режим совместимости с Geth", в котором он предлагает API JSON-RPC, идентичный тому, который предлагает Geth. Чтобы запустить Parity в этом режиме, используйте переключатель +--geth+(((range="endofrange", startref="ix_03clients-asciidoc14")))(((range="endofrange", startref="ix_03clients-asciidoc13")))(((range="endofrange", startref="ix_03clients-asciidoc12"))):(((range="endofrange", startref="ix_03clients-asciidoc11")))(((range="endofrange", startref="ix_03clients-asciidoc10")))(((range="endofrange", startref="ix_03clients-asciidoc9")))

++++
<pre data-type="programlisting">
$ <strong>parity --geth</strong>
</pre>
++++

[[lw_eth_clients]]
=== Удаленные (Remote) клиенты Ethereum

((("clients, Ethereum","remote", id="ix_03clients-asciidoc15", range="startofrange")))((("remote clients", id="ix_03clients-asciidoc16", range="startofrange")))Удаленные клиенты предлагают подмножество функциональных возможностей полноценного клиента. Они не хранят полный блокчейн Ethereum, поэтому их быстрее настраивать и они требуют гораздо меньшего объема хранения данных.

[role="pagebreak-before"]
Эти клиенты обычно предоставляют возможность выполнять одного или несколько следующих действий:

* Управление закрытыми ключами и адресами Ethereum в кошельке.
* Создание, подпись и транслирование транзакции.
* Взаимодействие со смарт-контрактами, используя полезную нагрузку данных.
* Просмотр dApps и взаимодействие с ними.
* Ссылки на внешние сервисы, такие как block explorers.
* Конвертацию единицы эфира и извлечение обменных курсов из внешних источников.
* Внедрение экземпляра web3 в веб-браузер в качестве объекта JavaScript.
* Использование экземпляра web3, предоставленного/внедрённого в браузер другим клиентом.
* Доступ к службам RPC на локальном или удаленном узле Ethereum.

Некоторые удаленные клиенты, например мобильные (на смартфоне) кошельки, предлагают только базовую функциональность кошелька. Другие удаленные клиенты - это полноценные браузеры DApp. Удаленные клиенты обычно предлагают некоторые функции полноузлового клиента Ethereum без синхронизации локальной копии блокчейна Ethereum путем подключения к полному узлу, запущенному в другом месте, например, вами локально на вашем компьютере или на веб-сервере, или третьей стороной на своих серверах.

Давайте рассмотрим некоторые из самых популярных удаленных клиентов и функции, которые они предлагают.

[[mobile_wallets]]
==== Мобильные (Смартфонные) Кошельки
Parity
((("mobile (smartphone) wallets")))((("remote clients","mobile wallets")))((("wallets","mobile")))Все мобильные кошельки являются удаленными клиентами, поскольку смартфоны не имеют достаточных ресурсов для запуска полноценного клиента Ethereum. Легкие клиенты находятся в разработке и не используются для общего использования Ethereum. В случае Parity клиент light помечен как "экспериментальный" и может быть использован путем запуска +parity+ с опцией +--light+.

Популярные мобильные кошельки включают в себя следующее (мы приводим их только в качестве примеров; это не является одобрением или указанием на безопасность или функциональность этих кошельков):

https://jaxx.io[Jaxx]:: ((("Jaxx","mobile version")))((("wallets","Jaxx")))Мультивалютный мобильный кошелек, основанный на мнемонической фразе (mnemonic seeds) BIP39, с поддержкой Bitcoin, Litecoin, Ethereum, Ethereum Classic, ZCash, различных токенов ERC20 и многих других валют. Jaxx доступен на Android и iOS, в качестве подключаемого кошелька для браузера и в качестве настольного кошелька для различных операционных систем.

https://status.im[Status]:: ((("Status (mobile wallet)")))Мобильный кошелек и браузер DApp с поддержкой различных токенов и популярных приложений. Доступно для iOS и Android.

https://trustwalletapp.com/[Trust Wallet]:: ((("Trust Wallet")))((("wallets","Trust")))Мобильный мультивалютный кошелек, который поддерживает Ethereum и Ethereum Classic, а также токены ERC20 и ERC223. Trust Wallet доступен для iOS и Android.

https://www.cipherbrowser.com[Cipher Browser]::  ((("Cipher Browser")))Полнофункциональный браузер и кошелек для мобильных приложений с поддержкой Ethereum, который позволяет интегрировать приложения и токены Ethereum. Доступно для iOS и Android.

[[browser_wallets]]
==== Browser Wallets

((("browser wallets")))((("remote clients","browser wallets")))((("wallets","browser wallets")))A variety of wallets and DApp browsers are available as plug-ins or extensions of web browsers such as Chrome and Firefox. These are remote clients that run inside your browser.

Some of the more popular ones are MetaMask, Jaxx, MyEtherWallet, and MyCrypto.

[[MetaMask]]
===== MetaMask

https://metamask.io/[MetaMask], ((("MetaMask","as browser wallet")))introduced in <<intro_chapter>>, is a versatile browser-based wallet, RPC client, and basic contract explorer. It is available on Chrome, Firefox, Opera, and Brave Browser.

Unlike other browser wallets, MetaMask injects a web3 instance into the browser JavaScript context, acting as an RPC client that connects to a variety of Ethereum blockchains (mainnet, Ropsten testnet, Kovan testnet, local RPC node, etc.). The ability to inject a web3 instance and act as a gateway to external RPC services makes MetaMask a very powerful tool for developers and users alike. It can be combined, for example, with MyEtherWallet or MyCrypto, acting as a web3 provider and RPC gateway for those tools.

[[Jaxx]]
===== Jaxx

https://jaxx.io[Jaxx], ((("Jaxx","desktop version")))((("wallets","Jaxx")))which was introduced as a mobile wallet in the previous section, is also available as a Chrome and Firefox extension and as a desktop wallet.

[[MEW]]
===== MyEtherWallet (MEW)

https://www.myetherwallet.com/[MyEtherWallet] ((("MyEtherWallet (MEW)")))((("wallets","MyEtherWallet")))is a browser-based JavaScript remote client that offers:

* A bridge to popular hardware wallets such as the Trezor and Ledger
* A web3 interface that can connect to a web3 instance injected by another client (e.g., MetaMask)
* An RPC client that can connect to an Ethereum full client
* A basic interface that can interact with smart contracts, given a contract's address and application binary interface (ABI)
* A mobile app, MEWConnect, that enables one to use a compatible Android or iOS device to store funds, similarly to a hardware wallet.
* A software wallet running in JavaScript

[WARNING]
====
You must be very careful when accessing MyEtherWallet and other browser-based JavaScript wallets, as they are frequent targets for phishing. Always use a bookmark and not a search engine or link to access the correct web URL.
====

[[MyCrypto]]
===== MyCrypto

((("MyCrypto (wallet)")))((("wallets","MyCrypto")))In early 2018, the ((("MyEtherWallet (MEW)")))((("wallets","MyEtherWallet")))MyEtherWallet project split into two competing implementations, guided by two independent development teams: a "fork," as it is called in open source development. The two projects are called MyEtherWallet (the original branding) and https://mycrypto.com/[MyCrypto]. MyCrypto offers almost identical functionality to MyEtherWallet, but instead of using MEWConnect, it offers a connection to the Parity Signer mobile app. Like MEWConnect, Parity Signer stores keys on the phone and interfaces with MyCrypto in a similar manner as a hardware wallet.

[[Mist]]
===== Mist (Deprecated)

https://github.com/ethereum/mist[Mist] ((("Mist (browser-based wallet)")))((("wallets","Mist")))was the first Ethereum-enabled browser, built by the Ethereum Foundation. It contained a browser-based wallet that was the first implementation of the ERC20 token standard (Fabian Vogelsteller, author of ERC20, was also the main developer of Mist). Mist was also the first wallet to introduce the camelCase checksum (EIP-55). As of March, 2019, Mist was deprecated and should no longer be used.

=== Conclusions

In this chapter we explored Ethereum clients. You downloaded, installed, and synchronized a client, becoming a participant in the Ethereum network, and contributing to the health and stability of the system by replicating the blockchain on your own computer.(((range="endofrange", startref="ix_03clients-asciidoc0")))

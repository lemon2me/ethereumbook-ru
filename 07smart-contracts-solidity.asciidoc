[[smart_contracts_chapter]]
== Смарт-контракты и Solidity

((("smart contracts", id="ix_07smart-contracts-solidity-asciidoc0", range="startofrange")))Как мы обсуждали в <<intro_chapter>>, в Ethereum существует два разных типа учетных записей: ((("EOA (Externally Owned Account)","contract accounts compared to")))аккаунты, принадлежащие лицам (EOA - Externally Owned Account), и аккаунт с контрактами. EOAS контролируются пользователями, часто с помощью программного обеспечения, такого как приложение кошелька, которое является внешним по отношению к платформе Ethereum. ((("contract accounts","EOAs compared to")))((("smart contracts","EOAs compared to")))Напротив, учетные записи с контрактами управляются программным кодом (также обычно называемым "смарт-контрактами"), который выполняется виртуальной машиной Ethereum. Короче говоря, EOAS - это простые учетные записи без какого-либо связанного кода или хранилища данных, в то время как контрактные учетные записи имеют как связанный код, так и хранилище данных. EOAS контролируются транзакциями, созданными и криптографически подписанными закрытым ключом в "реальном мире", внешнем по отношению к протоколу и независимом от него, в то время как контрактные учетные записи не имеют закрытых ключей и поэтому "контролируют себя" заранее определенным образом, предписанным их кодом смарт-контракта. Оба типа учетных записей идентифицируются по адресу Ethereum. В этой главе мы обсудим контрактные учетные записи и программный код, который ими управляет.

[[smart_contracts_definition]]
=== Что такое Смарт-контракт?

((("smart contracts","defined")))Термин _смарт-контракт_ (_smart-contract_) использовался на протяжении многих лет для описания самых разных вещей. ((("contract creation transaction")))((("Szabo, Nick")))В 1990-х годах криптограф Ник Сабо ввел этот термин в обиход и определил его как “набор обещаний, определенных в цифровой форме, включая протоколы, в рамках которых стороны выполняют другие обещания”. С тех пор концепция смарт-контрактов эволюционировала, особенно после внедрения децентрализованных блокчейн-платформ с изобретением Биткоина в 2009 году. В контексте Ethereum этот термин на самом деле немного неправильный, учитывая, что смарт-контракты Ethereum не являются ни интеллектуальными, ни юридическими контрактами, но этот термин прижился. В этой книге мы используем термин “смарт-контракты” для обозначения неизменяемых компьютерных программ, которые выполняются детерминированно в контексте виртуальной машины Ethereum как часть сетевого протокола Ethereum &#x2014; т.е. на децентрализованном всемирном компьютере Ethereum.

Давайте разложим это определение:

Компьютерные программы::
Смарт-контракты - это просто компьютерные программы. Слово "контракт" в данном контексте не имеет юридического значения.

Неизменный::
После развертывания код смарт-контракта не может быть изменен. В отличие от традиционного программного обеспечения, единственный способ изменить смарт-контракт - это развернуть (deploy) новый экземпляр.

Детерминированный::
Результат выполнения смарт-контракта одинаков для всех, кто его запускает, учитывая контекст транзакции, которая инициировала его выполнение, и состояние блокчейна Ethereum на момент исполнения.

Контекст EVM::
Смарт-контракты работают с очень ограниченным контекстом исполнения. Они могут получить доступ к своему собственному состоянию, контексту транзакции, которая их вызвала, и некоторой информации о самых последних блоках.

Децентрализованный мировой компьютер::
EVM работает как локальный экземпляр на каждом узле Ethereum, но поскольку все экземпляры EVM работают в одном и том же начальном состоянии и выдают одно и то же конечное состояние, система в целом работает как единый "мировой компьютер".

[[smart_contract_lifecycle]]
=== Жизненный цикл Смарт-контракта

((("smart contracts","life cycle of")))Смарт-контракты обычно пишутся на языке высокого уровня, таком как Solidity. Но для запуска они должны быть скомпилированы в низкоуровневый байт-код, который выполняется в EVM. После компиляции они развертываются на платформе Ethereum с использованием специальной транзакции _contract creation_, которая идентифицируется как таковая путем отправки на специальный адрес – адрес создания контрактов, а именно +0x0+ (см. <<contract_reg>>). Каждый контракт идентифицируется адресом Ethereum, который является производным от транзакции создания контракта в зависимости от исходной учетной записи и одноразового номера (nonce). Адрес Ethereum контракта может быть использован в транзакции в качестве получателя при отправлении средств или вызывая одну из функций контракта. Обратите внимание, что, в отличие от EOAs, ключей, связанных с учетной записью нового смарт-контракта, нет. Как создатель контракта, вы не получаете никаких особых привилегий на уровне протокола (хотя вы можете явно закодировать их в смарт-контракте). Вы, конечно, не получаете закрытый ключ для учетной записи контракта, которого на самом деле не существует &#x2014; мы можем сказать, что учетные записи смарт-контрактов владеют собой.

((("transactions","smart contracts and")))Важно отметить, что контракты _выполняются только в том случае, если они вызываются транзакцией_. Все смарт-контракты в Ethereum выполняются, в конечном счете, из-за транзакции, инициированной EOA. Контракт может вызывать другой контракт, который может вызывать другой контракт, и так далее, но первый контракт в такой цепочке выполнения всегда будет вызван транзакцией из EOA. Контракты никогда не выполняются “сами по себе” или “в фоновом режиме”. Контракты фактически бездействуют до тех пор, пока транзакция не инициирует выполнение, прямо или косвенно, как часть цепочки вызовов контрактов. Также стоит отметить, что смарт-контракты ни в коем случае не выполняются "параллельно" &#x2014; мировой компьютер Ethereum можно считать однопоточной машиной.

((("transactions","as atomic")))Транзакции являются _атомарными_ (_atomic_), они либо успешно завершаются, либо отменяются. Успешное завершение транзакции означает разные вещи в разных сценариях: (1) если транзакция отправляется из EOA в другой EOA, то записываются любые изменения глобального состояния (например, остатки на счетах), внесенные транзакцией; (2) если транзакция отправляется из EOA в контракт который не вызывает никаких других контрактов, тогда записываются любые изменения глобального состояния (например остатки на счетах, переменные состояния контрактов) (3) если транзакция отправляется из EOA в контракт, который только вызывает другие контракты способом, который распространяет ошибки, тогда записываются любые изменения глобального состояния (например, остатки на счетах, переменные состояния контрактов); и (4) если транзакция отправляется из EOA в контракт, который вызывает другие контракты способом, который не распространяет ошибки, тогда могут быть записаны только некоторые изменения глобального состояния (например остатки на счетах, переменные состояния контрактов без ошибок), в то время как другие изменения глобального состояния не регистрируются (например, переменные состояния контрактов с ошибками). В противном случае, если транзакция отменяется, все ее последствия (изменения состояния) “откатываются”, как если бы транзакция никогда не выполнялась.  Неудачная транзакция по-прежнему регистрируется как попытка, и эфир, потраченный на газ для выполнения, вычитается из исходного счета, но в остальном это не оказывает никакого другого влияния на контракт или состояние счета.

((("smart contracts","deleting")))Как упоминалось ранее, важно помнить, что код контракта не может быть изменен. Однако контракт можно “удалить”, удалив код и его внутреннее состояние (хранилище) из его адреса, оставив пустую учетную запись. Любые транзакции, отправленные на этот адрес учетной записи после удаления контракта, не приводят к выполнению какого-либо кода, поскольку там больше нет никакого кода для выполнения. ((("SELFDESTRUCT opcode")))Чтобы удалить контракт, вы выполняете код операции EVM с именем +SELFDESTRUCT+ (ранее называвшийся +SUICIDE+). ((("negative gas")))Эта операция обходится в “отрицательный газ”, возврат газа, тем самым стимулируя высвобождение ресурсов сетевого клиента из-за удаления сохраненного состояния. Удаление контракта таким образом не приводит к удалению истории транзакций (прошлого) контракта, поскольку сам блокчейн является неизменяемым. Также важно отметить, что возможность +SELFDESTRUCT+ будет доступна только в том случае, если автор контракта запрограммировал смарт-контракт на такую функциональность. Если в коде контракта нет кода операции +SELFDESTRUCT+ или он недоступен, смарт-контракт не может быть удален.

[[high_level_languages]]
=== Введение в языки высокого уровня Ethereum

((("EVM (Ethereum Virtual Machine)","and Ethereum high-level languages", id="ix_07smart-contracts-solidity-asciidoc1", range="startofrange")))((("smart contracts","and Ethereum high-level languages", id="ix_07smart-contracts-solidity-asciidoc2", range="startofrange")))EVM - это виртуальная машина, которая запускает ((("EVM bytecode"))) специальную форму кода, называемую _EVM bytecode_, аналогичную процессору вашего компьютера, который запускает машинный код, такой как x86_64. Мы рассмотрим работу и язык EVM гораздо более подробно в <<evm_chapter>>. В этом разделе мы рассмотрим, как пишутся смарт-контракты для работы на EVM.

В то время как можно программировать смарт-контракты непосредственно в байт-коде, байт-код EVM довольно громоздкий и очень трудный для чтения и понимания программистами. Вместо этого большинство разработчиков Ethereum используют язык высокого уровня для написания программ и компилятор для преобразования их в байт-код.

В то время как любой язык высокого уровня может быть адаптирован для написания смарт-контрактов, адаптация произвольного языка для компиляции в байт-код EVM является довольно громоздким занятием и в целом приведет к некоторой путанице. Смарт-контракты работают в сильно ограниченной и минималистичной среде исполнения (EVM). Кроме того, должен быть доступен специальный набор системных переменных и функций, специфичных для EVM. Таким образом, проще создать язык смарт-контрактов с нуля, чем создать язык общего назначения, подходящий для написания смарт-контрактов. В результате появился ряд языков специального назначения для программирования смарт-контрактов. В Ethereum есть несколько таких языков, а также компиляторы, необходимые для создания EVM-исполняемого байт-кода.

((("declarative programming")))В целом языки программирования можно разделить на две широкие парадигмы программирования: _декларативная_ (_declarative_) и _императивная_ (_imperative_), также известные как _функциональная_ (_functional_) и _процедурная_ (_procedural_) соответственно. В декларативном программировании мы пишем функции, которые выражают _логику_ (_logic_) программы, но не ее _поток выполнения_ (_flow_). ((("side effects")))Декларативное программирование используется для создания программ, в которых нет _сайд-эффектов_ (_side effects_), что означает, что нет никаких изменений состояния вне функции. Декларативные языки программирования включают Haskell и SQL. ((("hybrid programming languages")))((("imperative programming")))Императивное программирование, напротив, - это когда программист пишет набор процедур, которые объединяют логику и поток программы. Императивные языки программирования включают C++ и Java. Некоторые языки являются “гибридными”, что означает, что они поощряют декларативное программирование, но также могут использоваться для выражения императивной парадигмы программирования. Такие гибриды включают Lisp, JavaScript и Python. В общем, любой императивный язык можно использовать для написания в декларативной парадигме, но это часто приводит к неэлегантному коду. Для сравнения, чисто декларативные языки не могут использоваться для написания в императивной парадигме. В чисто декларативных языках _не существует никаких “переменных”_.

В то время как императивное программирование чаще используется программистами, может быть очень трудно писать программы, которые выполняются точно так, как ожидалось. Способность любой части программы изменять состояние любой другой части затрудняет рассуждения о выполнении программы и создает много возможностей для ошибок. Декларативное программирование, для сравнения, облегчает понимание того, как будет вести себя программа: поскольку оно не имеет побочных эффектов, любая часть программы может быть понята изолированно.

В смарт-контрактах ошибки в буквальном смысле стоят денег. В результате критически важно писать смарт-контракты без непреднамеренных последствий. Чтобы сделать это, вы должны быть в состоянии четко рассуждать об ожидаемом поведении программы. Таким образом, декларативные языки играют гораздо большую роль в смарт-контрактах, чем в программном обеспечении общего назначения. Тем не менее, как вы увидите, наиболее широко используемый язык для смарт-контрактов (Solidity) является императивным. Программисты, как и большинство людей, сопротивляются переменам!

Поддерживаемые в настоящее время языки программирования высокого уровня для смарт-контрактов включают в себя (упорядоченные по приблизительному возрасту):

LLL:: ((("LLL"))) Функциональный (декларативный) язык программирования с синтаксисом, подобным Lisp. Это был первый язык высокого уровня для смарт-контрактов Ethereum, но сегодня он редко используется.

Serpent:: ((("Serpent")))Процедурный (императивный) язык программирования с синтаксисом, похожим на Python. Может также использоваться для написания функционального (декларативного) кода, хотя он не полностью свободен от побочных эффектов.

Solidity:: ((("Solidity"))) Процедурный (императивный) язык программирования с синтаксисом, похожим на JavaScript, pass:[C++] или Java. Самый популярный и часто используемый язык для смарт-контрактов Ethereum.

Vyper:: ((("Vyper"))) Более недавно разработанный язык, похожий на Serpent и опять же с синтаксисом, подобным Python. Предназначен для того, чтобы приблизиться к чисто функциональному языку, подобному Python, чем Serpent, но не для замены Serpent.

Bamboo:: ((("Bamboo"))) Недавно разработанный язык, на который повлиял Erlang, с явными переходами состояний и без итеративных потоков (циклов). Предназначен для уменьшения побочных эффектов и повышения проверяемости. Очень новый и еще не получивший широкого распространения.

Как вы можете видеть, есть много языков на выбор. Однако из всех них Solidity, безусловно, является самым популярным, вплоть до того, что фактически является языком высокого уровня Ethereum и даже других блокчейнов, подобных EVM. Мы проведем большую часть нашего времени, используя Solidity, но также рассмотрим некоторые примеры на других языках высокого уровня, чтобы получить представление об их различных философиях.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc2")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc1")))

[[building_a_smart_contract_sec]]
=== Построение Смарт-контракта на Solidity

((("smart contracts","building with Solidity", id="ix_07smart-contracts-solidity-asciidoc3", range="startofrange")))((("Solidity","building a smart contract with", id="ix_07smart-contracts-solidity-asciidoc4", range="startofrange")))Solidity ((("smart contracts","Solidity and", id="ix_07smart-contracts-solidity-asciidoc5", range="startofrange")))((("Solidity","smart contracts and", id="ix_07smart-contracts-solidity-asciidoc6", range="startofrange")))был создан ((("Wood, Dr. Gavin","and Solidity")))доктором Гэвин Вуд (соавтор этой книги) как язык, предназначенный специально для написания смарт-контрактов с функциями, непосредственно поддерживающими выполнение в децентрализованной среде мирового компьютера Ethereum. Результирующие атрибуты являются довольно общими, и поэтому в конечном итоге они используются для кодирования смарт-контрактов на нескольких других блокчейн-платформах. Он был разработан Кристианом Рейтивесснером, а затем также Алексом Берегсаззи, Лианой Хусикян, Йоичи Хираи и несколькими бывшими участниками Ethereum core. Solidity в настоящее время разрабатывается и поддерживается как независимый проект https://github.com/ethereum/solidity[на GitHub].

Основным "продуктом" проекта Solidity является компилятор Solidity +solc+, который преобразует программы, написанные на языке Solidity, в байт-код EVM. Проект также управляет важным стандартом application binary interface (ABI) для смарт-контрактов Ethereum, который мы подробно рассмотрим в этой главе. Каждая версия компилятора Solidity соответствует и компилирует определенную версии Solidity pass:[<span class="keep-together">языка</span>].

Для начала мы загрузим двоичный исполняемый файл компилятора Solidity. Затем мы разработаем и скомпилируем простой контракт, следуя примеру, с которого мы начали в <<intro_chapter>>.

==== Выбор версии Solidity

((("semantic versioning")))((("Solidity","selecting version of")))Solidity следует модели управления версиями, называемой https://semver.org/[_semantic versioning_], которая определяет номера версий, структурированные в виде трех чисел, разделенных точками: __++MAJOR.MINOR.PATCH++__. Число "major" увеличивается для основных изменений и изменений, несовместимых с предыдущими версиями, число "minor" увеличивается по мере добавления обратно совместимых функций между основными выпусками, а число "patch" увеличивается для исправлений ошибок, совместимых с предыдущими версиями.

На момент написания статьи Solidity находится на версии 0.6.4. Правила для основной версии 0, которая предназначена для начальной разработки проекта, отличаются: все может измениться в любое время. На практике Solidity изменяет "minor" номер так, как если бы это была основная версия, а номер "patch" - как если бы это была второстепенная версия. Поэтому в версии 0.6.4 6 считается основной версией (major), а 4 - второстепенной (minor).

В ближайшее время ожидается выпуск основной версии Solidity версии 0.5.

Как вы видели в <<intro_chapter>>, ваши программы Solidity могут содержать директиву pragma, которая определяет минимальную и максимальную версии Solidity, с которыми она совместима, и может использоваться для компиляции вашего контракта.

Поскольку Solidity быстро развивается, часто лучше установить последнюю версию.

==== Загрузка и установка

((("Solidity","downloading/installing")))Существует несколько методов, которые вы можете использовать для загрузки и установки Solidity, либо в виде двоичной версии, либо путем компиляции из исходного кода. Вы можете найти подробные инструкции в http://bit.ly/2RrZmup[документации к Solidity].

Вот как установить последнюю двоичную версию Solidity в операционную систему Ubuntu/Debian, используя менеджер пакетов +apt+:

++++
<pre data-type="programlisting">
$ <strong>sudo add-apt-repository ppa:ethereum/ethereum</strong>
$ <strong>sudo apt update</strong>
$ <strong>sudo apt install solc</strong>
</pre>
++++

После установки +solc+ проверьте версию, запустив:

++++
<pre data-type="programlisting">
$ <strong>solc --version</strong>
solc, the solidity compiler commandline interface
Version: 0.6.4+commit.1dca32f3.Linux.g++
</pre>
++++

Существует ряд других способов установки Solidity, в зависимости от вашей операционной системы и требований, включая компиляцию непосредственно из исходного кода. Для получения дополнительной информации смотрите https://github.com/ethereum/solidity[].



==== Среда разработки

((("Solidity","development environment")))Для разработки в Solidity вы можете использовать любой текстовый редактор и +solc+ в командной строке. Однако вы можете обнаружить, что некоторые текстовые редакторы, предназначенные для разработки, такие как Emacs, Vim и Atom, предлагают дополнительные функции, такие как подсветка синтаксиса и макросы, которые упрощают разработку Solidity.

Существуют также веб-среды разработки, такие как https://remix.ethereum.org/[Remix IDE] и https://ethfiddle.com/[EthFiddle].

Используйте инструменты, которые делают вас продуктивными. В конце концов, программы Solidity - это просто текстовые файлы. В то время как модные редакторы и среды разработки могут упростить задачу, вам не нужно ничего, кроме простого текстового редактора, такого как nano (Linux / Unix), TextEdit (macOS) или даже NotePad (Windows). Просто сохраните исходный код вашей программы с расширением _.sol_, и компилятор Solidity распознает его как программу Solidity.

==== Написание простой программы на Solidity

((("Solidity","writing a simple program in")))В <<intro_chapter>> мы написали нашу первую программу Solidity. Когда мы впервые создали контракт +Faucet+, мы использовали среду разработки Remix IDE для компиляции и развертывания контракта. В этом разделе мы рассмотрим, улучшим и приукрасим +Faucet+.

Наша первая попытка выглядела так <<original_sol_faucet>>.

[[original_sol_faucet]]
.Faucet.sol:  Solidity контракт, реализующий кран
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----
====

==== Компиляция с помощью компилятора Solidity (solc)

((("Faucet.sol contract (test example)","compiling")))((("solc (Solidity compiler)")))((("Solidity compiler (solc)")))Теперь мы будем использовать компилятор Solidity в командной строке для непосредственной компиляции нашего контракта. Компилятор Solidity +solc+ предлагает множество опций, которые вы можете увидеть, передав аргумент +--help+.

Мы используем аргументы +--bin+ и +--optimize+ в +solc+ для создания оптимизированного двоичного файла нашего контракта из примера:


++++
<pre data-type="programlisting">
$ <strong>solc --optimize --bin Faucet.sol</strong>
======= Faucet.sol:Faucet =======
Binary:
608060405234801561001057600080fd5b5060cc8061001f6000396000f3fe6080604052600436106
01f5760003560e01c80632e1a7d4d14602a576025565b36602557005b600080fd5b34801560355760
0080fd5b50605060048036036020811015604a57600080fd5b50356052565b005b67016345785d8a0
000811115606657600080fd5b604051339082156108fc029083906000818181858888f19350505050
1580156092573d6000803e3d6000fd5b505056fea26469706673582212205cf23994b22f7ba19eee5
6c77b5fb127bceec1276b6f76ca71b5f95330ce598564736f6c63430006040033
</pre>
++++


Результат, который выдает +solc+, представляет собой шестнадцатеричный двоичный файл, который может быть отправлен в блокчейн Ethereum.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc6")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc5")))

[[eth_contract_abi_sec]]
=== ABI для контрактов Ethereum

((("ABI (application binary interface)", id="ix_07smart-contracts-solidity-asciidoc7", range="startofrange")))((("application binary interface (ABI)", id="ix_07smart-contracts-solidity-asciidoc8", range="startofrange")))((("smart contracts","ABI", id="ix_07smart-contracts-solidity-asciidoc9", range="startofrange")))В компьютерном программном обеспечении _двоичный интерфейс приложения_ (_application binary interface_) (ABI) - это интерфейс между двумя программными модулями; часто между операционной системой и пользовательскими программами. ABI определяет, как осуществляется доступ к структурам данных и функциям в _машинном коде_ (_machine code_); это не следует путать с API, который определяет этот доступ в высокоуровневых, часто удобочитаемых форматах в _исходном коде_ (_source code_). Таким образом, ABI является основным способом кодирования и декодирования данных в машинный код и из него.

В Ethereum ABI используется для кодирования вызовов контрактов для EVM и считывания данных из транзакций. Цель ABI - определить функции в контракте, которые могут быть вызваны, и описать, как каждая функция будет принимать аргументы и возвращать свой результат.

ABI контракта указывается в виде массива JSON с описанием функций (см. <<solidity_functions>>) и событий (см. <<solidity_events>>). Описание функции представляет собой объект JSON с полями `type`, `name`, `inputs`, `outputs`, `constant` и `payable`. Объект описания события имеет поля `type", "name`, `inputs` и `anonymous`.

Мы используем Solidity компилятор +solc+ в командной строке для создания ABI для нашего pass:[<span class="keep-together"><em>Faucet.sol</em></span>] контракта:

++++
<pre data-type="programlisting">
$ <strong>solc --abi Faucet.sol</strong>
======= Faucet.sol:Faucet =======
Contract JSON ABI
[{"inputs":[{"internalType":"uint256","name":"withdraw_amount","type":"uint256"}], \
"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}, \
{"stateMutability":"payable","type":"receive"}]
</pre>
++++

Как вы можете видеть, компилятор создает массив JSON, описывающий две функции, определенные _Faucet.sol_. Этот JSON может быть использован любым приложением, которое хочет получить доступ к контракту +Faucet+ после его развертывания. Используя ABI, приложение, такое как кошелек или браузер DApp, может создавать транзакции, которые вызывают функции в +Faucet+ с правильными аргументами и типами аргументов. Например, кошелек будет знать, что для вызова функции +withdraw+ он должен предоставить +uint256+ аргумент с именем +withdraw_amount+. Кошелек может предложить пользователю указать это значение, затем создать транзакцию, которая кодирует его и выполняет функцию +withdraw+.

Все, что необходимо для взаимодействия приложения с контрактом, - это ABI и адрес, по которому был развернут контракт.

[[solidity_pragma]]
==== Выбор компилятора Solidity и версии языка

((("Solidity","selecting compiler and language version")))Как мы видели в предыдущем коде, наш контракт +Faucet+ успешно компилируется с Solidity версии 0.6.4. Но что, если бы мы использовали другую версию компилятора Solidity? Язык все еще находится в постоянном движении, и все может измениться самым неожиданным образом. Наш контракт довольно прост, но что, если наша программа использовала функцию, которая была добавлена только в Solidity версии 0.6.1, и мы попытались скомпилировать ее с помощью 0.6.0?

((("compiler directive")))((("version pragma")))Для решения таких проблем Solidity предлагает _команду для компилятора_ (_compiler directive_), известную как _version pragma_, которая сообщает компилятору, что программа ожидает конкретную версию компилятора (и языка). Давайте рассмотрим пример:

[[compiler_version]]
----
pragma solidity ^0.6.0;
----

Компилятор Solidity считывает _version pragma_ и выдает ошибку, если версия компилятора несовместима с _version pragma_. В этом случае наша _version pragma_ говорит, что эта программа может быть скомпилирована компилятором Solidity с минимальной версией 0.6.0. Символ +^+ указывает, однако, что мы разрешаем компиляцию с любым _minor revision_ выше 0.6.0; например, 0.6.1, но не 0.7.0 (что является major версией, а не minor). Директивы "pragma" не компилируются в байт-код EVM. Они используются компилятором только для проверки совместимости.

Давайте добавим директиву pragma в наш контракт +Faucet+. Мы назовем новый файл pass:[<span class="keep-together"><em>Faucet2.sol</em></span>], чтобы отслеживать наши изменения по мере прохождения этих примеров, начиная с <<add_pragma_to_faucet>>.

[[add_pragma_to_faucet]]
.Faucet2.sol: Добавление version pragma в Faucet
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet2.sol[]
----
====

Добавление version pragma является наилучшей практикой, поскольку это позволяет избежать проблем с несовпадением версий компилятора и языка. Мы изучим другие лучшие практики и продолжим совершенствовать контракт +Faucet+ на протяжении всей этой главы.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc9")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc8")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc7")))

=== Programming with Solidity

((("Solidity","programming with", id="ix_07smart-contracts-solidity-asciidoc10", range="startofrange")))In this section, we will look at some of the capabilities of the Solidity language. As we mentioned in <<intro_chapter>>, our first contract example was very simple and also flawed in various ways. We'll gradually improve it here, while exploring how to use Solidity. This won't be a comprehensive Solidity tutorial, however, as Solidity is quite complex and rapidly evolving. We'll cover the basics and give you enough of a foundation to be able to explore the rest on your own. The documentation for Solidity can be found
https://solidity.readthedocs.io/en/latest/[on the project website].

==== Data Types

((("Solidity","data types", id="ix_07smart-contracts-solidity-asciidoc11", range="startofrange")))First, let's look at some of the basic data types offered in Solidity:

Boolean (+bool+):: Boolean value, +true+ or +false+, with logical operators +!+ (not), +&&+ (and), +||+ (or), +==+ (equal), and +!=+ (not equal).

Integer (+int+, +uint+):: Signed (+int+) and unsigned (+uint+) integers, declared in increments of 8 bits from +int8+ to +uint256+. Without a size suffix, 256-bit quantities are used, to match the word size of the EVM.

Fixed point (+fixed+, +ufixed+):: Fixed-point numbers, declared with pass:[(<code>u</code>)<code>fixed<em>M</em>x<em>N</em></code>] where __++M++__ is the size in bits (increments of 8 up to 256) and __++N++__ is the number of decimals after the point (up to 18); e.g., +ufixed32x2+.

Address:: A 20-byte Ethereum address. The +address+ object has many helpful member functions, the main ones being +balance+ (returns the account balance) and pass:[<span class="keep-together"><code>transfer</code></span>] (transfers ether to the account).

Byte array (fixed):: Fixed-size arrays of bytes, declared with +bytes1+ up to +bytes32+.

Byte array (dynamic):: Variable-sized arrays of bytes, declared with +bytes+ or +string+.

Enum:: User-defined type for enumerating discrete values: +enum NAME {LABEL1, LABEL 2, pass:[...]}+.

Arrays:: An array of any type, either fixed or dynamic: +uint32[][5]+ is a fixed-size array of five dynamic arrays of unsigned integers.

Struct:: User-defined data containers for grouping variables: pass:[<code>struct NAME {TYPE1 <span class="keep-together">VARIABLE1</span>; TYPE2 VARIABLE2; ...}</code>].

Mapping:: Hash lookup tables for __++key++__ +=>+ _++value++_ pairs: +mapping(KEY_TYPE => VALUE_TYPE) NAME+.

In addition to these data types, Solidity also offers a variety of value literals that can be used to calculate different units:

Time units:: The units +seconds+, +minutes+, +hours+, and +days+ can be used as suffixes, converting to multiples of the base unit +seconds+.

Ether units:: The units +wei+, +finney+, +szabo+, and +ether+ can be used as suffixes, converting to multiples of the base unit +wei+.

In our +Faucet+ contract example, we used a +uint+ (which is an alias for +uint256+) for the +withdraw_amount+ variable. We also indirectly used an +address+ variable, which we set with +msg.sender+. We will use more of these data types in our examples in the rest of this chapter.

Let's use one of the unit multipliers to improve the readability of our example contract. In the +withdraw+ function we limit the maximum withdrawal, expressing the limit in wei, the base unit of ether:

----
require(withdraw_amount <= 100000000000000000);
----

That's not very easy to read. We can improve our code by using the unit multiplier +ether+, to express the value in ether instead of wei:(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc11")))

----
require(withdraw_amount <= 0.1 ether);
----

==== Predefined Global Variables and Functions

((("Solidity","predefined global variables/functions", id="ix_07smart-contracts-solidity-asciidoc12", range="startofrange")))When a contract is executed in the EVM, it has access to a small set of global objects. These include the +block+, +msg+, and +tx+ objects. In addition, Solidity exposes a number of EVM opcodes as predefined functions. In this section we will examine the variables and functions you can access from within a smart contract in Solidity.

===== Transaction/message call context

((("message call")))((("msg object")))((("transaction call")))The +msg+ object is the transaction call (EOA originated) or message call (contract originated) that launched this contract execution. It contains a number of useful attributes:

+msg.sender+:: We've already used this one. It represents the address that initiated this contract call, not necessarily the originating EOA that sent the transaction. If our contract was called directly by an EOA transaction, then this is the address that signed the transaction, but otherwise it will be a contract address.

+msg.value+:: The value of ether sent with this call (in wei).

+msg.gas+:: The amount of gas left in the gas supply of this execution environment. This was deprecated in Solidity v0.4.21 and replaced by the +gasleft+ function.

+msg.data+:: The data payload of this call into our contract.

+msg.sig+:: The first four bytes of the data payload, which is the function selector.

[NOTE]
====
Whenever a contract calls another contract, the values of all the attributes of +msg+ change to reflect the new caller's information. The only exception to this is the +delegatecall+ function, which runs the code of another contract/library within the original +msg+ pass:[<span class="keep-together">context</span>].
====

===== Transaction context

((("tx object")))The +tx+ object provides a means of accessing transaction-related information:

++tx.gasprice++:: The gas price in the calling transaction.

++tx.origin++:: The address of the originating EOA for this transaction. WARNING: unsafe!

===== Block context

((("block object")))The +block+ object contains information about the current block:

++block.blockhash(__blockNumber__)++:: The block hash of the specified block number, up to 256 blocks in the past. Deprecated and replaced with the +blockhash+ function in Solidity v0.4.22.

++block.coinbase++:: The address of the recipient of the current block's fees and block reward.

++block.difficulty++:: The difficulty (proof of work) of the current block.

++block.gaslimit++:: The maximum amount of gas that can be spent across all transactions included in the current block.

++block.number++:: The current block number (blockchain height).

++block.timestamp++:: The timestamp placed in the current block by the miner (number of seconds since the Unix epoch).

[[solidity_address_object]]
===== address object

((("address object")))Any address, either passed as an input or cast from a contract object, has a number of attributes and methods:

+address.balance+:: The balance of the address, in wei. For example, the current contract balance is +address(this).balance+.

++address.transfer(__amount__)++:: Transfers the amount (in wei) to this address, throwing an exception on any error. We used this function in our +Faucet+ example as a method on the +msg.sender+ address, as +msg.sender.transfer+.

++address.send(__amount__)++:: Similar to +transfer+, only instead of throwing an exception, it returns +false+ on error. WARNING: always check the return value of +send+.

++address.call(__payload__)++:: Low-level +CALL+ function&#x2014;can construct an arbitrary message call with a data payload. Returns +false+ on error. WARNING: unsafe&#x2014;recipient can (accidentally or maliciously) use up all your gas, causing your contract to halt with an +OOG+ exception; always check the return value of +call+.

+address.delegatecall(__payload__)+:: Low-level +DELEGATECALL+ function, like +callcode(pass:[...])+ but with the full +msg+ context seen by the current contract. Returns +false+ on error. WARNING: advanced use only!

===== Built-in functions

Other functions worth noting are:

+addmod+, +mulmod+:: For modulo addition and multiplication. For example, +addmod(x,y,k)+ calculates +pass:[(x + y) % k]+.

+keccak256+, +sha256+, +sha3+, +ripemd160+:: Functions to calculate hashes with various standard hash algorithms.

+ecrecover+:: Recovers the address used to sign a message from the signature.

++selfdestruct(__recipient_address__)++:: Deletes the current contract, sending any remaining ether in the account to the recipient address.

+this+:: The address of the currently executing contract account.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc12")))

==== Contract Definition

((("contract data type")))((("contract definition, Solidity")))((("Solidity","contract definition")))Solidity's principal data type is +contract+; our +Faucet+ example simply defines a pass:[<span class="keep-together"><code>contract</code></span>] object. Similar to any object in an object-oriented language, the contract is a container that includes data and methods.

Solidity offers two other object types that are similar to a contract:

+interface+:: ((("interface object type")))((("stub")))An interface definition is structured exactly like a contract, except none of the functions are defined, they are only declared. This type of declaration is often called a _stub_; it tells you the functions' arguments and return types without any implementation. An interface specifies the "shape" of a contract; when inherited, each of the functions declared by the interface must be defined by the child.

+library+:: ((("library contract")))A library contract is one that is meant to be deployed only once and used by other contracts, using the +delegatecall+ method (see <<solidity_address_object>>).

[[solidity_functions]]
==== Functions

((("Solidity","functions", id="ix_07smart-contracts-solidity-asciidoc13", range="startofrange")))Within a contract, we define functions that can be called by an EOA transaction or another contract. In our +Faucet+ example, we have two functions: +withdraw+ and the (unnamed) _fallback_ function.

((("Solidity","function syntax")))The syntax we use to declare a function in Solidity is as follows:

++++
<pre data-type="programlisting">
function FunctionName([<em>parameters</em>]) {public|private|internal|external}
[pure|view|payable] [<em>modifiers</em>] [returns (<em>return types</em>)]
</pre>
++++


Let's look at each of these components:

++FunctionName++:: The name of the function, which is used to call the function in a transaction (from an EOA), from another contract, or even from within the same contract. ((("fallback function")))One function in each contract may be defined as a fallback function using the "fallback" keyword or a receive ether function defined using the "receive" keyword. If present, the receive ether function is called whenever the call data is empty (whether or not ether is received). Otherwise, the fallback function is called when no other function is named. The fallback function cannot have any arguments or return anything.

__++parameters++__:: Following the name, we specify the arguments that must be passed to the function, with their names and types. In our +Faucet+ example we defined +uint withdraw_amount+ as the only argument to the pass:[<code><span class="keep-together">withdraw</span></code>] function.

The next set of keywords (+public+, +private+, +internal+, +external+) specify the function's _visibility_:

+public+:: ((("public function")))Public is the default; such functions can be called by other contracts or EOA transactions, or from within the contract. In our +Faucet+ example, both functions are defined as public.

+external+:: ((("external function")))External functions are like public functions, except they cannot be called from within the contract unless explicitly prefixed with the keyword +this+.

+internal+:: ((("internal function")))Internal functions are only accessible from within the contract&#x2014;they cannot be called by another contract or EOA transaction. They can be called by derived contracts (those that inherit this one).

+private+:: ((("private function")))Private functions are like internal functions but cannot be called by derived pass:[<span class="keep-together">contracts</span>].

Keep in mind that the terms _internal_ and _private_ are somewhat misleading. Any function or data inside a contract is always _visible_ on the public blockchain, meaning that anyone can see the code or data. The keywords described here only affect how and when a function can be _called_.

The second set of keywords (+pure+, +constant+, +view+, +payable+) affect the behavior of the function:

+constant+ or +view+:: ((("view (function keyword)")))A function marked as a _view_ promises not to modify any state. ((("constant (function keyword)")))The term _constant_ is an alias for view that will be deprecated in a future release. At this time, the compiler does not enforce the +view+ modifier, only producing a warning, but this is expected to become an enforced keyword in v0.5 of Solidity.

+pure+:: ((("pure function")))A pure function is one that neither reads nor writes any variables in storage. It can only operate on arguments and return data, without reference to any stored data. Pure functions are intended to encourage declarative-style programming without side effects or state.

+payable+:: ((("payable function")))A payable function is one that can accept incoming payments. Functions not declared as +payable+ will reject incoming payments. There are two exceptions, due to design decisions in the EVM: coinbase payments and +SELFDESTRUCT+ inheritance will be paid even if the fallback function is not declared as +payable+, but this makes sense because code execution is not part of those payments pass:[<span class="keep-together">anyway</span>].

As you can see in our +Faucet+ example, we have one payable function (the fallback function), which is the only function that can receive incoming payments.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc13")))

==== Contract Constructor and selfdestruct

((("constructor function")))((("smart contracts","constructor function")))((("Solidity","contract constructor function")))There is a special function that is only used once. When a contract is created, it also runs the _constructor function_ if one exists, to initialize the state of the contract. The constructor is run in the same transaction as the contract creation. The constructor function is optional; you'll notice our +Faucet+ example doesn't have one.

Constructors can be specified in two ways. Up to and including in Solidity v0.4.21, the constructor is a function whose name matches the name of the contract, as you can see here:

[source,solidity]
----
contract MEContract {
    function MEContract() {
        // This is the constructor
    }
}
----


The difficulty with this format is that if the contract name is changed and the constructor function name is not changed, it is no longer a constructor. Likewise, if there is an accidental typo in the naming of the contract and/or constructor, the function is again no longer a constructor. This can cause some pretty nasty, unexpected, and difficult-to-find bugs. Imagine for example if the constructor is setting the owner of the contract for purposes of control. If the function is not actually the constructor because of a naming error, not only will the owner be left unset at the time of contract creation, but the function may also be deployed as a permanent and "callable" part of the contract, like a normal function, allowing any third party to hijack the contract and become the "owner" after contract creation.

To address the potential problems with constructor functions being based on having an identical name as the contract, Solidity v0.4.22 introduces a +constructor+ keyword that operates like a constructor function but does not have a name. Renaming the contract does not affect the constructor at all. Also, it is easier to identify which function is the constructor. It looks like this:

[source,solidity]
----
pragma ^0.4.22
contract MEContract {
    constructor () {
        // This is the constructor
    }
}
----

To summarize, a contract's life cycle starts with a creation transaction from an EOA or contract account. If there is a constructor, it is executed as part of contract creation, to initialize the state of the contract as it is being created, and is then discarded.

((("contract destruction")))((("selfdestruct function")))((("Solidity","contract destruction")))((("Solidity","selfdestruct function")))The other end of the contract's life cycle is _contract destruction_. ((("SELFDESTRUCT opcode")))Contracts are destroyed by a special EVM opcode called +SELFDESTRUCT+. It used to be called pass:[<span class="keep-together"><code>SUICIDE</code></span>], but that name was deprecated due to the negative associations of the word. In Solidity, this opcode is exposed as a high-level built-in function called +selfdestruct+, which takes one argument: the address to receive any ether balance remaining in the contract account. It looks like this:

[source,solidity]
----
selfdestruct(address recipient);
----

Note that you must explicitly add this command to your contract if you want it to be deletable&#x2014;this is the only way a contract can be deleted, and it is not present by default. In this way, users of a contract who might rely on a contract being there forever can be certain that a contract can't be deleted if it doesn't contain a pass:[<span class="keep-together"><code>SELFDESTRUCT</code></span>] opcode.

==== Adding a Constructor and selfdestruct to Our Faucet Example

((("constructor function","adding to faucet example")))((("Faucet.sol contract (test example)","adding constructor and selfdestruct to")))((("Solidity","adding constructor/selfdestruct to faucet example")))The +Faucet+ example contract we introduced in <<intro_chapter>> does not have any constructor or +selfdestruct+ functions. It is an eternal contract that cannot be deleted. Let's change that, by adding a constructor and +selfdestruct+ function. We probably want +selfdestruct+ to be callable _only_ by the EOA that originally created the contract. By convention, this is usually stored in an address variable called +owner+. Our constructor sets the +owner+ variable, and the +selfdestruct+ function will first check that the owner called it directly.

First, our constructor:

[source,solidity]
----
// Version of Solidity compiler this program was written for
pragma solidity ^0.6.0;

// Our first contract is a faucet!
contract Faucet {

    address owner;

    // Initialize Faucet contract: set owner
    constructor() {
        owner = msg.sender;
    }

    [...]
}
----

Our contract now has an +address+ type variable named +owner+. The name "owner" is not special in any way. We could call this address variable "potato" and still use it the same way. The name +owner+ simply makes its purpose clear.

Next, our constructor, which runs as part of the contract creation transaction, assigns the address from +msg.sender+ to the +owner+ variable. We used +msg.sender+ in the pass:[<span class="keep-together"><code>withdraw</code></span>] function to identify the initiator of the withdrawal request. In the constructor, however, the +msg.sender+ is the EOA or contract address that initiated contract creation. We know this is the case _because_ this is a constructor function: it only runs once, during contract creation.

Now we can add a function to destroy the contract. We need to make sure that only the owner can run this function, so we will use a +require+ statement to control access. Here's how it will look:

[source,solidity]
----
// Contract destructor
function destroy() public {
    require(msg.sender == owner);
    selfdestruct(owner);
}
----

If anyone calls this +destroy+ function from an address other than +owner+, it will fail. But if the same address stored in +owner+ by the constructor calls it, the contract will self-destruct and send any remaining balance to the +owner+ address. Note that we did not use the unsafe +tx.origin+ to determine whether the owner wished to destroy the contract&#x2014;using +tx.origin+ would allow malign contracts to destroy your contract without your permission.

==== Function Modifiers

((("function modifiers")))((("Solidity","function modifiers")))Solidity offers a special type of function called a _function modifier_. You apply modifiers to functions by adding the modifier name in the function declaration. Modifiers are most often used to create conditions that apply to many functions within a contract. We have an access control statement already, in our +destroy+ function. Let's create a function modifier that expresses that condition:

[source,solidity]
----
modifier onlyOwner {
    require(msg.sender == owner);
    _;
}
----


This function modifier, named +onlyOwner+, sets a condition on any function that it modifies, requiring that the address stored as the +owner+ of the contract is the same as the address of the transaction's +msg.sender+. This is the basic design pattern for access control, allowing only the owner of a contract to execute any function that has the +onlyOwner+ modifier.

You may have noticed that our function modifier has a peculiar syntactic "placeholder" in it, an underscore followed by a semicolon (+&#95;;+). This placeholder is replaced by the code of the function that is being modified. Essentially, the modifier is "wrapped around" the modified function, placing its code in the location identified by the underscore character.

To apply a modifier, you add its name to the function declaration. More than one modifier can be applied to a function; they are applied in the sequence they are declared, as a space-separated list.

Let's rewrite our +destroy+ function to use the +onlyOwner+ modifier:

[source,solidity]
----
function destroy() public onlyOwner {
    selfdestruct(owner);
}
----

The function modifier's name (+onlyOwner+) is after the keyword +public+ and tells us that the +destroy+ function is modified by the +onlyOwner+ modifier. Essentially, you can read this as "Only the owner can destroy this contract." In practice, the resulting code is equivalent to "wrapping" the code from +onlyOwner+ around +destroy+.

Function modifiers are an extremely useful tool because they allow us to write preconditions for functions and apply them consistently, making the code easier to read and, as a result, easier to audit for security. They are most often used for access control, but they are quite versatile and can be used for a variety of other purposes.

Inside a modifier, you can access all the values (variables and arguments) visible to the modified function. In this case, we can access the +owner+ variable, which is declared within the contract. However, the inverse is not true: you cannot access any of the modifier's variables inside the modified function.

==== Contract Inheritance

((("contract object", id="ix_07smart-contracts-solidity-asciidoc14", range="startofrange")))((("inheritance", id="ix_07smart-contracts-solidity-asciidoc15", range="startofrange")))((("smart contracts","inheritance", id="ix_07smart-contracts-solidity-asciidoc16", range="startofrange")))((("Solidity","contract inheritance", id="ix_07smart-contracts-solidity-asciidoc17", range="startofrange")))Solidity's +contract+ object supports _inheritance_, which is a mechanism for extending a base contract with additional functionality. To use inheritance, specify a parent contract with the keyword +is+:

[source,solidity]
----
contract Child is Parent {
    ...
}
----

With this construct, the +Child+ contract inherits all the methods, functionality, and variables of +Parent+. Solidity also supports multiple inheritance, which can be specified by comma-separated contract names after the keyword +is+:

[source,solidity]
----
contract Child is Parent1, Parent2 {
    ...
}
----

Contract inheritance allows us to write our contracts in such a way as to achieve modularity, extensibility, and reuse. We start with contracts that are simple and implement the most generic capabilities, then extend them by inheriting those capabilities in more specialized contracts.

In our +Faucet+ contract, we introduced the constructor and destructor, together with access control for an owner, assigned on construction. Those capabilities are quite generic: many contracts will have them. We can define them as generic contracts, then use inheritance to extend them to the +Faucet+ contract.

We start by defining a base contract +Owned+, which has an +owner+ variable, setting it in the contract's constructor:

[source,solidity]
----
contract Owned {
	address owner;

	// Contract constructor: set owner
	constructor() {
		owner = msg.sender;
	}

	// Access control modifier
	modifier onlyOwner {
	    require(msg.sender == owner);
	    _;
	}
}
----

Next, we define a base contract +Mortal+, which inherits +Owned+:

[source,solidity]
----
contract Mortal is Owned {
	// Contract destructor
	function destroy() public onlyOwner {
		selfdestruct(owner);
	}
}
----

As you can see, the +Mortal+ contract can use the +onlyOwner+ function modifier, defined in +Owned+. It indirectly also uses the +owner+ address variable and the constructor defined in +Owned+. Inheritance makes each contract simpler and focused on its specific functionality, allowing us to manage the details in a modular way.

Now we can further extend the +Owned+ contract, inheriting its capabilities in +Faucet+:

[source,solidity]
----
contract Faucet is Mortal {
    // Give out ether to anyone who asks
    function withdraw(uint withdraw_amount) public {
        // Limit withdrawal amount
        require(withdraw_amount <= 0.1 ether);
        // Send the amount to the address that requested it
        msg.sender.transfer(withdraw_amount);
    }
    // Accept any incoming amount
    receive () external payable {}
}
----

By inheriting +Mortal+, which in turn inherits +Owned+, the +Faucet+ contract now has the constructor and +destroy+ functions, and a defined owner. The functionality is the same as when those functions were within +Faucet+, but now we can reuse those functions in other contracts without writing them again. Code reuse and modularity make our code cleaner, easier to read, and easier to audit.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc17")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc16")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc15")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc14")))

==== Error Handling (assert, require, revert)

((("error handling, Solidity")))((("Solidity","error handling")))A contract call can terminate and return an error. Error handling in Solidity is handled by four functions: +assert+, +require+, +revert+, and +throw+ (now deprecated).

When a contract terminates with an error, all the state changes (changes to variables, balances, etc.) are reverted, all the way up the chain of contract calls if more than one contract was called. This ensures that transactions are _atomic_, meaning they either complete successfully or have no effect on state and are reverted entirely.

((("assert function","Solidity and")))((("require function")))The +assert+ and +require+ functions operate in the same way, evaluating a condition and stopping execution with an error if the condition is false. By convention, +assert+ is used when the outcome is expected to be true, meaning that we use +assert+ to test internal conditions. By comparison, +require+ is used when testing inputs (such as function arguments or transaction fields), setting our expectations for those pass:[<span class="keep-together">conditions</span>].

We've used +require+ in our function modifier +onlyOwner+, to test that the message sender is the owner of the contract:

[source,solidity]
----
require(msg.sender == owner);
----

The +require+ function acts as a _gate condition_, preventing execution of the rest of the function and producing an error if it is not satisfied.

As of Solidity v0.6.0, +require+ can also include a helpful text message that can be used to show the reason for the error. The error message is recorded in the transaction log. So, we can improve our code by adding an error message in our +require+ function:

[source,solidity]
----
require(msg.sender == owner, "Only the contract owner can call this function");
----

((("revert function")))((("throw function")))The +revert+ and +throw+ functions halt the execution of the contract and revert any state changes. The +throw+ function is obsolete and will be removed in future versions of Solidity; you should use +revert+ instead. The +revert+ function can also take an error message as the only argument, which is recorded in the transaction log.

Certain conditions in a contract will generate errors regardless of whether we explicitly check for them. For example, in our +Faucet+ contract, we don't check whether there is enough ether to satisfy a withdrawal request. That's because the +transfer+ function will fail with an error and revert the transaction if there is insufficient balance to make the transfer:

[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

However, it might be better to check explicitly and provide a clear error message on failure. We can do that by adding a +require+ statement before the transfer:

[source,solidity]
----
require(this.balance >= withdraw_amount,
        "Insufficient balance in faucet for withdrawal request");
msg.sender.transfer(withdraw_amount);
----

Additional error-checking code like this will increase gas consumption slightly, but it offers better error reporting than if omitted. You will need to find the right balance between gas consumption and verbose error checking based on the expected use of your contract. In the case of a +Faucet+ contract intended for a testnet, we'd probably err on the side of extra reporting even if it costs more gas. Perhaps for a mainnet contract we'd choose to be frugal with our gas usage instead.

[[solidity_events]]
==== Events

((("events","Solidity", id="ix_07smart-contracts-solidity-asciidoc18", range="startofrange")))((("Solidity","event objects", id="ix_07smart-contracts-solidity-asciidoc19", range="startofrange")))When ((("transaction receipt")))a transaction completes (successfully or not), it produces a _transaction receipt_, as we will see in <<evm_chapter>>. The transaction receipt contains _log_ entries that provide information about the actions that occurred during the execution of the transaction. _Events_ are the Solidity high-level objects that are used to construct these logs.

Events are especially useful for light clients and DApp services, which can "watch" for specific events and report them to the user interface, or make a change in the state of the application to reflect an event in an underlying contract.

Event objects take arguments that are serialized and recorded in the transaction logs, in the blockchain. You can supply the keyword +indexed+ before an argument, to make the value part of an indexed table (hash table) that can be searched or filtered by an application.

((("Faucet.sol contract (test example)","adding events to", id="ix_07smart-contracts-solidity-asciidoc20", range="startofrange")))We have not added any events in our +Faucet+ example so far, so let's do that. We will add two events, one to log any withdrawals and one to log any deposits. We will call these events +Withdrawal+ and +Deposit+, respectively. First, we define the events in the +Faucet+ contract:

[source,solidity]
----
contract Faucet is Mortal {
	event Withdrawal(address indexed to, uint amount);
	event Deposit(address indexed from, uint amount);

    [...]
}
----

We've chosen to make the addresses +indexed+, to allow searching and filtering in any user interface built to access our +Faucet+.

Next, we use the +emit+ keyword to incorporate the event data in the transaction logs:

[source,solidity]
----
// Give out ether to anyone who asks
function withdraw(uint withdraw_amount) public {
    [...]
    msg.sender.transfer(withdraw_amount);
    emit Withdrawal(msg.sender, withdraw_amount);
}
// Accept any incoming amount
receive () external payable {
    emit Deposit(msg.sender, msg.value);
}
----

The resulting _Faucet.sol_ contract looks like <<Faucet8_sol>>.

[[Faucet8_sol]]
.Faucet8.sol: Revised Faucet contract, with events
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet8.sol[]
----
====

===== Catching events

((("events","catching")))((("Faucet.sol contract (test example)","catching events")))OK, so we've set up our contract to emit events. How do we see the results of a transaction and "catch" the events? The web3.js library provides a data structure that contains a transaction's logs. Within those we can see the events generated by the transaction.

((("Truffle","running test transaction with")))Let's use +truffle+ to run a test transaction on the revised +Faucet+ contract. Follow the instructions in <<truffle>> to set up a project directory and compile the pass:[<span class="keep-together"><code>Faucet</code></span>] code. The source code can be found in https://github.com/ethereumbook/ethereumbook[the book's GitHub repository] under _code/truffle/FaucetEvents_.

++++
<pre data-type="programlisting">
$ <strong>truffle develop</strong>
truffle(develop)> <strong>compile</strong>
truffle(develop)> <strong>migrate</strong>
Using network 'develop'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb77ceae7c3f5afb7fbe3a6c5974d352aa844f53f955ee7d707ef6f3f8e6b4e61
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying Faucet...
  ... 0xfa850d754314c3fb83f43ca1fa6ee20bc9652d891c00a2f63fd43ab5bfb0d781
  Faucet: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...

truffle(develop)> <strong>Faucet.deployed().then(i => {FaucetDeployed = i})</strong>
truffle(develop)> <strong>FaucetDeployed.send(web3.utils.toWei(1, "ether")).then(res => \
                  { console.log(res.logs[0].event, res.logs[0].args) })</strong>
Deposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }
truffle(develop)> <strong>FaucetDeployed.withdraw(web3.utils.toWei(0.1, "ether")).then(res => \
                  { console.log(res.logs[0].event, res.logs[0].args) })</strong>
Withdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }
</pre>
++++

After deploying the contract using the +deployed+ function, we execute two transactions. The first transaction is a deposit (using +send+), which emits a +Deposit+ event in the transaction logs:

----
Deposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }
----

Next, we use the +withdraw+ function to make a withdrawal. This emits a +Withdrawal+ event:

----
Withdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }
----

To get these events, we looked at the +logs+ array returned as a result (+res+) of the transactions. The first log entry (+logs[0]+) contains an event name in +logs[0].event+ and the event arguments in +logs[0].args+. By showing these on the console, we can see the emitted event name and the event arguments.

Events are a very useful mechanism, not only for intra-contract communication, but also for debugging during development(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc20"))).(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc19")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc18")))

==== Calling Other Contracts (send, call, callcode, delegatecall)

((("smart contracts","calling other contracts from within a contract", id="ix_07smart-contracts-solidity-asciidoc21", range="startofrange")))((("Solidity","calling other contracts from within a contract", id="ix_07smart-contracts-solidity-asciidoc22", range="startofrange")))Calling other contracts from within your contract is a very useful but potentially dangerous operation. We'll examine the various ways you can achieve this and evaluate the risks of each method. In short, the risks arise from the fact that you may not know much about a contract you are calling into or that is calling into your contract. When writing smart contracts, you must keep in mind that while you may mostly expect to be dealing with EOAs, there is nothing to stop arbitrarily complex and perhaps malign contracts from calling into and being called by your code.

===== Creating a new instance

((("smart contracts","creating new instance")))The safest way to call another contract is if you create that other contract yourself. That way, you are certain of its interfaces and behavior. To do this, you can simply instantiate it, using the keyword +new+, as in other object-oriented languages. In Solidity, the keyword +new+ will create the contract on the blockchain and return an object that you can use to reference it. Let's say you want to create and call a +Faucet+ contract from within another contract called +Token+:

[role="pagebreak-before"]
[source,solidity]
----
contract Token is Mortal {
	Faucet _faucet;

    constructor() {
        _faucet = new Faucet();
    }
}
----

This mechanism for contract construction ensures that you know the exact type of the contract and its interface. The contract +Faucet+ must be defined within the scope of +Token+, which you can do with an +import+ statement if the definition is in another file:

[source,solidity]
----
import "Faucet.sol";

contract Token is Mortal {
	Faucet _faucet;

    constructor() {
        _faucet = new Faucet();
    }
}
----

You can optionally specify the +value+ of ether transfer on creation, and pass arguments to the new contract's constructor:

[source,solidity]
----
import "Faucet.sol";

contract Token is Mortal {
	Faucet _faucet;

    constructor() {
        _faucet = (new Faucet).value(0.5 ether)();
    }
}
----

You can also then call the +Faucet+ functions. In this example, we call the +destroy+ function of +Faucet+ from within the +destroy+ function of +Token+:

[source,solidity]
----
import "Faucet.sol";

contract Token is Mortal {
	Faucet _faucet;

    constructor() {
        _faucet = (new Faucet).value(0.5 ether)();
    }

    function destroy() ownerOnly {
        _faucet.destroy();
    }
}
----

Note that while you are the owner of the +Token+ contract, the +Token+ contract itself owns the new +Faucet+ contract, so only the +Token+ contract can destroy it.

===== Addressing an existing instance

((("smart contracts","addressing an existing instance")))Another way you can call a contract is by casting the address of an existing instance of the contract. With this method, you apply a known interface to an existing instance. It is therefore critically important that you know, for sure, that the instance you are addressing is in fact of the type you assume. Let's look at an example:

[source,solidity]
----
import "Faucet.sol";

contract Token is Mortal {

    Faucet _faucet;

    constructor(address _f) {
        _faucet = Faucet(_f);
        _faucet.withdraw(0.1 ether);
    }
}
----

Here, we take an address provided as an argument to the constructor, +_f+, and we cast it to a +Faucet+ object. This is much riskier than the previous mechanism, because we don't know for sure whether that address actually is a +Faucet+ object. When we call +withdraw+, we are assuming that it accepts the same arguments and executes the same code as our +Faucet+ declaration, but we can't be sure. For all we know, the +withdraw+ function at this address could execute something completely different from what we expect, even if it is named the same. Using addresses passed as input and casting them into specific objects is therefore much more dangerous than creating the contract yourself.

===== Raw call, delegatecall

Solidity offers some even more "low-level" functions for calling other contracts. These correspond directly to EVM opcodes of the same name and allow us to construct a contract-to-contract call manually. As such, they represent the most flexible _and_ the most dangerous mechanisms for calling other contracts.

((("smart contracts","call method", id="ix_07smart-contracts-solidity-asciidoc23", range="startofrange")))Here's the same example, using a +call+ method:

[source,solidity]
----
contract Token is Mortal {
	constructor(address _faucet) {
		_faucet.call("withdraw", 0.1 ether);
	}
}
----

((("blind calls")))As you can see, this type of +call+ is a _blind_ call into a function, very much like constructing a raw transaction, only from within a contract's context. ((("reentrancy attacks","blind calls and")))It can expose your contract to a number of security risks, most importantly _reentrancy_, which we will discuss in more detail in <<reentrancy_security>>. The +call+ function will return +false+ if there is a problem, so you can evaluate the return value for error handling:

[source,solidity]
----
contract Token is Mortal {
	constructor(address _faucet) {
		if !(_faucet.call("withdraw", 0.1 ether)) {
			revert("Withdrawal from faucet failed");
		}
	}
}
----

((("delegatecall method")))((("smart contracts","delegatecall method")))Another variant of +call+ is +delegatecall+, which replaced the more dangerous +callcode+. The pass:[<code><span class="keep-together">callcode</span></code>] method will be deprecated soon, so it should not be used.

As mentioned in <<solidity_address_object>>, a +delegatecall+ is different from a +call+ in that the +msg+ context does not change. For example, whereas a +call+ changes the value of +msg.sender+ to be the calling contract, a +delegatecall+ keeps the same +msg.sender+ as in the calling contract. Essentially, +delegatecall+ runs the code of another contract inside the context of the execution of the current contract. It is most often used to invoke code from a library. It also allows you to draw on the pattern of using library functions stored elsewhere, but have that code work with the storage data of your contract.

The +delegate+ call should be used with great caution. It can have some unexpected effects, especially if the contract you call was not designed as a library.

Let's use an example contract to demonstrate the various call semantics used by +call+ and +delegatecall+ for calling libraries and contracts. In <<call_examples_code>>, we use an event to log the details of each call and see how the calling context changes depending on the call type.

[[call_examples_code]]
.CallExamples.sol: An example of different call semantics
====
[source,solidity,linenums]
----
include::code/truffle/CallExamples/contracts/CallExamples.sol[]
----
====

As you can see in this example, our main contract is +caller+, which calls a library +calledLibrary+ and a contract +calledContract+. Both the called library and the contract have identical +calledFunction+ functions, which emit an event +callEvent+. The event +callEvent+ logs three pieces of data: +msg.sender+, +tx.origin+, and +this+. Each time +calledFunction+ is called it may have a different execution context (with different values for potentially all the context variables), depending on whether it is called directly or through +delegatecall+.

In +caller+, we first call the contract and library directly, by invoking +calledFunction+ in each. Then, we explicitly use the low-level functions +call+ and +delegatecall+ to call +calledContract.calledFunction+. This way we can see how the various calling mechanisms behave.

Let's run this in a Truffle development environment and capture the events, to see how it looks:

++++
<pre data-type="programlisting">
truffle(develop)> <strong>migrate</strong>
Using network 'develop'.
[...]
Saving artifacts...
truffle(develop)> <strong>(await web3.eth.getAccounts())[0]</strong>
'0x627306090abab3a6e1400e9345bc60c78a8bef57'
truffle(develop)> <strong>caller.address</strong>
'0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f'
truffle(develop)> <strong>calledContract.address</strong>
'0x345ca3e014aaf5dca488057592ee47305d9b3e10'
truffle(develop)> <strong>calledLibrary.address</strong>
'0xf25186b5081ff5ce73482ad761db0eb0d25abfbf'
truffle(develop)> <strong>caller.deployed().then( i => { callerDeployed = i })</strong>

truffle(develop)> <strong>callerDeployed.make_calls(calledContract.address).then(res => \
                  { res.logs.forEach( log => { console.log(log.args) })})</strong>
{ sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10' }
{ sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f' }
{ sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10' }
{ sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f' }
</pre>
++++

Let's see what happened here. We called the +make_calls+ function and passed the address of +calledContract+, then caught the four events emitted by each of the different calls. Let's look at the +make_calls+ function and walk through each step.

The first call is:

----
_calledContract.calledFunction();
----

Here, we're calling +calledContract.calledFunction+ directly, using the high-level ABI for +calledFunction+. The event emitted is:

----
sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10'
----

As you can see, +msg.sender+ is the address of the +caller+ contract. The +tx.origin+ is the address of our account, +web3.eth.accounts[0]+, that sent the transaction to +caller+. The event was emitted by +calledContract+, as we can see from the last argument in the event.

The next call in +make_calls+ is to the library:

----
calledLibrary.calledFunction();
----

It looks identical to how we called the contract, but behaves very differently. Let's look at the second event emitted:

----
sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f'
----

This time, the +msg.sender+ is not the address of +caller+. Instead, it is the address of our account, and is the same as the transaction origin. That's because when you call a library, the call is always +delegatecall+ and runs within the context of the caller. So, when the +calledLibrary+ code was running, it inherited the execution context of +caller+, as if its code was running inside +caller+. The variable +this+ (shown as +from+ in the event emitted) is the address of +caller+, even though it is accessed from within pass:[<span class="keep-together"><code>calledLibrary</code></span>].

The next two calls, using the low-level +call+ and +delegatecall+, verify our expectations, emitting events that mirror what we just(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc23"))) saw(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc22")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc21"))).(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc10")))

[[gas_sec]]
=== Gas Considerations

((("gas","conserving", id="ix_07smart-contracts-solidity-asciidoc24", range="startofrange")))((("smart contracts","gas considerations", id="ix_07smart-contracts-solidity-asciidoc25", range="startofrange")))((("Solidity","gas considerations", id="ix_07smart-contracts-solidity-asciidoc26", range="startofrange")))Gas, described in more detail in <<gas>>, is an incredibly important consideration in smart contract programming. Gas is a resource constraining the maximum amount of computation that Ethereum will allow a transaction to consume. If the gas limit is exceeded during computation, the following series of events occurs:

* An "out of gas" exception is thrown.
* The state of the contract prior to execution is restored (reverted).
* All ether used to pay for the gas is taken as a transaction fee; it is _not_ refunded.

Because gas is paid by the user who initiates the transaction, users are discouraged from calling functions that have a high gas cost. It is thus in the programmer's best interest to minimize the gas cost of a contract's functions. To this end, there are certain practices that are recommended when constructing smart contracts, so as to minimize the gas cost of a function call.

==== Avoid Dynamically Sized Arrays

((("dynamically sized arrays")))((("gas","dynamically sized arrays and")))Any loop through a dynamically sized array where a function performs operations on each element or searches for a particular element introduces the risk of using too much gas. Indeed, the contract may run out of gas before finding the desired result, or before acting on every element, thus wasting time and ether without giving any result at all.

==== Avoid Calls to Other Contracts

((("gas","avoiding calls to other contracts")))Calling other contracts, especially when the gas cost of their functions is not known, introduces the risk of running out of gas. Avoid using libraries that are not well tested and broadly used. The less scrutiny a library has received from other programmers, the greater the risk of using it.

==== Estimating Gas Cost

((("gas","estimating cost of", id="ix_07smart-contracts-solidity-asciidoc27", range="startofrange")))If you need to estimate the gas necessary to execute a certain method of a contract considering its arguments, you could use the following procedure:

[source, javascript]
var contract = web3.eth.contract(abi).at(address);
var gasEstimate = contract.myAweSomeMethod.estimateGas(arg1, arg2,
    {from: account});

+gasEstimate+ will tell you the number of gas units needed for its execution. It is an estimate because of the Turing completeness of the EVM&#x2014;it is relatively trivial to create a function that will take vastly different amounts of gas to execute different calls. Even production code can change execution paths in subtle ways, resulting in hugely different gas costs from one call to the next. However, most functions are sensible and +estimateGas+ will give a good estimate most of the time.

To obtain the gas price from the network you can use:

[source, javascript]
var gasPrice = web3.eth.getGasPrice();

And from there you can estimate the gas cost:

[source, javascript]
var gasCostInEther = web3.utils.fromWei((gasEstimate * gasPrice), 'ether');

Let's apply our gas estimation functions to estimating the gas cost of our +Faucet+ example, using the code http://bit.ly/2zf0SIO[from the book's repository].

Start Truffle in development mode and execute the JavaScript file in <<estimateGas_function>>, _gas_estimates.js_.

[source, javascript]
[[estimateGas_function]]
.gas_estimates.js: Using the estimateGas function
====
[source,javascript]
----
var FaucetContract = artifacts.require("./Faucet.sol");

FaucetContract.web3.eth.getGasPrice(function(error, result) {
    var gasPrice = Number(result);
    console.log("Gas Price is " + gasPrice + " wei"); // "10000000000000"

    // Get the contract instance
    FaucetContract.deployed().then(function(FaucetContractInstance) {

		// Use the keyword 'estimateGas' after the function name to get the gas
		// estimation for this particular function (aprove)
		FaucetContractInstance.send(web3.utils.toWei(1, "ether"));
        return FaucetContractInstance.withdraw.estimateGas(web3.utils.toWei(0.1, "ether"));

    }).then(function(result) {
        var gas = Number(result);

        console.log("gas estimation = " + gas + " units");
        console.log("gas cost estimation = " + (gas * gasPrice) + " wei");
        console.log("gas cost estimation = " +
                FaucetContract.web3.utils.fromWei((gas * gasPrice), 'ether') + " ether");
    });
});
----
====

Here's how that looks in the Truffle development console:

++++
<pre data-type="programlisting">
$ <strong>truffle develop</strong>

truffle(develop)> <strong>exec gas_estimates.js</strong>
Using network 'develop'.

Gas Price is 20000000000 wei
gas estimation = 31397 units
gas cost estimation = 627940000000000 wei
gas cost estimation = 0.00062794 ether
</pre>
++++

It is recommended that you evaluate the gas cost of functions as part of your development workflow, to avoid any surprises when deploying contracts to the mainnet(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc27"))).(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc26")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc25")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc24")))

=== Conclusions

In this chapter we started working with smart contracts in detail and explored the Solidity contract programming language.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc4")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc3"))) We took a simple example contract, _Faucet.sol_, and gradually improved it and made it more complex, using it to explore various aspects of the Solidity language. In <<vyper_chap>> we will work with Vyper, another contract-oriented programming language. We will compare Vyper to Solidity, showing some of the differences in the design of these two languages and deepening our understanding of smart contract programming.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc0")))

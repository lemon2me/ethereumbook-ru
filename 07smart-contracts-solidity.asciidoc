[[smart_contracts_chapter]]
== Смарт-контракты и Solidity

((("smart contracts", id="ix_07smart-contracts-solidity-asciidoc0", range="startofrange")))Как мы обсуждали в <<intro_chapter>>, в Ethereum существует два разных типа учетных записей: ((("EOA (Externally Owned Account)","contract accounts compared to")))аккаунты, принадлежащие лицам (EOA - Externally Owned Account), и аккаунт с контрактами. EOAS контролируются пользователями, часто с помощью программного обеспечения, такого как приложение кошелька, которое является внешним по отношению к платформе Ethereum. ((("contract accounts","EOAs compared to")))((("smart contracts","EOAs compared to")))Напротив, учетные записи с контрактами управляются программным кодом (также обычно называемым "смарт-контрактами"), который выполняется виртуальной машиной Ethereum. Короче говоря, EOAS - это простые учетные записи без какого-либо связанного кода или хранилища данных, в то время как контрактные учетные записи имеют как связанный код, так и хранилище данных. EOAS контролируются транзакциями, созданными и криптографически подписанными закрытым ключом в "реальном мире", внешнем по отношению к протоколу и независимом от него, в то время как контрактные учетные записи не имеют закрытых ключей и поэтому "контролируют себя" заранее определенным образом, предписанным их кодом смарт-контракта. Оба типа учетных записей идентифицируются по адресу Ethereum. В этой главе мы обсудим контрактные учетные записи и программный код, который ими управляет.

[[smart_contracts_definition]]
=== Что такое Смарт-контракт?

((("smart contracts","defined")))Термин _смарт-контракт_ (_smart-contract_) использовался на протяжении многих лет для описания самых разных вещей. ((("contract creation transaction")))((("Szabo, Nick")))В 1990-х годах криптограф Ник Сабо ввел этот термин в обиход и определил его как “набор обещаний, определенных в цифровой форме, включая протоколы, в рамках которых стороны выполняют другие обещания”. С тех пор концепция смарт-контрактов эволюционировала, особенно после внедрения децентрализованных блокчейн-платформ с изобретением Биткоина в 2009 году. В контексте Ethereum этот термин на самом деле немного неправильный, учитывая, что смарт-контракты Ethereum не являются ни интеллектуальными, ни юридическими контрактами, но этот термин прижился. В этой книге мы используем термин “смарт-контракты” для обозначения неизменяемых компьютерных программ, которые выполняются детерминированно в контексте виртуальной машины Ethereum как часть сетевого протокола Ethereum &#x2014; т.е. на децентрализованном всемирном компьютере Ethereum.

Давайте разложим это определение:

Компьютерные программы::
Смарт-контракты - это просто компьютерные программы. Слово "контракт" в данном контексте не имеет юридического значения.

Неизменный::
После развертывания код смарт-контракта не может быть изменен. В отличие от традиционного программного обеспечения, единственный способ изменить смарт-контракт - это развернуть (deploy) новый экземпляр.

Детерминированный::
Результат выполнения смарт-контракта одинаков для всех, кто его запускает, учитывая контекст транзакции, которая инициировала его выполнение, и состояние блокчейна Ethereum на момент исполнения.

Контекст EVM::
Смарт-контракты работают с очень ограниченным контекстом исполнения. Они могут получить доступ к своему собственному состоянию, контексту транзакции, которая их вызвала, и некоторой информации о самых последних блоках.

Децентрализованный мировой компьютер::
EVM работает как локальный экземпляр на каждом узле Ethereum, но поскольку все экземпляры EVM работают в одном и том же начальном состоянии и выдают одно и то же конечное состояние, система в целом работает как единый "мировой компьютер".

[[smart_contract_lifecycle]]
=== Жизненный цикл Смарт-контракта

((("smart contracts","life cycle of")))Смарт-контракты обычно пишутся на языке высокого уровня, таком как Solidity. Но для запуска они должны быть скомпилированы в низкоуровневый байт-код, который выполняется в EVM. После компиляции они развертываются на платформе Ethereum с использованием специальной транзакции _contract creation_, которая идентифицируется как таковая путем отправки на специальный адрес – адрес создания контрактов, а именно +0x0+ (см. <<contract_reg>>). Каждый контракт идентифицируется адресом Ethereum, который является производным от транзакции создания контракта в зависимости от исходной учетной записи и одноразового номера (nonce). Адрес Ethereum контракта может быть использован в транзакции в качестве получателя при отправлении средств или вызывая одну из функций контракта. Обратите внимание, что, в отличие от EOAs, ключей, связанных с учетной записью нового смарт-контракта, нет. Как создатель контракта, вы не получаете никаких особых привилегий на уровне протокола (хотя вы можете явно закодировать их в смарт-контракте). Вы, конечно, не получаете закрытый ключ для учетной записи контракта, которого на самом деле не существует &#x2014; мы можем сказать, что учетные записи смарт-контрактов владеют собой.

((("transactions","smart contracts and")))Важно отметить, что контракты _выполняются только в том случае, если они вызываются транзакцией_. Все смарт-контракты в Ethereum выполняются, в конечном счете, из-за транзакции, инициированной EOA. Контракт может вызывать другой контракт, который может вызывать другой контракт, и так далее, но первый контракт в такой цепочке выполнения всегда будет вызван транзакцией из EOA. Контракты никогда не выполняются “сами по себе” или “в фоновом режиме”. Контракты фактически бездействуют до тех пор, пока транзакция не инициирует выполнение, прямо или косвенно, как часть цепочки вызовов контрактов. Также стоит отметить, что смарт-контракты ни в коем случае не выполняются "параллельно" &#x2014; мировой компьютер Ethereum можно считать однопоточной машиной.

((("transactions","as atomic")))Транзакции являются _атомарными_ (_atomic_), они либо успешно завершаются, либо отменяются. Успешное завершение транзакции означает разные вещи в разных сценариях: (1) если транзакция отправляется из EOA в другой EOA, то записываются любые изменения глобального состояния (например, остатки на счетах), внесенные транзакцией; (2) если транзакция отправляется из EOA в контракт который не вызывает никаких других контрактов, тогда записываются любые изменения глобального состояния (например остатки на счетах, переменные состояния контрактов) (3) если транзакция отправляется из EOA в контракт, который только вызывает другие контракты способом, который распространяет ошибки, тогда записываются любые изменения глобального состояния (например, остатки на счетах, переменные состояния контрактов); и (4) если транзакция отправляется из EOA в контракт, который вызывает другие контракты способом, который не распространяет ошибки, тогда могут быть записаны только некоторые изменения глобального состояния (например остатки на счетах, переменные состояния контрактов без ошибок), в то время как другие изменения глобального состояния не регистрируются (например, переменные состояния контрактов с ошибками). В противном случае, если транзакция отменяется, все ее последствия (изменения состояния) “откатываются”, как если бы транзакция никогда не выполнялась.  Неудачная транзакция по-прежнему регистрируется как попытка, и эфир, потраченный на газ для выполнения, вычитается из исходного счета, но в остальном это не оказывает никакого другого влияния на контракт или состояние счета.

((("smart contracts","deleting")))Как упоминалось ранее, важно помнить, что код контракта не может быть изменен. Однако контракт можно “удалить”, удалив код и его внутреннее состояние (хранилище) из его адреса, оставив пустую учетную запись. Любые транзакции, отправленные на этот адрес учетной записи после удаления контракта, не приводят к выполнению какого-либо кода, поскольку там больше нет никакого кода для выполнения. ((("SELFDESTRUCT opcode")))Чтобы удалить контракт, вы выполняете код операции EVM с именем +SELFDESTRUCT+ (ранее называвшийся +SUICIDE+). ((("negative gas")))Эта операция обходится в “отрицательный газ”, возврат газа, тем самым стимулируя высвобождение ресурсов сетевого клиента из-за удаления сохраненного состояния. Удаление контракта таким образом не приводит к удалению истории транзакций (прошлого) контракта, поскольку сам блокчейн является неизменяемым. Также важно отметить, что возможность +SELFDESTRUCT+ будет доступна только в том случае, если автор контракта запрограммировал смарт-контракт на такую функциональность. Если в коде контракта нет кода операции +SELFDESTRUCT+ или он недоступен, смарт-контракт не может быть удален.

[[high_level_languages]]
=== Введение в языки высокого уровня Ethereum

((("EVM (Ethereum Virtual Machine)","and Ethereum high-level languages", id="ix_07smart-contracts-solidity-asciidoc1", range="startofrange")))((("smart contracts","and Ethereum high-level languages", id="ix_07smart-contracts-solidity-asciidoc2", range="startofrange")))EVM - это виртуальная машина, которая запускает ((("EVM bytecode"))) специальную форму кода, называемую _EVM bytecode_, аналогичную процессору вашего компьютера, который запускает машинный код, такой как x86_64. Мы рассмотрим работу и язык EVM гораздо более подробно в <<evm_chapter>>. В этом разделе мы рассмотрим, как пишутся смарт-контракты для работы на EVM.

В то время как можно программировать смарт-контракты непосредственно в байт-коде, байт-код EVM довольно громоздкий и очень трудный для чтения и понимания программистами. Вместо этого большинство разработчиков Ethereum используют язык высокого уровня для написания программ и компилятор для преобразования их в байт-код.

В то время как любой язык высокого уровня может быть адаптирован для написания смарт-контрактов, адаптация произвольного языка для компиляции в байт-код EVM является довольно громоздким занятием и в целом приведет к некоторой путанице. Смарт-контракты работают в сильно ограниченной и минималистичной среде исполнения (EVM). Кроме того, должен быть доступен специальный набор системных переменных и функций, специфичных для EVM. Таким образом, проще создать язык смарт-контрактов с нуля, чем создать язык общего назначения, подходящий для написания смарт-контрактов. В результате появился ряд языков специального назначения для программирования смарт-контрактов. В Ethereum есть несколько таких языков, а также компиляторы, необходимые для создания EVM-исполняемого байт-кода.

((("declarative programming")))В целом языки программирования можно разделить на две широкие парадигмы программирования: _декларативная_ (_declarative_) и _императивная_ (_imperative_), также известные как _функциональная_ (_functional_) и _процедурная_ (_procedural_) соответственно. В декларативном программировании мы пишем функции, которые выражают _логику_ (_logic_) программы, но не ее _поток выполнения_ (_flow_). ((("side effects")))Декларативное программирование используется для создания программ, в которых нет _сайд-эффектов_ (_side effects_), что означает, что нет никаких изменений состояния вне функции. Декларативные языки программирования включают Haskell и SQL. ((("hybrid programming languages")))((("imperative programming")))Императивное программирование, напротив, - это когда программист пишет набор процедур, которые объединяют логику и поток программы. Императивные языки программирования включают C++ и Java. Некоторые языки являются “гибридными”, что означает, что они поощряют декларативное программирование, но также могут использоваться для выражения императивной парадигмы программирования. Такие гибриды включают Lisp, JavaScript и Python. В общем, любой императивный язык можно использовать для написания в декларативной парадигме, но это часто приводит к неэлегантному коду. Для сравнения, чисто декларативные языки не могут использоваться для написания в императивной парадигме. В чисто декларативных языках _не существует никаких “переменных”_.

В то время как императивное программирование чаще используется программистами, может быть очень трудно писать программы, которые выполняются точно так, как ожидалось. Способность любой части программы изменять состояние любой другой части затрудняет рассуждения о выполнении программы и создает много возможностей для ошибок. Декларативное программирование, для сравнения, облегчает понимание того, как будет вести себя программа: поскольку оно не имеет побочных эффектов, любая часть программы может быть понята изолированно.

В смарт-контрактах ошибки в буквальном смысле стоят денег. В результате критически важно писать смарт-контракты без непреднамеренных последствий. Чтобы сделать это, вы должны быть в состоянии четко рассуждать об ожидаемом поведении программы. Таким образом, декларативные языки играют гораздо большую роль в смарт-контрактах, чем в программном обеспечении общего назначения. Тем не менее, как вы увидите, наиболее широко используемый язык для смарт-контрактов (Solidity) является императивным. Программисты, как и большинство людей, сопротивляются переменам!

Поддерживаемые в настоящее время языки программирования высокого уровня для смарт-контрактов включают в себя (упорядоченные по приблизительному возрасту):

LLL:: ((("LLL"))) Функциональный (декларативный) язык программирования с синтаксисом, подобным Lisp. Это был первый язык высокого уровня для смарт-контрактов Ethereum, но сегодня он редко используется.

Serpent:: ((("Serpent")))Процедурный (императивный) язык программирования с синтаксисом, похожим на Python. Может также использоваться для написания функционального (декларативного) кода, хотя он не полностью свободен от побочных эффектов.

Solidity:: ((("Solidity"))) Процедурный (императивный) язык программирования с синтаксисом, похожим на JavaScript, pass:[C++] или Java. Самый популярный и часто используемый язык для смарт-контрактов Ethereum.

Vyper:: ((("Vyper"))) Более недавно разработанный язык, похожий на Serpent и опять же с синтаксисом, подобным Python. Предназначен для того, чтобы приблизиться к чисто функциональному языку, подобному Python, чем Serpent, но не для замены Serpent.

Bamboo:: ((("Bamboo"))) Недавно разработанный язык, на который повлиял Erlang, с явными переходами состояний и без итеративных потоков (циклов). Предназначен для уменьшения побочных эффектов и повышения проверяемости. Очень новый и еще не получивший широкого распространения.

Как вы можете видеть, есть много языков на выбор. Однако из всех них Solidity, безусловно, является самым популярным, вплоть до того, что фактически является языком высокого уровня Ethereum и даже других блокчейнов, подобных EVM. Мы проведем большую часть нашего времени, используя Solidity, но также рассмотрим некоторые примеры на других языках высокого уровня, чтобы получить представление об их различных философиях.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc2")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc1")))

[[building_a_smart_contract_sec]]
=== Построение Смарт-контракта на Solidity

((("smart contracts","building with Solidity", id="ix_07smart-contracts-solidity-asciidoc3", range="startofrange")))((("Solidity","building a smart contract with", id="ix_07smart-contracts-solidity-asciidoc4", range="startofrange")))Solidity ((("smart contracts","Solidity and", id="ix_07smart-contracts-solidity-asciidoc5", range="startofrange")))((("Solidity","smart contracts and", id="ix_07smart-contracts-solidity-asciidoc6", range="startofrange")))был создан ((("Wood, Dr. Gavin","and Solidity")))доктором Гэвин Вуд (соавтор этой книги) как язык, предназначенный специально для написания смарт-контрактов с функциями, непосредственно поддерживающими выполнение в децентрализованной среде мирового компьютера Ethereum. Результирующие атрибуты являются довольно общими, и поэтому в конечном итоге они используются для кодирования смарт-контрактов на нескольких других блокчейн-платформах. Он был разработан Кристианом Рейтивесснером, а затем также Алексом Берегсаззи, Лианой Хусикян, Йоичи Хираи и несколькими бывшими участниками Ethereum core. Solidity в настоящее время разрабатывается и поддерживается как независимый проект https://github.com/ethereum/solidity[на GitHub].

Основным "продуктом" проекта Solidity является компилятор Solidity +solc+, который преобразует программы, написанные на языке Solidity, в байт-код EVM. Проект также управляет важным стандартом application binary interface (ABI) для смарт-контрактов Ethereum, который мы подробно рассмотрим в этой главе. Каждая версия компилятора Solidity соответствует и компилирует определенную версии Solidity pass:[<span class="keep-together">языка</span>].

Для начала мы загрузим двоичный исполняемый файл компилятора Solidity. Затем мы разработаем и скомпилируем простой контракт, следуя примеру, с которого мы начали в <<intro_chapter>>.

==== Выбор версии Solidity

((("semantic versioning")))((("Solidity","selecting version of")))Solidity следует модели управления версиями, называемой https://semver.org/[_semantic versioning_], которая определяет номера версий, структурированные в виде трех чисел, разделенных точками: __++MAJOR.MINOR.PATCH++__. Число "major" увеличивается для основных изменений и изменений, несовместимых с предыдущими версиями, число "minor" увеличивается по мере добавления обратно совместимых функций между основными выпусками, а число "patch" увеличивается для исправлений ошибок, совместимых с предыдущими версиями.

На момент написания статьи Solidity находится на версии 0.6.4. Правила для основной версии 0, которая предназначена для начальной разработки проекта, отличаются: все может измениться в любое время. На практике Solidity изменяет "minor" номер так, как если бы это была основная версия, а номер "patch" - как если бы это была второстепенная версия. Поэтому в версии 0.6.4 6 считается основной версией (major), а 4 - второстепенной (minor).

В ближайшее время ожидается выпуск основной версии Solidity версии 0.5.

Как вы видели в <<intro_chapter>>, ваши программы Solidity могут содержать директиву pragma, которая определяет минимальную и максимальную версии Solidity, с которыми она совместима, и может использоваться для компиляции вашего контракта.

Поскольку Solidity быстро развивается, часто лучше установить последнюю версию.

==== Загрузка и установка

((("Solidity","downloading/installing")))Существует несколько методов, которые вы можете использовать для загрузки и установки Solidity, либо в виде двоичной версии, либо путем компиляции из исходного кода. Вы можете найти подробные инструкции в http://bit.ly/2RrZmup[документации к Solidity].

Вот как установить последнюю двоичную версию Solidity в операционную систему Ubuntu/Debian, используя менеджер пакетов +apt+:

++++
<pre data-type="programlisting">
$ <strong>sudo add-apt-repository ppa:ethereum/ethereum</strong>
$ <strong>sudo apt update</strong>
$ <strong>sudo apt install solc</strong>
</pre>
++++

После установки +solc+ проверьте версию, запустив:

++++
<pre data-type="programlisting">
$ <strong>solc --version</strong>
solc, the solidity compiler commandline interface
Version: 0.6.4+commit.1dca32f3.Linux.g++
</pre>
++++

Существует ряд других способов установки Solidity, в зависимости от вашей операционной системы и требований, включая компиляцию непосредственно из исходного кода. Для получения дополнительной информации смотрите https://github.com/ethereum/solidity[].



==== Среда разработки

((("Solidity","development environment")))Для разработки в Solidity вы можете использовать любой текстовый редактор и +solc+ в командной строке. Однако вы можете обнаружить, что некоторые текстовые редакторы, предназначенные для разработки, такие как Emacs, Vim и Atom, предлагают дополнительные функции, такие как подсветка синтаксиса и макросы, которые упрощают разработку Solidity.

Существуют также веб-среды разработки, такие как https://remix.ethereum.org/[Remix IDE] и https://ethfiddle.com/[EthFiddle].

Используйте инструменты, которые делают вас продуктивными. В конце концов, программы Solidity - это просто текстовые файлы. В то время как модные редакторы и среды разработки могут упростить задачу, вам не нужно ничего, кроме простого текстового редактора, такого как nano (Linux / Unix), TextEdit (macOS) или даже NotePad (Windows). Просто сохраните исходный код вашей программы с расширением _.sol_, и компилятор Solidity распознает его как программу Solidity.

==== Написание простой программы на Solidity

((("Solidity","writing a simple program in")))В <<intro_chapter>> мы написали нашу первую программу Solidity. Когда мы впервые создали контракт +Faucet+, мы использовали среду разработки Remix IDE для компиляции и развертывания контракта. В этом разделе мы рассмотрим, улучшим и приукрасим +Faucet+.

Наша первая попытка выглядела так <<original_sol_faucet>>.

[[original_sol_faucet]]
.Faucet.sol:  Solidity контракт, реализующий кран
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----
====

==== Компиляция с помощью компилятора Solidity (solc)

((("Faucet.sol contract (test example)","compiling")))((("solc (Solidity compiler)")))((("Solidity compiler (solc)")))Теперь мы будем использовать компилятор Solidity в командной строке для непосредственной компиляции нашего контракта. Компилятор Solidity +solc+ предлагает множество опций, которые вы можете увидеть, передав аргумент +--help+.

Мы используем аргументы +--bin+ и +--optimize+ в +solc+ для создания оптимизированного двоичного файла нашего контракта из примера:


++++
<pre data-type="programlisting">
$ <strong>solc --optimize --bin Faucet.sol</strong>
======= Faucet.sol:Faucet =======
Binary:
608060405234801561001057600080fd5b5060cc8061001f6000396000f3fe6080604052600436106
01f5760003560e01c80632e1a7d4d14602a576025565b36602557005b600080fd5b34801560355760
0080fd5b50605060048036036020811015604a57600080fd5b50356052565b005b67016345785d8a0
000811115606657600080fd5b604051339082156108fc029083906000818181858888f19350505050
1580156092573d6000803e3d6000fd5b505056fea26469706673582212205cf23994b22f7ba19eee5
6c77b5fb127bceec1276b6f76ca71b5f95330ce598564736f6c63430006040033
</pre>
++++


Результат, который выдает +solc+, представляет собой шестнадцатеричный двоичный файл, который может быть отправлен в блокчейн Ethereum.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc6")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc5")))

[[eth_contract_abi_sec]]
=== ABI для контрактов Ethereum

((("ABI (application binary interface)", id="ix_07smart-contracts-solidity-asciidoc7", range="startofrange")))((("application binary interface (ABI)", id="ix_07smart-contracts-solidity-asciidoc8", range="startofrange")))((("smart contracts","ABI", id="ix_07smart-contracts-solidity-asciidoc9", range="startofrange")))В компьютерном программном обеспечении _двоичный интерфейс приложения_ (_application binary interface_) (ABI) - это интерфейс между двумя программными модулями; часто между операционной системой и пользовательскими программами. ABI определяет, как осуществляется доступ к структурам данных и функциям в _машинном коде_ (_machine code_); это не следует путать с API, который определяет этот доступ в высокоуровневых, часто удобочитаемых форматах в _исходном коде_ (_source code_). Таким образом, ABI является основным способом кодирования и декодирования данных в машинный код и из него.

В Ethereum ABI используется для кодирования вызовов контрактов для EVM и считывания данных из транзакций. Цель ABI - определить функции в контракте, которые могут быть вызваны, и описать, как каждая функция будет принимать аргументы и возвращать свой результат.

ABI контракта указывается в виде массива JSON с описанием функций (см. <<solidity_functions>>) и событий (см. <<solidity_events>>). Описание функции представляет собой объект JSON с полями `type`, `name`, `inputs`, `outputs`, `constant` и `payable`. Объект описания события имеет поля `type", "name`, `inputs` и `anonymous`.

Мы используем Solidity компилятор +solc+ в командной строке для создания ABI для нашего pass:[<span class="keep-together"><em>Faucet.sol</em></span>] контракта:

++++
<pre data-type="programlisting">
$ <strong>solc --abi Faucet.sol</strong>
======= Faucet.sol:Faucet =======
Contract JSON ABI
[{"inputs":[{"internalType":"uint256","name":"withdraw_amount","type":"uint256"}], \
"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}, \
{"stateMutability":"payable","type":"receive"}]
</pre>
++++

Как вы можете видеть, компилятор создает массив JSON, описывающий две функции, определенные _Faucet.sol_. Этот JSON может быть использован любым приложением, которое хочет получить доступ к контракту +Faucet+ после его развертывания. Используя ABI, приложение, такое как кошелек или браузер DApp, может создавать транзакции, которые вызывают функции в +Faucet+ с правильными аргументами и типами аргументов. Например, кошелек будет знать, что для вызова функции +withdraw+ он должен предоставить +uint256+ аргумент с именем +withdraw_amount+. Кошелек может предложить пользователю указать это значение, затем создать транзакцию, которая кодирует его и выполняет функцию +withdraw+.

Все, что необходимо для взаимодействия приложения с контрактом, - это ABI и адрес, по которому был развернут контракт.

[[solidity_pragma]]
==== Выбор компилятора Solidity и версии языка

((("Solidity","selecting compiler and language version")))Как мы видели в предыдущем коде, наш контракт +Faucet+ успешно компилируется с Solidity версии 0.6.4. Но что, если бы мы использовали другую версию компилятора Solidity? Язык все еще находится в постоянном движении, и все может измениться самым неожиданным образом. Наш контракт довольно прост, но что, если наша программа использовала функцию, которая была добавлена только в Solidity версии 0.6.1, и мы попытались скомпилировать ее с помощью 0.6.0?

((("compiler directive")))((("version pragma")))Для решения таких проблем Solidity предлагает _команду для компилятора_ (_compiler directive_), известную как _version pragma_, которая сообщает компилятору, что программа ожидает конкретную версию компилятора (и языка). Давайте рассмотрим пример:

[[compiler_version]]
----
pragma solidity ^0.6.0;
----

Компилятор Solidity считывает _version pragma_ и выдает ошибку, если версия компилятора несовместима с _version pragma_. В этом случае наша _version pragma_ говорит, что эта программа может быть скомпилирована компилятором Solidity с минимальной версией 0.6.0. Символ +^+ указывает, однако, что мы разрешаем компиляцию с любым _minor revision_ выше 0.6.0; например, 0.6.1, но не 0.7.0 (что является major версией, а не minor). Директивы "pragma" не компилируются в байт-код EVM. Они используются компилятором только для проверки совместимости.

Давайте добавим директиву pragma в наш контракт +Faucet+. Мы назовем новый файл pass:[<span class="keep-together"><em>Faucet2.sol</em></span>], чтобы отслеживать наши изменения по мере прохождения этих примеров, начиная с <<add_pragma_to_faucet>>.

[[add_pragma_to_faucet]]
.Faucet2.sol: Добавление version pragma в Faucet
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet2.sol[]
----
====

Добавление version pragma является наилучшей практикой, поскольку это позволяет избежать проблем с несовпадением версий компилятора и языка. Мы изучим другие лучшие практики и продолжим совершенствовать контракт +Faucet+ на протяжении всей этой главы.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc9")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc8")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc7")))

=== Программирование на Solidity

((("Solidity","programming with", id="ix_07smart-contracts-solidity-asciidoc10", range="startofrange")))В этом разделе мы рассмотрим некоторые возможности языка Solidity. Как мы упоминали в <<intro_chapter>>, наш первый пример контракта был очень простым, а также имел различные недостатки. Мы будем постепенно улучшать его здесь, изучая, как использовать Solidity. Однако это не будет всеобъемлющим руководством по Solidity, поскольку Solidity довольно сложна и быстро развивается. Мы рассмотрим основы и дадим вам достаточную основу, чтобы вы могли изучить остальное самостоятельно. Документацию по Solidity можно найти
https://solidity.readthedocs.io/en/latest/[на сайте проекта].

==== Типы данных

((("Solidity","data types", id="ix_07smart-contracts-solidity-asciidoc11", range="startofrange")))Во-первых, давайте рассмотрим некоторые из основных типов данных, предлагаемых в Solidity:

Булево значение (+bool+):: Логическое значение, +true+ или +false+, с логическими операторами +!+ (не), +&&+ (и), +||+ (или), +==+ (равно) и +!=+ (не равно).

Целое число (+int+, +uint+):: Целые числа со знаком (+int+) и без знака (+uint+), объявляемые с шагом 8 бит от +int8+ до +uint256+. Без суффикса размера используются 256-битные величины, соответствующие размеру слова EVM.

Фиксированная точка (+fixed+, +ufixed+):: Числа с фиксированной точкой, объявленные с помощью pass:[(<code>u</code>)<code>fixed<em>M</em>x<em>N</em></code>], где __++M++__ - размер в битах (с шагом от 8 до 256), а __++N++__ - количество десятичных знаков после запятой (до 18); например, +ufixed32x2+.

Адрес:: 20-байтовый адрес Ethereum. Объект +address+ имеет много полезных функций-членов, основными из которых являются +balance+ (возвращает баланс счета) и pass:[<span class="keep-together"><code>transfer</code></span>] (переводит эфир на счет).

Массив байтов (фиксированный):: Массивы байтов фиксированного размера, объявленные от +байт1+ до +байт32+.

Массив байтов (динамический):: Массивы байтов переменного размера, объявленные с помощью +bytes+ или +string+.

Enum:: Определяемый пользователем тип для перечисления дискретных значений: +enum NAME {LABEL1, LABEL 2, pass:[...]}+.

Массивы:: Массив любого типа, фиксированный или динамический: +uint32[][5]+ представляет собой массив фиксированного размера из пяти динамических массивов целых чисел без знака.

Структура:: Определяемые пользователем контейнеры данных для группировки переменных: pass:[<code>struct NAME {TYPE1 <span class="keep-together">VARIABLE1</span>; TYPE2 VARIABLE2; ...}</code>].

Сопоставление:: Таблицы хэш-поиска для __++key++__ +=>+ _++value++_ pairs: +mapping(KEY_TYPE => VALUE_TYPE) NAME+.

В дополнение к этим типам данных Solidity также предлагает множество литералов, которые можно использовать для вычисления различных единиц измерения:

Единицы измерения времени:: Единицы измерения +секунды+, +минуты+, +часы+ и +дни+ могут использоваться в качестве суффиксов, преобразуясь в кратные базовой единице (+секунда+) значения.

Единицы эфира:: Единицы +wei+, +finney+, +szabo+ и +ether+ могут использоваться в качестве суффиксов, преобразуясь в кратные базовой единице (+wei+) значения.

В нашем примере контракта +Faucet+ мы использовали +uint+ (который является псевдонимом +uint256+) для переменной +withdraw_amount+. Мы также косвенно использовали переменную +address+, которую мы установили с помощью +msg.sender+. Мы будем использовать больше этих типов данных в наших примерах в остальной части этой главы.

Давайте используем один из множителей для единиц измерения, чтобы улучшить читаемость нашего примера контракта. В функции +withdraw+ мы ограничиваем максимальный вывод средств, выражая предел в wei, базовой единице эфира:

----
require(withdraw_amount <= 100000000000000000);
----

Это не очень легко читать. Мы можем улучшить наш код, используя множитель для единиц измерения +ether+, чтобы выразить значение в эфире вместо wei:(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc11")))

----
require(withdraw_amount <= 0.1 ether);
----

==== Предопределенные глобальные переменные и функции

((("Solidity","predefined global variables/functions", id="ix_07smart-contracts-solidity-asciidoc12", range="startofrange")))Когда контракт выполняется в EVM, он имеет доступ к небольшому набору глобальных объектов. К ним относятся объекты +block+, +msg+ и +tx+. Кроме того, Solidity предоставляет ряд кодов операций EVM в качестве предопределенных функций. В этом разделе мы рассмотрим переменные и функции, к которым вы можете получить доступ из смарт-контракта в Solidity.

===== Контекст вызова транзакции/сообщения

((("message call")))((("msg object")))((("transaction call")))Объект +msg+ - это вызов транзакции (инициированный EOA) или вызов сообщения (инициированный контрактом), который запустил выполнение этого контракта. Он содержит ряд полезных атрибутов:

+msg.sender+:: Мы уже использовали его. Он представляет адрес, который инициировал вызов этого контракта, не обязательно исходный EOA, отправивший транзакцию. Если наш контракт был вызван непосредственно транзакцией EOA, то это адрес, который подписал транзакцию, но в противном случае это будет адрес контракта.

+msg.value+:: Значение эфира, отправленного с этим вызовом (в wei).

+msg.gas+:: Количество газа, оставшегося для данной среды выполнения. Эта функция устарела в Solidity v0.4.21 и была заменена функцией +gasleft+.

+msg.data+:: Полезная нагрузка данных этого вызова в наш контракт.

+msg.sig+:: Первые четыре байта полезной нагрузки данных, которая является селектором функций.

[NOTE]
====
Всякий раз, когда контракт вызывает другой контракт, значения всех атрибутов +msg+ изменяются, чтобы отразить информацию о новом вызывающем абоненте. Единственным исключением из этого правила является функция +delegatecall+, которая запускает код другого контракта/библиотеки в исходном +msg+ pass:[<span class="keep-together">контексте</span>].
====

===== Контекст транзакции

((("tx object")))Объект +tx+ предоставляет средство доступа к информации, связанной с транзакцией:

++tx.gasprice++:: Цена на газ в вызывающей транзакции.

++tx.origin++:: Адрес отправителя EOA для этой транзакции. ВНИМАНИЕ: небезопасно!

===== Контекст блока

((("block object")))Объект +block+ содержит информацию о текущем блоке:

++block.blockhash(__blockNumber__)++:: Хэш блока для указанного номера блока, до 256 блоков в прошлом. Устарел и заменен функцией +blockhash+ в Solidity v0.4.22.

++block.coinbase++:: Адрес получателя сборов за текущий блок и вознаграждения за блок.

++block.difficulty++:: Сложность (proof of work) текущего блока.

++block.gaslimit++:: Максимальное количество газа, которое может быть потрачено на все транзакции, включенные в текущий блок.

++block.number++:: Текущий номер блока (высота блокчейна).

++block.timestamp++:: Временная метка, помещенная майнером в текущий блок (количество секунд, прошедших с эпохи Unix).

[[solidity_address_object]]
===== Адрес объекта

((("address object")))Любой адрес, либо переданный в качестве входных данных, либо полученный из контракта, имеет ряд атрибутов и методов:

+address.balance+:: Баланс адреса в вэй. Например, текущий баланс контракта равен +address(this).balance+.

++address.transfer(__amount__)++:: Переводит сумму (в wei) на этот адрес, вызывая исключение при любой ошибке. Мы использовали эту функцию в нашем примере +Faucet+ в качестве метода для адреса +msg.sender+, как +msg.sender.transfer+.

++address.send(__amount__)++:: Аналогично +transfer+, только вместо того, чтобы выдавать исключение, он возвращает +false+ при ошибке. ПРЕДУПРЕЖДЕНИЕ: всегда проверяйте возвращаемое значение +send+.

++address.call(__payload__)++:: Низкоуровневая +CALL+ функция&#x2014; может создавать произвольный вызов сообщения с полезной нагрузкой данных. Возвращает +false+ при ошибке. ПРЕДУПРЕЖДЕНИЕ: небезопасный получатель может (случайно или злонамеренно) израсходовать весь ваш газ, что приведет к остановке вашего контракта с исключением +OOG+; всегда проверяйте возвращаемое значение +call+.

+address.delegatecall(__payload__)+:: Низкоуровневая функция +DELEGATECALL+, например +call code(pass:[...])+ , но с полным контекстом +msg+, видимым текущим контрактом. Возвращает +false+ при ошибке. ВНИМАНИЕ: только для продвинутого использования!

===== Встроенные функции

Другими функциями, которые стоит отметить, являются:

+addmod+, +mulmod+:: Для сложения и умножения по модулю. Например, +addmod(x,y,k)+ вычисляет +pass:[(x + y) % k]+.

+keccak256+, +sha256+, +sha3+, +ripemd160+:: Функции для вычисления хэшей с помощью различных стандартных алгоритмов хэширования.

+ecrecover+:: Восстанавливает из подписи адрес, используемый для подписывания сообщения.

++selfdestruct(__recipient_address__)++:: Удаляет текущий контракт, отправляя любой оставшийся эфир на счете на адрес получателя.

+this+:: Адрес учетной записи текущего исполняемого контракта.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc12")))

==== Определение контракта

((("contract data type")))((("contract definition, Solidity")))((("Solidity","contract definition")))Основным типом данных Solidity является +contract+; в нашем примере +Faucet+ просто определяет объект контракта: pass:[<span class="keep-together"><code>contract</code></span>]. Подобно любому объекту в объектно-ориентированном языке, контракт представляет собой контейнер, включающий данные и методы.

Solidity предлагает два других типа объектов, похожих на контракт:

+interface+:: ((("interface object type")))((("stub")))Определение интерфейса структурировано точно так же, как контракт, за исключением того, что ни одна из функций не определена, они только объявлены. Этот тип объявления часто называют _stub_; он сообщает вам аргументы функций и возвращаемые типы без какой-либо реализации. Интерфейс определяет "форму" контракта; при наследовании каждая из функций, объявленных интерфейсом, должна быть определена дочерним элементом.

+library+:: ((("library contract")))Библиотечный контракт - это контракт, который предназначен для развертывания только один раз и использования другими контрактами с использованием метода +delegatecall+ (см. <<solidity_address_object>>).

[[solidity_functions]]
==== Функции

((("Solidity","functions", id="ix_07smart-contracts-solidity-asciidoc13", range="startofrange")))В контракте мы определяем функции, которые могут быть вызваны транзакцией EOA или другим контрактом. В нашем примере +Faucet+ у нас есть две функции: +withdraw+ и (безымянная) функция _fallback_.

((("Solidity","function syntax")))Синтаксис, который мы используем для объявления функции в Solidity, выглядит следующим образом:

++++
<pre data-type="programlisting">
function FunctionName([<em>parameters</em>]) {public|private|internal|external}
[pure|view|payable] [<em>modifiers</em>] [returns (<em>return types</em>)]
</pre>
++++


Давайте рассмотрим каждый из этих компонентов:

++FunctionName++:: Имя функции, которое используется для вызова функции в транзакции (из EOA), из другого контракта или даже из того же контракта. ((("fallback function"))) Одна функция в каждом контракте может быть определена как _резервная функция_ (_fallback function_) с использованием ключевого слова ""fallback или функция приема эфира, определенная с использованием ключевого слова "receive". Если функция приема эфира присутствует, то она вызывается всякий раз, когда данные вызова пусты (независимо от того, получен эфир или нет). А резервная функция вызывается, когда никакая другая функция не вызвана. Резервная функция не может иметь никаких аргументов или возвращать что-либо.

__++parameters++__:: После имени мы указываем аргументы, которые должны быть переданы функции, с их именами и типами. В нашем примере +Faucet+ мы определили +uint withdraw_amount+ в качестве единственного аргумента для pass:[<code><span class="keep-together">withdraw</span></code>] функции.

Следующий набор ключевых слов (+public+, +private+, +internal+, +external+) определяет видимость функции:

+public+:: ((("public function")))По умолчанию используется значение public; такие функции могут вызываться другими контрактами или транзакциями EOA или изнутри контракта. В нашем примере +Faucet+ обе функции определены как общедоступные (public).

+external+:: ((("external function")))Внешние функции подобны общедоступным функциям, за исключением того, что они не могут быть вызваны из контракта, если явно не указано ключевое слово +this+.

+internal+:: ((("internal function")))Внутренние функции доступны только из контракта &#x2014; они не могут быть вызваны другим контрактом или транзакцией EOA. Они могут быть вызваны производными контрактами (теми, которые наследуют этот контракт).

+private+:: ((("private function")))Приватные функции подобны внутренним функциям, но не могут быть вызваны производными pass:[<span class="keep-together">контактами</span>].

Имейте в виду, что термины _internal_ и _private_ несколько вводят в заблуждение. Любая функция или данные внутри контракта всегда доступны для просмотра в общедоступном блокчейне, что означает, что любой может увидеть код или данные. Ключевые слова, описанные здесь, влияют только на то, как и когда функция может быть _вызвана_.

Второй набор ключевых слов (+pure+, +constant+, +view+, +payable+) влияет на поведение функции:

+constant+ or +view+:: ((("view (function keyword)")))Функция, помеченная как _view_, обещает не изменять какое-либо состояние. ((("constant (function keyword)"))) Термин _constant_ - это псевдоним представления (+view+,), который станет устаревшим в будущем выпуске. В настоящее время компилятор не применяет модификатор +view+, выдавая только предупреждение, но ожидается, что это станет принудительным ключевым словом в версии 0.5 Solidity.

+pure+:: ((("pure function")))Чистая функция (pure) - это функция, которая не считывает и не записывает никакие переменные в хранилище. Она может работать только с аргументами и возвращать данные не ссылаясь на какие-либо сохраненные данные. Чистые функции предназначены для поощрения программирования в декларативном стиле без побочных эффектов (side effects) или хранения состояний.

+payable+:: ((("payable function")))Payable функция - это функция, которая может принимать входящие платежи. Функции, не объявленные как +payable+, будут отклонять входящие платежи. Есть два исключения, обусловленные проектными решениями в EVM: платежи coinbase и наследование +SELFDESTRUCT+ будут оплачены, даже если резервная функция не объявлена как +payable+, но это имеет смысл, поскольку выполнение кода в любом случае не является частью этих pass:[<span class="keep-together">платежей</span>].

Как вы можете видеть в нашем примере +Faucet+, у нас есть одна (payable) функция оплаты (резервная функция – fallback), которая является единственной функцией, которая может принимать входящие платежи.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc13")))

==== Конструктор контрактов и самоуничтожение

((("constructor function")))((("smart contracts","constructor function")))((("Solidity","contract constructor function")))Существует специальная функция, которая используется только один раз. Когда создается контракт, он также запускает функцию _constructor_, если таковая существует, для инициализации состояния контракта. Конструктор запускается в той же транзакции, что и создание контракта. Функция конструктора необязательна; вы заметите, что в нашем примере +Faucet+ ее нет.

Конструкторы могут быть указаны двумя способами. Вплоть до Solidity v0.4.21 включительно конструктор представляет собой функцию, имя которой совпадает с именем контракта, как вы можете видеть здесь:

[source,solidity]
----
contract MEContract {
    function MEContract() {
        // This is the constructor
    }
}
----


Сложность с этим форматом заключается в том, что если имя контракта изменено, а имя функции конструктора не изменено, это больше не конструктор. Аналогично, если есть случайная опечатка в именовании контракта и / или конструктора, функция снова больше не является конструктором. Это может привести к некоторым довольно неприятным, неожиданным и трудным в поиске ошибкам. Представьте, например, что конструктор устанавливает владельца контракта в целях контроля. Если функция на самом деле не является конструктором из-за ошибки именования, владелец не только останется неустановленным во время создания контракта, но функция также может быть развернута как постоянная и доступная для вызова часть контракта, как обычная функция, позволяя любой третьей стороне перехватить контракт и стать его "владельцем" после создания контракта.

Чтобы устранить потенциальные проблемы, связанные с тем, что функции конструктора основаны на том, что их имя совпадает с именем контракта, Solidity v0.4.22 вводит ключевое слово +constructor+, которое работает как функция конструктора, но не имеет имени. Переименование контракта вообще не влияет на конструктор. Кроме того, легче определить, какая функция является конструктором. Это выглядит примерно так:

[source,solidity]
----
pragma ^0.4.22
contract MEContract {
    constructor () {
        // This is the constructor
    }
}
----

Подводя итог, можно сказать, что жизненный цикл контракта начинается с транзакции создания из EOA или учетной записи контракта. Если существует конструктор, он выполняется как часть создания контракта, чтобы инициализировать состояние контракта при его создании, а затем отбрасывается.

((("contract destruction")))((("selfdestruct function")))((("Solidity","contract destruction")))((("Solidity","selfdestruct function")))Другой конец жизненного цикла контракта - это _разрушение контракта_ (_contract destruction_). ((("SELFDESTRUCT opcode")))Контракты уничтожаются специальным кодом операции EVM, называемым +SELFDESTRUCT+. Раньше он назывался pass:[<span class="keep-together"><code>SUICIDE</code></span>], но это название устарело из-за негативных ассоциаций этого слова. В Solidity этот код операции отображается как высокоуровневая встроенная функция с именем +selfdestruct+, которая принимает один аргумент: адрес для получения любого остатка эфира, оставшегося на контрактной учетной записи. Это выглядит примерно так:

[source,solidity]
----
selfdestruct(address recipient);
----

Обратите внимание, что вы должны явно добавить эту команду в свой контракт, если хотите, чтобы он был удаляемым &#x2014; это единственный способ удаления контракта, и по умолчанию он отсутствует. Таким образом, пользователи контракта, которые могут полагаться на то, что контракт существует вечно, могут быть уверены, что контракт не может быть удален, если он не содержит pass:[<span class="keep-together"><code>SELFDESTRUCT</code></span>] команду.

==== Добавление конструктора и selfdestruct к нашему примеру Faucet

((("constructor function","adding to faucet example")))((("Faucet.sol contract (test example)","adding constructor and selfdestruct to")))((("Solidity","adding constructor/selfdestruct to faucet example")))Пример контракта +Faucet+, который мы представили в <<intro_chapter>>, не имеет никакого конструктора или функций +selfdestruct+. Это вечный контракт, который не может быть удален. Давайте изменим это, добавив конструктор и функцию +selfdestruct+. Вероятно, мы хотим, чтобы +selfdestruct+ вызывался только EOA, который первоначально создал контракт. По соглашению, его значение обычно хранится в адресной переменной, называемой +owner+. Наш конструктор устанавливает переменную +owner+, и функция +selfdestruct+ сначала проверит, что владелец вызвал ее напрямую.

Во-первых, наш конструктор:

[source,solidity]
----
// Version of Solidity compiler this program was written for
pragma solidity ^0.6.0;

// Our first contract is a faucet!
contract Faucet {

    address owner;

    // Initialize Faucet contract: set owner
    constructor() {
        owner = msg.sender;
    }

    [...]
}
----

В нашем контракте теперь есть переменная типа +address+ с именем +owner+. Название "owner" никоим образом не является особенным. Мы могли бы назвать эту переменную адреса "potato" и по-прежнему использовать ее таким же образом. Название "owner" просто проясняет её назначение.

Далее наш конструктор, который выполняется как часть транзакции создания контракта, присваивает адрес из +msg.sender+ переменной +owner+. Мы использовали +msg.sender+ в функции pass:[<span class="keep-together"><code>withdraw</code></span>] для идентификации инициатора запроса на вывод средств. Однако в конструкторе +msg.sender+ - это EOA или адрес контракта, который инициировал создание контракта. Мы знаем, что это так, потому что это функция конструктора: она выполняется только один раз, во время создания контракта.

Теперь мы можем добавить функцию для уничтожения контракта. Нам нужно убедиться, что только владелец может запустить эту функцию, поэтому мы будем использовать оператор +require+ для управления доступом. Вот как это будет выглядеть:

[source,solidity]
----
// Contract destructor
function destroy() public {
    require(msg.sender == owner);
    selfdestruct(owner);
}
----

Если кто-либо вызовет функцию +destroy+ с адреса, отличного от +owner+, она завершится неудачей. Но если тот же адрес, сохраненный в +owner+ конструктором, вызовет его, контракт самоуничтожится и отправит любой оставшийся остаток на адрес +owner+. Обратите внимание, что мы не использовали небезопасный +tx.origin+, чтобы определить, желает ли владелец уничтожить контракт &#x2014; использование +tx.origin + позволит вредоносным контрактам уничтожить ваш контракт без вашего разрешения.

==== Модификаторы функций

((("function modifiers")))((("Solidity","function modifiers")))Solidity предлагает специальный тип функции, называемый _модификатор функции_ (_function modifier_). Вы применяете модификаторы к функциям, добавляя имя модификатора в объявление функции. Модификаторы чаще всего используются для создания условий, которые применяются ко многим функциям в контракте. У нас уже есть оператор управления доступом в нашей функции +destroy+. Давайте создадим модификатор функции, который выражает это условие:

[source,solidity]
----
modifier onlyOwner {
    require(msg.sender == owner);
    _;
}
----


Этот модификатор функции с именем +onlyOwner+ устанавливает условие для любой функции, которую он изменяет, требуя, чтобы адрес, сохраненный в качестве +владельца+ контракта, совпадал с адресом +msg.sender+ транзакции. Это базовый шаблон проектирования для управления доступом, позволяющий только владельцу контракта выполнять любую функцию, имеющую модификатор +onlyOwner+.

Возможно, вы заметили, что наш модификатор функции содержит своеобразный синтаксический "плейсхолдер" - символ подчеркивания, за которым следует точка с запятой &#95;;. Этот плейсхолдер заменяется кодом изменяемой функции. По сути, модификатор "оборачивается" вокруг измененной функции, помещая ее код в место, обозначенное символом подчеркивания.

Чтобы применить модификатор, вы добавляете его имя в объявление функции. К функции может быть применено более одного модификатора; они применяются в той последовательности, в которой они объявлены, в виде списка, разделенного пробелами.

Давайте перепишем нашу функцию +destroy+, чтобы использовать модификатор +onlyOwner+:

[source,solidity]
----
function destroy() public onlyOwner {
    selfdestruct(owner);
}
----

Имя модификатора функции (+onlyOwner+) стоит после ключевого слова +public+ и сообщает нам, что функция +destroy+ модифицируется модификатором +onlyOwner+. По сути, вы можете прочитать это как "Только владелец может уничтожить этот контракт". На практике результирующий код эквивалентен "обертыванию" кода из +onlyOwner+ вокруг +destroy+.

Модификаторы функций - чрезвычайно полезный инструмент, поскольку они позволяют нам писать предварительные условия для функций и последовательно применять их, облегчая чтение кода и, как следствие, облегчая аудит безопасности. Чаще всего они используются для контроля доступа, но они достаточно универсальны и могут использоваться для множества других целей.

Внутри модификатора вы можете получить доступ ко всем значениям (переменным и аргументам), видимым для измененной функции. В этом случае мы можем получить доступ к переменной +owner+, которая объявлена в контракте. Однако обратное неверно: вы не можете получить доступ ни к одной из переменных модификатора внутри измененной функции.

==== Наследование контрактов

((("contract object", id="ix_07smart-contracts-solidity-asciidoc14", range="startofrange")))((("inheritance", id="ix_07smart-contracts-solidity-asciidoc15", range="startofrange")))((("smart contracts","inheritance", id="ix_07smart-contracts-solidity-asciidoc16", range="startofrange")))((("Solidity","contract inheritance", id="ix_07smart-contracts-solidity-asciidoc17", range="startofrange")))Solidity контракты поддерживают _наследование_ (_inheritance_), которое представляет собой механизм расширения базового контракта дополнительными функциональными возможностями. Чтобы использовать наследование, укажите родительский контракт с ключевым словом +is+:

[source,solidity]
----
contract Child is Parent {
    ...
}
----

С помощью этой конструкции контракт +Child+ наследует все методы, функциональные возможности и переменные +Parent+. Solidity также поддерживает множественное наследование, которое может быть задано именами контрактов, разделенными запятыми, после ключевого слова +is+:

[source,solidity]
----
contract Child is Parent1, Parent2 {
    ...
}
----

Наследование контрактов позволяет нам писать наши контракты таким образом, чтобы обеспечить модульность, расширяемость и повторное использование. Мы начинаем с простых контрактов, реализующих наиболее общие возможности, затем расширяем их, наследуя эти возможности в более специализированных контрактах.

В нашем контракте +Faucet+ мы ввели конструктор и деструктор вместе с контролем доступа для владельца, назначенного в конструкторе. Эти возможности довольно универсальны: они будут присутствовать во многих контрактах. Мы можем определить их как общие контракты, а затем использовать наследование, чтобы распространить их на контракт +Faucet+.

Мы начинаем с определения базового контракта +Owned+, который имеет переменную +owner+, устанавливая ее в конструкторе контракта:

[source,solidity]
----
contract Owned {
	address owner;

	// Contract constructor: set owner
	constructor() {
		owner = msg.sender;
	}

	// Access control modifier
	modifier onlyOwner {
	    require(msg.sender == owner);
	    _;
	}
}
----

Далее мы определяем базовый контракт +Mortal+, который наследует +Owned+:

[source,solidity]
----
contract Mortal is Owned {
	// Contract destructor
	function destroy() public onlyOwner {
		selfdestruct(owner);
	}
}
----

Как вы можете видеть, контракт +Mortal+ может использовать модификатор функции +onlyOwner+, определенный в +Owned+. Он косвенно также использует переменную адреса +owner+ и конструктор, определенный в +Owned+. Наследование упрощает каждый контракт и фокусирует его на конкретной функциональности, позволяя нам управлять деталями модульным способом.

Теперь мы можем еще больше расширить контракт +Owned+, унаследовав его возможности в +Faucet+:

[source,solidity]
----
contract Faucet is Mortal {
    // Give out ether to anyone who asks
    function withdraw(uint withdraw_amount) public {
        // Limit withdrawal amount
        require(withdraw_amount <= 0.1 ether);
        // Send the amount to the address that requested it
        msg.sender.transfer(withdraw_amount);
    }
    // Accept any incoming amount
    receive () external payable {}
}
----

Наследуя +Mortal+, который, в свою очередь, наследует +Owned+, контракт +Faucet+ теперь имеет функции constructor и +destroy+, а также определенного владельца. Функциональность такая же, как и тогда, когда эти функции были в +Faucet+, но теперь мы можем повторно использовать эти функции в других контрактах, не записывая их снова. Повторное использование кода и модульность делают наш код более чистым, удобным для чтения и аудита.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc17")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc16")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc15")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc14")))

==== Обработка ошибок (assert, require, revert)

((("error handling, Solidity")))((("Solidity","error handling")))Вызов контракта может завершиться и вернуть ошибку. Обработка ошибок в Solidity выполняется четырьмя функциями: +assert+, +require+, +revert+ и +throw+ (в настоящее время устарела).

Когда контракт завершается с ошибкой, все изменения состояния (изменения переменных, балансов и т.д.) отменяются, вплоть до цепочки вызовов контрактов, если было вызвано более одного контракта. Это гарантирует, что транзакции являются _atomic_, что означает, что они либо завершаются успешно, либо не влияют на состояние и полностью отменяются.

((("assert function","Solidity and")))((("require function")))Функции +assert+ и +require+ работают одинаково, оценивая условие и останавливая выполнение с ошибкой, если условие ложно. По соглашению, +assert+ используется, когда ожидается, что результат будет истинным, что означает, что мы используем +assert+ для проверки внутренних условий. Для сравнения, +require+ используется при тестировании входных данных (таких как аргументы функции или поля транзакции), устанавливая наши ожидания для этих pass:[<span class="keep-together">условий</span>].

Мы использовали +require+ в нашем модификаторе функции +onlyOwner+, чтобы проверить, что отправитель сообщения является владельцем контракта:

[source,solidity]
----
require(msg.sender == owner);
----

Функция +require+ действует как условие _gate condition_, предотвращая выполнение остальной части функции и выдавая ошибку, если оно не выполняется.

Начиная с Solidity v0.6.0, +require+ также может содержать полезное текстовое сообщение, которое можно использовать для отображения причины ошибки. Сообщение об ошибке записывается в журнал транзакций. Итак, мы можем улучшить наш код, добавив сообщение об ошибке в нашу функцию +require+:

[source,solidity]
----
require(msg.sender == owner, "Only the contract owner can call this function");
----

((("revert function")))((("throw function")))Функции +revert+ и +throw+ останавливают выполнение контракта и отменяют любые изменения состояния. Функция +throw+ устарела и будет удалена в будущих версиях Solidity; вместо этого вам следует использовать +revert+. Функция +revert+ также может принимать сообщение об ошибке в качестве единственного аргумента, который записывается в журнал транзакций.

Определенные условия в контракте будут генерировать ошибки независимо от того, проверяем ли мы их явно. Например, в нашем контракте +Faucet+ мы не проверяем, достаточно ли эфира для удовлетворения запроса на вывод средств. Это связано с тем, что функция +transfer+ завершится с ошибкой и отменит транзакцию, если баланс будет недостаточным для осуществления перевода:

[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Однако, возможно, было бы лучше проверить явно и предоставить четкое сообщение об ошибке при сбое. Мы можем сделать это, добавив +require + условие перед передачей:

[source,solidity]
----
require(this.balance >= withdraw_amount,
        "Insufficient balance in faucet for withdrawal request");
msg.sender.transfer(withdraw_amount);
----

Дополнительный код проверки ошибок, подобный этому, немного увеличит потребление газа, но он обеспечивает лучший отчёт об ошибках, чем если бы он был опущен. Вам нужно будет найти правильный баланс между потреблением газа и подробной проверкой ошибок на основе ожидаемого использования вашего контракта. В случае контракта +Faucet+, предназначенного для тестовой сети, мы, вероятно, склонились бы в сторону дополнительной отчетности, даже если это стоит больше газа. Возможно, для контракта в главной сети мы предпочли бы быть экономными в использовании газа.

[[solidity_events]]
==== События

((("events","Solidity", id="ix_07smart-contracts-solidity-asciidoc18", range="startofrange")))((("Solidity","event objects", id="ix_07smart-contracts-solidity-asciidoc19", range="startofrange")))Когда ((("transaction receipt")))транзакция завершается (успешно или нет), она создает _отчёт о транзакции_ (_transaction receipt_), как мы увидим в <<evm_chapter>>. Отчёт транзакции содержит записи логов, которые предоставляют информацию о действиях, которые произошли во время выполнения транзакции. _События_ (_Events_) - это объекты высокого уровня Solidity, которые используются для создания этих журналов.

События особенно полезны для лёгких клиентов и приложений DApp, которые могут "следить" за конкретными событиями и сообщать о них в пользовательский интерфейс или вносить изменения в состояние приложения, чтобы отразить событие в базовом контракте.

Объекты событий принимают аргументы, которые сериализуются и записываются в журналы транзакций в блокчейне. Вы можете указать ключевое слово +indexed+ перед аргументом, чтобы сделать значение частью индексированной таблицы (хэш-таблицы), которую приложение может искать или фильтровать.

((("Faucet.sol contract (test example)","adding events to", id="ix_07smart-contracts-solidity-asciidoc20", range="startofrange")))Мы пока не добавили никаких событий в наш пример +Faucet+, так что давайте сделаем это. Мы добавим два события: одно для регистрации любых снятий средств и одно для регистрации любых депозитов. Мы будем называть эти события +Withdrawal+ и +Deposit+ соответственно. Во-первых, мы определяем события в контракте +Faucet+:

[source,solidity]
----
contract Faucet is Mortal {
	event Withdrawal(address indexed to, uint amount);
	event Deposit(address indexed from, uint amount);

    [...]
}
----

Мы решили сделать адреса +индексируемыми+ (+indexed+), чтобы разрешить поиск и фильтрацию в любом пользовательском интерфейсе, созданным для доступа к нашему +Faucet+.

Затем мы используем ключевое слово +emit+ для включения данных о событиях в журналы транзакций:

[source,solidity]
----
// Give out ether to anyone who asks
function withdraw(uint withdraw_amount) public {
    [...]
    msg.sender.transfer(withdraw_amount);
    emit Withdrawal(msg.sender, withdraw_amount);
}
// Accept any incoming amount
receive () external payable {
    emit Deposit(msg.sender, msg.value);
}
----

В результате контракт _Faucet.sol_ выглядит следующим образом <<Faucet8_sol>>.

[[Faucet8_sol]]
.Faucet8.sol: Пересмотренный контракт Faucet с событиями
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet8.sol[]
----
====

===== Отслеживание событий

((("events","catching")))((("Faucet.sol contract (test example)","catching events")))Итак, мы настроили наш контракт на выдачу событий. Как мы видим результаты транзакции и "отслеживаем" события? В web3.js библиотека предоставляет структуру данных, содержащую журналы транзакций. Внутри них мы можем видеть события, сгенерированные транзакцией.

((("Truffle","running test transaction with")))Давайте используем +truffle+ для запуска тестовой транзакции в пересмотренный контракт +Faucet+. Следуйте инструкциям в <<truffle>>, чтобы настроить каталог проекта и скомпилировать pass:[<span class="keep-together"><code>Faucet</code></span>] код. Исходный код можно найти в https://github.com/ethereumbook/ethereumbook[GitHub репозитории этой книги] в _code/truffle/FaucetEvents_.

++++
<pre data-type="programlisting">
$ <strong>truffle develop</strong>
truffle(develop)> <strong>compile</strong>
truffle(develop)> <strong>migrate</strong>
Using network 'develop'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb77ceae7c3f5afb7fbe3a6c5974d352aa844f53f955ee7d707ef6f3f8e6b4e61
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying Faucet...
  ... 0xfa850d754314c3fb83f43ca1fa6ee20bc9652d891c00a2f63fd43ab5bfb0d781
  Faucet: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...

truffle(develop)> <strong>Faucet.deployed().then(i => {FaucetDeployed = i})</strong>
truffle(develop)> <strong>FaucetDeployed.send(web3.utils.toWei(1, "ether")).then(res => \
                  { console.log(res.logs[0].event, res.logs[0].args) })</strong>
Deposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }
truffle(develop)> <strong>FaucetDeployed.withdraw(web3.utils.toWei(0.1, "ether")).then(res => \
                  { console.log(res.logs[0].event, res.logs[0].args) })</strong>
Withdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }
</pre>
++++

После развертывания контракта с помощью функции +deployed+ мы выполняем две транзакции. Первая транзакция - это депозит (с использованием +send+), который генерирует событие +Deposit+ в журналах транзакций:

----
Deposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }
----

Далее мы используем функцию +withdraw+ для вывода средств. Это вызывает событие +Withdrawal+:

----
Withdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }
----

Чтобы получить эти события, мы просмотрели массив +logs+, возвращаемый в результате (+res+) транзакций. Первая запись журнала (+logs[0]+) содержит имя события в +logs[0].event+ и аргументы события в +logs[0].args+. Показывая их на консоли, мы можем увидеть имя передаваемого события и аргументы события.

События - это очень полезный механизм не только для внутриконтрактного взаимодействия, но и для отладки во время разработки(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc20"))).(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc19")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc18")))

==== Вызов других контрактов (send, call, callcode, delegatecall)

((("smart contracts","calling other contracts from within a contract", id="ix_07smart-contracts-solidity-asciidoc21", range="startofrange")))((("Solidity","calling other contracts from within a contract", id="ix_07smart-contracts-solidity-asciidoc22", range="startofrange")))Вызов других контрактов из вашего контракта - очень полезная, но потенциально опасная операция. Мы рассмотрим различные способы, которыми вы можете достичь этого, и оценим риски каждого метода. Короче говоря, риски возникают из-за того, что вы можете мало что знать о контракте, на который вы ссылаетесь, или о том, что касается вашего контракта. При написании смарт-контрактов вы должны иметь в виду, что, хотя вы, возможно, в основном ожидаете иметь дело с EOAS, ничто не мешает произвольным, сложным и, возможно, вредоносным контрактам вызывать ваш код.

===== Создание нового экземпляра

((("smart contracts","creating new instance")))Самый безопасный способ вызвать другой контракт - это если вы создадите этот другой контракт самостоятельно. Таким образом, вы уверены в его интерфейсах и поведении. Чтобы сделать это, вы можете просто создать его экземпляр, используя ключевое слово +new+, как и в других объектно-ориентированных языках. В Solidity ключевое слово +new+ создаст контракт в блокчейне и вернет объект, который вы можете использовать для ссылки на него. Допустим, вы хотите создать и вызвать контракт +Faucet+ из другого контракта, называемого +Token+:

[role="pagebreak-before"]
[source,solidity]
----
contract Token is Mortal {
	Faucet _faucet;

    constructor() {
        _faucet = new Faucet();
    }
}
----

Этот механизм построения контракта гарантирует, что вы знаете точный тип контракта и его интерфейс. Контракт +Faucet+ должен быть определен в рамках +Token+, что вы можете сделать с помощью инструкции +import+, если определение находится в другом файле:

[source,solidity]
----
import "Faucet.sol";

contract Token is Mortal {
	Faucet _faucet;

    constructor() {
        _faucet = new Faucet();
    }
}
----

Вы можете дополнительно указать +значение+ (+value+) передачи эфира при создании и передать аргументы конструктору нового контракта:

[source,solidity]
----
import "Faucet.sol";

contract Token is Mortal {
	Faucet _faucet;

    constructor() {
        _faucet = (new Faucet).value(0.5 ether)();
    }
}
----

Затем вы также можете вызвать функции +Faucet+. В этом примере мы вызываем функцию +destroy+ для +Faucet+ из функции +destroy+ для +Token+:

[source,solidity]
----
import "Faucet.sol";

contract Token is Mortal {
	Faucet _faucet;

    constructor() {
        _faucet = (new Faucet).value(0.5 ether)();
    }

    function destroy() ownerOnly {
        _faucet.destroy();
    }
}
----

Обратите внимание, что, хотя вы являетесь владельцем контракта +Token+, сам контракт +Token+ владеет новым контрактом +Faucet+, поэтому только контракт +Token+ может его уничтожить.

===== Обращение к существующему экземпляру

((("smart contracts","addressing an existing instance")))Другой способ вызова контракта - это приведение (casting) адреса существующего экземпляра контракта. С помощью этого метода вы применяете известный интерфейс к существующему экземпляру. Поэтому крайне важно, чтобы вы точно знали, что экземпляр, к которому вы обращаетесь, на самом деле относится к тому типу, который вы предполагаете. Давайте рассмотрим пример:

[source,solidity]
----
import "Faucet.sol";

contract Token is Mortal {

    Faucet _faucet;

    constructor(address _f) {
        _faucet = Faucet(_f);
        _faucet.withdraw(0.1 ether);
    }
}
----

Здесь мы берем адрес, предоставленный в качестве аргумента конструктору, +_f+, и приводим его к объекту +Faucet+. Это намного более рискованно, чем предыдущий механизм, потому что мы не знаем наверняка, действительно ли этот адрес является объектом +Faucet+. Когда мы вызываем +withdraw+, мы предполагаем, что он принимает те же аргументы и выполняет тот же код, что и наше объявление +Faucet+, но мы не можем быть уверены. Насколько нам известно, функция +withdraw+ по этому адресу может выполнить что-то совершенно отличное от того, что мы ожидаем, даже если она названа так же. Поэтому использование адресов, переданных в качестве входных данных, и приведение их к определенным объектам гораздо опаснее, чем самостоятельное создание контракта.

===== Необработанный вызов, делегированный вызов (delegatecall)

Solidity предлагает некоторые еще более "низкоуровневые" функции для вызова других контрактов. Они непосредственно соответствуют кодам операций EVM с тем же именем и позволяют нам создавать вызов от контракта к контракту вручную. Как таковые, они представляют собой наиболее гибкие и наиболее опасные механизмы для вызова других контрактов.

((("smart contracts","call method", id="ix_07smart-contracts-solidity-asciidoc23", range="startofrange")))Вот тот же пример, с использованием метода +call+:

[source,solidity]
----
contract Token is Mortal {
	constructor(address _faucet) {
		_faucet.call("withdraw", 0.1 ether);
	}
}
----

((("blind calls")))Как вы можете видеть, данный способ выхова представляет собой _blind_ вызов функции, очень похожий на построение необработанной транзакции, только из контекста контракта. ((("reentrancy attacks","blind calls and")))Это может подвергнуть ваш контракт ряду рисков безопасности, наиболее важным из которых является _reentrancy_ (повторный вход), которые мы обсудим более подробно в разделе <<reentrancy_security>>. Функция +call+ вернет +false+, если есть проблема, так что вы можете оценить возвращаемое значение для обработки ошибок:

[source,solidity]
----
contract Token is Mortal {
	constructor(address _faucet) {
		if !(_faucet.call("withdraw", 0.1 ether)) {
			revert("Withdrawal from faucet failed");
		}
	}
}
----

((("delegatecall method")))((("smart contracts","delegatecall method")))Другим вариантом +call+ является +delegatecall+, который заменил более опасный +callcode+. Метод pass:[<code><span class="keep-together">callcode</span></code>] скоро устареет, поэтому его не следует использовать.

Как упоминалось в <<solidity_address_object>>, +delegatecall+ отличается от +call+ тем, что контекст +msg+ не изменяется. Например, в то время как +call+ изменяет значение +msg.sender+ на вызывающий контракт, a +delegatecall+ сохраняет то же значение +msg.sender+, что и в вызывающем контракте. По сути, +delegatecall+ запускает код другого контракта в контексте выполнения текущего контракта. Чаще всего он используется для вызова кода из библиотеки. Это также позволяет вам использовать шаблон использования библиотечных функций, хранящихся в другом месте, но заставить этот код работать с данными хранилища вашего контракта.

Вызов +delegatecall+ следует использовать с большой осторожностью. Это может иметь некоторые неожиданные последствия, особенно если вызываемый вами контракт не был разработан как библиотека.

Давайте воспользуемся примером контракта, чтобы продемонстрировать различную семантику вызовов, используемую +call+ и +delegatecall+ для вызова библиотек и контрактов. В <<call_examples_code>> мы используем событие для регистрации деталей каждого вызова и просмотра того, как меняется контекст вызова в зависимости от типа вызова.

[[call_examples_code]]
.CallExamples.sol: Пример разных call семантик 
====
[source,solidity,linenums]
----
include::code/truffle/CallExamples/contracts/CallExamples.sol[]
----
====

Как вы можете видеть в этом примере, нашим основным контрактом является +caller+, который вызывает библиотеку +calledLibrary+ и контракт +calledContract+. Вызываемая библиотека и контракт имеют идентичные функции +calledFunction+, которые выдают событие +callEvent+. Событие +callEvent+ регистрирует три фрагмента данных: +msg.sender+, +tx.origin+ и +this+. Каждый раз, когда вызывается +calledFunction+, у нее может быть другой контекст выполнения (с разными значениями возможно для всех переменных контекста), в зависимости от того, вызывается ли она напрямую или через +delegatecall+.

В +caller+ мы сначала вызываем контракт и библиотеку напрямую, вызывая +calledFunction+ в каждом из них. Затем мы явно используем низкоуровневые функции +call+ и +delegatecall+ для вызова +calledContract.calledFunction+. Таким образом, мы можем видеть, как ведут себя различные механизмы вызова.

Давайте запустим это в среде разработки Truffle и отловим события, чтобы посмотреть, как это выглядит:

++++
<pre data-type="programlisting">
truffle(develop)> <strong>migrate</strong>
Using network 'develop'.
[...]
Saving artifacts...
truffle(develop)> <strong>(await web3.eth.getAccounts())[0]</strong>
'0x627306090abab3a6e1400e9345bc60c78a8bef57'
truffle(develop)> <strong>caller.address</strong>
'0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f'
truffle(develop)> <strong>calledContract.address</strong>
'0x345ca3e014aaf5dca488057592ee47305d9b3e10'
truffle(develop)> <strong>calledLibrary.address</strong>
'0xf25186b5081ff5ce73482ad761db0eb0d25abfbf'
truffle(develop)> <strong>caller.deployed().then( i => { callerDeployed = i })</strong>

truffle(develop)> <strong>callerDeployed.make_calls(calledContract.address).then(res => \
                  { res.logs.forEach( log => { console.log(log.args) })})</strong>
{ sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10' }
{ sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f' }
{ sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10' }
{ sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f' }
</pre>
++++

Давайте посмотрим, что здесь произошло. Мы вызвали функцию +make_calls+ и передали адрес +calledContract+, затем перехватили четыре события, вызванные каждым из разных вызовов. Давайте посмотрим на функцию +make_calls+ и пройдемся по каждому шагу.

Первый вызов - это:

----
_calledContract.calledFunction();
----

Здесь мы вызываем +calledContract.calledFunction+ напрямую, используя высокоуровневый ABI для +calledFunction+. Генерируемое событие:

----
sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10'
----

Как вы можете видеть, +msg.sender+ - это адрес +вызывающего+ контракта. +tx.origin+ - это адрес нашей учетной записи, +web3.eth.accounts[0]+, которая отправила транзакцию на +caller+. Событие было вызвано +calledContract+, как мы можем видеть из последнего аргумента в событии.

Следующий вызов в +make_calls+ относится к библиотеке:

----
calledLibrary.calledFunction();
----

Он выглядит идентично тому, как мы назвали контракт, но ведет себя совсем по-другому. Давайте посмотрим на второе событие.:

----
sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f'
----

На этот раз +msg.sender+ не является адресом +caller+ (того, кто вызвал контракт). Вместо этого это адрес нашей учетной записи, который совпадает с источником транзакции. Это потому, что когда вы вызываете библиотеку, вызов происходит всегда через +delegatecall+ и выполняется в контексте caller. Итак, когда код +calledLibrary+ был запущен, он унаследовал контекст выполнения +caller+, как если бы его код выполнялся внутри +caller+. Переменная +this+ (показанная как +from+ в генерируемом событии) является адресом +caller+, даже если доступ к ней осуществляется из pass:[<span class="keep-together"><code>calledLibrary</code></span>].

Следующие два вызова, используя низкоуровневые +call + и +delegatecall+, подтверждают наши ожидания, посылая события, которые отражают то, что мы только что  (((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc23"))) видели(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc22")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc21"))).(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc10")))

[[gas_sec]]
=== Рассуждения о газе

((("gas","conserving", id="ix_07smart-contracts-solidity-asciidoc24", range="startofrange")))((("smart contracts","gas considerations", id="ix_07smart-contracts-solidity-asciidoc25", range="startofrange")))((("Solidity","gas considerations", id="ix_07smart-contracts-solidity-asciidoc26", range="startofrange")))Газ, более подробно описанный в <<газ>>, является невероятно важным фактором в программировании смарт-контрактов. Газ - это ресурс, ограничивающий максимальный объем вычислений, который Ethereum позволит использовать транзакции. Если во время вычисления превышен предел газа, происходит следующая серия событий:

* Выдается исключение "кончился газ".
* Состояние контракта восстанавливается как было до исполнения (reverted).
* Весь эфир, использованный для оплаты газа, берется в качестве комиссии за транзакцию; он не возвращается.

Поскольку газ оплачивается пользователем, который инициирует транзакцию, пользователи не любят вызывать функции, которые имеют высокую стоимость газа. Таким образом, в интересах программиста минимизировать затраты на газ, связанные с функциями контракта. С этой целью существуют определенные практики, которые рекомендуются при построении смарт-контрактов, чтобы минимизировать затраты на газ при вызове функции.

==== Избегайте массивов динамического размера

((("dynamically sized arrays")))((("gas","dynamically sized arrays and")))Любой цикл по массиву динамического размера, в котором функция выполняет операции над каждым элементом или выполняет поиск определенного элемента, создает риск использования слишком большого количества газа. Действительно, контракт может истратить газ до того, как будет найден желаемый результат, или до того, как будут предприняты действия по каждому элементу, таким образом, будет тратить время и эфир, не давая никакого результата вообще.

==== Избегайте вызовов других контрактов

((("gas","avoiding calls to other contracts")))Обращение к другим контрактам, особенно когда стоимость газа для их функций неизвестна, создает риск нехватки газа. Избегайте использования библиотек, которые недостаточно хорошо протестированы и не используются широко. Чем меньше внимания библиотека получила от других программистов, тем выше риск ее использования.

==== Оценка стоимости газа

((("gas","estimating cost of", id="ix_07smart-contracts-solidity-asciidoc27", range="startofrange")))Если вам нужно оценить газ, необходимый для выполнения определенного метода контракта, учитывая его аргументы, вы можете использовать следующую процедуру:

[source, javascript]
var contract = web3.eth.contract(abi).at(address);
var gasEstimate = contract.myAweSomeMethod.estimateGas(arg1, arg2,
    {from: account});

+gasEstimate+ сообщит вам количество единиц газа, необходимых для его выполнения. Это только оценка, так как из-за полноты EVM по Тьюрингу относительно тривиально создать функцию, для выполнения разных вызовов которой потребуется значительно различное количество газа. Даже производственный код может незаметно изменять пути выполнения, что приводит к огромным различиям в затратах на газ от одного вызова к следующему. Тем не менее, большинство функций являются разумными, и +estimateGas+ даст хорошую оценку большую часть времени.

Чтобы получить цену на газ из сети, вы можете использовать:

[source, javascript]
var gasPrice = web3.eth.getGasPrice();

И оттуда вы можете оценить стоимость газа:

[source, javascript]
var gasCostInEther = web3.utils.fromWei((gasEstimate * gasPrice), 'ether');

Давайте применим наши функции оценки газа для оценки стоимости газа в нашем примере +Faucet +, используя код http://bit.ly/2zf0SIO[из репозитория книги].

Запустите Truffle в режиме разработки и запустите файл JavaScript <<estimateGas_function>> – _gas_estimates.js_.

[source, javascript]
[[estimateGas_function]]
.gas_estimates.js: Использование функции estimateGas
====
[source,javascript]
----
var FaucetContract = artifacts.require("./Faucet.sol");

FaucetContract.web3.eth.getGasPrice(function(error, result) {
    var gasPrice = Number(result);
    console.log("Gas Price is " + gasPrice + " wei"); // "10000000000000"

    // Get the contract instance
    FaucetContract.deployed().then(function(FaucetContractInstance) {

		// Use the keyword 'estimateGas' after the function name to get the gas
		// estimation for this particular function (aprove)
		FaucetContractInstance.send(web3.utils.toWei(1, "ether"));
        return FaucetContractInstance.withdraw.estimateGas(web3.utils.toWei(0.1, "ether"));

    }).then(function(result) {
        var gas = Number(result);

        console.log("gas estimation = " + gas + " units");
        console.log("gas cost estimation = " + (gas * gasPrice) + " wei");
        console.log("gas cost estimation = " +
                FaucetContract.web3.utils.fromWei((gas * gasPrice), 'ether') + " ether");
    });
});
----
====

Вот как это выглядит в консоли разработки Truffle:

++++
<pre data-type="programlisting">
$ <strong>truffle develop</strong>

truffle(develop)> <strong>exec gas_estimates.js</strong>
Using network 'develop'.

Gas Price is 20000000000 wei
gas estimation = 31397 units
gas cost estimation = 627940000000000 wei
gas cost estimation = 0.00062794 ether
</pre>
++++

Рекомендуется оценивать стоимость функций как часть рабочего процесса разработки, чтобы избежать каких-либо неожиданностей при развертывании контрактов в основной сети(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc27"))).(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc26")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc25")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc24")))

=== Заключение

В этой главе мы начали подробно работать со смарт-контрактами и изучили язык программирования Solidity contract.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc4")))(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc3"))) Мы взяли простой пример контракта, _Faucet.sol_, и постепенно улучшали его и усложняли, используя для изучения различных аспектов языка Solidity. В <<vyper_chap>> мы будем работать с Vyper, другим контрактно-ориентированным языком программирования. Мы сравним Vyper с Solidity, показав некоторые различия в дизайне этих двух языков и углубив наше понимание программирования смарт-контрактов.(((range="endofrange", startref="ix_07smart-contracts-solidity-asciidoc0")))

[[vyper_chap]]
== Смарт-контракты и Vyper

((("Vyper", id="ix_08smart-contracts-vyper-asciidoc0", range="startofrange")))Vyper - это экспериментальный, ориентированный на контракты язык программирования для виртуальной машины Ethereum, который стремится обеспечить превосходную проверяемость, упрощая разработчикам создание понятного кода. На самом деле, один из принципов Vyper заключается в том, чтобы сделать практически невозможным для разработчиков написание вводящего в заблуждение кода.

В этой главе мы рассмотрим общие проблемы со смарт-контрактами, представим язык программирования контрактов Vyper и сравним его с Solidity, продемонстрировав различия.

=== Уязвимости и Vyper

https://arxiv.org/pdf/1802.06038.pdf[Недавнее исследование] ((("vulnerabilities", seealso="security; specific attacks/vulnerabilities")))((("Vyper","contract vulnerabilities and")))проанализировало почти миллион развернутых смарт-контрактов Ethereum и обнаружило, что многие из этих контрактов содержат серьезные уязвимости. В ходе своего анализа исследователи выделили три основные категории уязвимостей:

Самоубийственные контракты:: Смарт-контракты, которые могут быть уничтожены произвольными адресами

Жадные контракты:: Смарт-контракты, которые могут достичь состояния, в котором они не могут освободить эфир

Блудные контракты:: Смарт-контракты, которые могут отправить эфир на произвольные адресам

Уязвимости вводятся в смарт-контракты с помощью кода. Можно решительно утверждать, что эти и другие уязвимости вводятся не намеренно, но, несмотря на это, нежелательный код смарт-контракта, очевидно, приводит к неожиданной потере средств для пользователей Ethereum, и это не идеально. Vyper разработан для того, чтобы упростить написание защищенного кода или в равной степени затруднить случайное написание вводящего в заблуждение или уязвимого кода.

[[comparison_to_solidity_sec]]
=== Сравнение с Solidity

((("Solidity","Vyper compared to", id="ix_08smart-contracts-vyper-asciidoc1", range="startofrange")))((("Vyper","Solidity compared to", id="ix_08smart-contracts-vyper-asciidoc2", range="startofrange")))Один из способов, с помощью которого Vyper пытается усложнить написание небезопасного кода, - это намеренное отсутствие некоторых функций Solidity. Тем, кто рассматривает возможность разработки смарт-контрактов в Vyper, важно понять, какими функциями Vyper не обладает и почему. Поэтому в этом разделе мы рассмотрим эти функции и приведем обоснование того, почему они были опущены.

==== Модификаторы

((("modifiers")))((("Solidity","modifiers")))((("Vyper","modifiers")))Как мы видели в предыдущей главе, в Solidity вы можете написать функцию, используя модификаторы. Например, следующая функция, `changeOwner`, будет запускать код в модификаторе с именем `onlyBy` как часть своего выполнения:

[source,javascript]
----
function changeOwner(address _newOwner)
    public
    onlyBy(owner)
{
    owner = _newOwner;
}
----

Этот модификатор обеспечивает соблюдение правила в отношении владения. Как вы можете видеть, этот конкретный модификатор действует как механизм для выполнения предварительной проверки от имени функции `changeOwner`:

[source,javascript]
----
modifier onlyBy(address _account)
{
    require(msg.sender == _account);
    _;
}
----

Но модификаторы существуют не только для выполнения проверок, как показано здесь. Фактически, как модификаторы, они могут значительно изменить среду смарт-контракта в контексте вызывающей функции. Проще говоря, модификаторы являются _проникающими_ (_pervasive_).

Давайте посмотрим на другой пример в стиле Solidity:

[source, javascript]
----
enum Stages {
    SafeStage,
    DangerStage,
    FinalStage
}

uint public creationTime = now;
Stages public stage = Stages.SafeStage;

function nextStage() internal {
    stage = Stages(uint(stage) + 1);
}

modifier stageTimeConfirmation() {
    if (stage == Stages.SafeStage &&
                now >= creationTime + 10 days)
        nextStage();
    _;
}

function a()
    public
    stageTimeConfirmation
    // More code goes here
{
}
----

С одной стороны, разработчики всегда должны проверять любой другой код, который вызывает их собственный код. Однако возможно, что в определенных ситуациях (например, когда нехватка времени или истощение приводят к отсутствию концентрации) разработчик может пропустить одну строку кода. Это еще более вероятно, если разработчику приходится перемещаться внутри большого файла, мысленно отслеживая иерархию вызовов функций и фиксируя состояние переменных смарт-контракта в памяти.

Давайте рассмотрим предыдущий пример немного подробнее. Представьте, что разработчик пишет общедоступную функцию с именем `a`. Разработчик является новичком в этом контракте и использует модификатор, написанный кем-то другим. На первый взгляд кажется, что модификатор `stageTimeConfirmation` просто выполняет некоторые проверки относительно возраста контракта по отношению к вызывающей функции. Чего разработчик может _не_ понимать, так это того, что модификатор также вызывает другую функцию, `nextStage`. В этом упрощенном демонстрационном сценарии простой вызов общедоступной функции "a" приводит к тому, что переменная "stage" смарт-контракта перемещается с "SafeStage" на "DangerStage".

Vyper полностью отказался от модификаторов. Рекомендации от Vyper заключаются в следующем: если вы выполняете с модификаторами только проверки, то просто используйте встроенные проверки и утверждения как часть функции; если вы изменяете состояние смарт-контракта и так далее, снова сделайте эти изменения явно частью функции. Выполнение этого улучшает проверяемость и удобочитаемость, поскольку читателю не нужно мысленно (или вручную) "оборачивать" код модификатора вокруг функции, чтобы увидеть, что она делает.

==== Наследование классов

((("class inheritance")))((("inheritance")))((("Solidity","class inheritance")))((("Vyper","class inheritance")))Наследование позволяет программистам использовать возможности предварительно написанного кода, приобретая ранее существовавшие функциональные возможности, свойства и поведение из существующих программных библиотек. Наследование является мощным средством и способствует повторному использованию кода. Solidity поддерживает множественное наследование, а также полиморфизм, но, хотя это ключевые особенности объектно-ориентированного программирования, Vyper их не поддерживает. Vyper утверждает, что реализация наследования требует, чтобы программисты и аудиторы переходили между несколькими файлами, чтобы понять, что делает программа. Vyper также придерживается мнения, что множественное наследование может сделать код слишком сложным для понимания &#x2014; точка зрения, молчаливо признаваемая Solidity http://bit.ly/2Q6Azvo[документацией], в которой приводится пример того, как множественное наследование может быть проблематичным.

==== Встроенная сборка (Inline assembly)

((("inline assembly")))((("inline assembly","Solidity compared to Vyper")))((("Solidity inline assembly")))Встроенная сборка предоставляет разработчикам низкоуровневый доступ к виртуальной машине Ethereum, позволяя программам Solidity выполнять операции путем прямого доступа к инструкциям EVM. Например, следующий встроенный ассемблерный код добавляет 3 к ячейке памяти +0x80+:

----
3 0x80 mload add 0x80 mstore
----

Vyper считает потерю удобочитаемости слишком высокой ценой за дополнительную мощность и поэтому не поддерживает встроенную сборку.

==== Перегрузка функций

((("function overloading")))((("Solidity","function overloading")))((("Vyper","function overloading")))Перегрузка функций позволяет разработчикам писать несколько функций с одним и тем же именем. Какая функция используется в данном случае, зависит от типов предоставляемых аргументов. Возьмем, к примеру, следующие две функции:

[source,javascript]
----
function f(uint _in) public pure returns (uint out) {
    out = 1;
}

function f(uint _in, bytes32 _key) public pure returns (uint out) {
    out = 2;
}
----

Первая функция (с именем +f+) принимает входной аргумент типа +uint+; вторая функция (также с именем +f+) принимает два аргумента, один типа +uint+ и один типа +bytes32+. Наличие нескольких определений функций с одинаковым именем, принимающих разные аргументы, может привести к путанице, поэтому Vyper не поддерживает перегрузку функций.

==== Приведение типов переменных

((("Solidity","variable typecasting")))((("typecasting")))((("Vyper","variable typecasting")))Существует два вида приведения типов: _не явное_ (_implicit_) и _явное_ (_explicit_).

((("implicit typecasting")))Неявное приведение типов часто выполняется во время компиляции. Например, если преобразование типа является семантически обоснованным и никакая информация, вероятно, не будет потеряна, компилятор может выполнить неявное преобразование, такое как преобразование переменной типа +uint8+ в +uint16+. Самые ранние версии Vyper допускали неявное приведение типов переменных, но последние версии этого не делают.

((("explicit typecasting")))Явные приведения типов типов могут быть вставлены в Solidity. К сожалению, они могут привести к неожиданному поведению. Например, приведение +uint32+ к меньшему типу +uint16+ просто удаляет биты более высокого порядка, как показано здесь:

[source,javascript]
----
uint32 a = 0x12345678;
uint16 b = uint16(a);
// Variable b is 0x5678 now
----

((("convert function (Vyper)")))Вместо этого Vyper имеет функцию +convert+ для выполнения явных приведений. Функция преобразования (находится в строке 82 из https://bit.ly/2Nnjy3I[_convert.py_]):

[source,python]
----
def convert(expr, context):
    output_type = expr.args[1].s
    if output_type in conversion_table:
        return conversion_table[output_type](expr, context)
    else:
        raise Exception("Conversion to {} is invalid.".format(output_type))
----

Обратите внимание на использование +conversion_table+ (находится в строке 90 того же файла), который выглядит следующим образом:

[source,python]
----
conversion_table = {
    'int128': to_int128,
    'uint256': to_unint256,
    'decimal': to_decimal,
    'bytes32': to_bytes32,
}
----

Когда разработчик вызывает +convert+, он ссылается на +conversion_table+, что гарантирует выполнение соответствующего преобразования. Например, если разработчик передает +int128+ в функцию +convert+, будет выполнена функция +to_int128+ в строке 26 того же файла (_convert.py_). Функция +to_int128+ выглядит следующим образом:

[source,python]
----
@signature(('int128', 'uint256', 'bytes32', 'bytes'), 'str_literal')
def to_int128(expr, args, kwargs, context):
    in_node = args[0]
    typ, len = get_type(in_node)
    if typ in ('int128', 'uint256', 'bytes32'):
        if in_node.typ.is_literal 
            and not SizeLimits.MINNUM <= in_node.value <= SizeLimits.MAXNUM:
            raise InvalidLiteralException(
                "Number out of range: {}".format(in_node.value), expr
            )
        return LLLnode.from_list(
            ['clamp', ['mload', MemoryPositions.MINNUM], in_node,
            ['mload', MemoryPositions.MAXNUM]], typ=BaseType('int128'),
            pos=getpos(expr)
        )
    else:
        return byte_array_to_num(in_node, expr, 'int128')
----

Как вы можете видеть, процесс преобразования гарантирует, что никакая информация не может быть потеряна; если это возможно, возникает исключение. Код преобразования предотвращает усечение, а также другие аномалии, которые обычно допускаются неявным приведением типов.

Выбор явного, а не неявного приведения типов означает, что разработчик несет ответственность за выполнение всех приведений. Хотя такой подход действительно создает более подробный код, он также повышает безопасность и проверяемость смарт-контрактов.

==== Бесконечный цикл
((("infinite loop")))((("Solidity","infinite loop")))((("Vyper","infinite loop")))Хотя из-за gaslimit нет никаких последствий, разработчики могут написать бесконечный цикл в Solidity. Бесконечный цикл делает невозможным установить верхнюю границу пределов газа, открывая дверь для атак с ограничением газа. Таким образом, Vyper не позволяет вам написать подобное и имеет следующие три функции:

Оператор `while`::
вы можете использовать оператор `while` в Solidity, но в Vyper этого оператора нет.

Детерминированное число итераций оператора `for`::
У Vyper есть оператор `for`, но верхний предел числа итераций должен быть определен, а `range ()` может принимать только целочисленные литералы.

Рекурсивный вызов::
Рекурсивный вызов может быть записан в Solidity, но не в Vyper.

==== Предварительные условия и Постусловия

((("Vyper","preconditions/postconditions")))Vyper явно обрабатывает предварительные условия, постусловия и изменения состояния. Хотя это приводит к избыточному коду, это также обеспечивает максимальную читаемость и безопасность. При написании смарт-контракта в Vyper разработчик должен соблюдать следующие три пункта:

Состояние::
Каково текущее состояние переменных состояния Ethereum?
Эффекты::
Какое влияние этот код смарт-контракта окажет на состояние переменных состояния Ethereum при выполнении? То есть, что будет затронуто, а что не будет затронуто? Согласуются ли эти эффекты с намерениями смарт-контракта?
Взаимодействие::
После того, как первые два соображения были исчерпывающе рассмотрены, пришло время запустить код. Перед развертыванием логически пройдитесь по коду и рассмотрите все возможные постоянные результаты, последствия и сценарии выполнения кода, включая взаимодействие с другими контрактами.

В идеале каждый из этих пунктов должен быть тщательно рассмотрен, а затем тщательно задокументирован в коде. Это улучшит дизайн кода, в конечном счете сделав его более читаемым и проверяемым.(((range="endofrange", startref="ix_08smart-contracts-vyper-asciidoc2")))(((range="endofrange", startref="ix_08smart-contracts-vyper-asciidoc1")))

[[decorators_sec]]
=== Декораторы
((("decorators, Vyper")))((("Vyper","decorators")))В начале каждой функции могут использоваться следующие декораторы:

+@private+:: Декоратор `@private` делает функцию недоступной извне контракта.

+@public+:: Декоратор `@public` делает функцию как видимой, так и исполняемой публично. Например, даже кошелек Ethereum будет отображать такие функции при просмотре контракта.

+@constant+:: Функциям с декоратором `@constant` не разрешается изменять переменные состояния. Фактически, компилятор отклонит всю программу (с соответствующей ошибкой), если функция попытается изменить переменную состояния.

+@payable+:: Передавать эфир разрешено только функциям с декоратором `@payable`.

Vyper реализует http://bit.ly/2P14RDq[логику декораторов] явно. Например, процесс компиляции Vyper завершится неудачей, если функция имеет как декоратор `@payable`, так и декоратор `@constant`. Это имеет смысл, потому что функция, которая передает значение, по определению обновила состояние, поэтому не может быть `@constant`. Каждая функция Vyper должна быть оформлена либо `@public`, либо `@private` (но не обоими!).

[[order_of_functions_sec]]
=== Упорядочение функций и переменных

((("function declarations, ordering of")))((("Solidity","function ordering")))((("Solidity","variable ordering")))((("variable declarations, ordering of")))((("Vyper","function ordering")))((("Vyper","variable ordering")))Каждый отдельный смарт-контракт Vyper состоит только из одного файла Vyper. Другими словами, весь код данного смарт-контракта Vyper, включая все функции, переменные и так далее, существует в одном месте. Vyper требует, чтобы объявления функций и переменных каждого смарт-контракта физически записывались в определенном порядке. У Solidity вообще нет этого требования. Давайте быстро взглянем на пример солидности

[source,javascript]
----
pragma solidity ^0.4.0;

contract ordering {

    function topFunction()
    external
    returns (bool) {
        initiatizedBelowTopFunction = this.lowerFunction();
        return initiatizedBelowTopFunction;
    }

    bool initiatizedBelowTopFunction;
    bool lowerFunctionVar;

    function lowerFunction()
    external
    returns (bool) {
        lowerFunctionVar = true;
        return lowerFunctionVar;
    }

}
----

В этом примере функция с именем +topFunction+ вызывает другую функцию +lowerFunction+. +topFunction+ также присваивает значение переменной с именем +initiatizedBelowTopFunction+. Как вы можете видеть, Solidity не требует, чтобы эти функции и переменные были физически объявлены перед вызовом исполняющего кода. Это работающий код Solidity, который будет успешно скомпилирован.

Требования к порядку Vyper не являются чем-то новым; на самом деле, эти требования к порядку всегда присутствовали в программировании на Python. Порядок, требуемый Vyper, прост и логичен, как показано в следующем примере:

[source,python]
----
# Declare a variable called theBool
theBool: public(bool)

# Declare a function called topFunction
@public
def topFunction() -> bool:
    # Assign a value to the already declared variable called theBool
    self.theBool = True
    return self.theBool

# Declare a function called lowerFunction
@public
def lowerFunction():
    # Call the already declared function called topFunction
    assert self.topFunction()
----

Это показывает правильный порядок функций и переменных в смарт-контракте Vyper. Обратите внимание, как переменная +theBool+ и функция +topFunction+ объявляются до того, как им присваивается значение и вызывается соответственно. Если +theBool+ был объявлен ниже +topFunction+ или если +topFunction+ был объявлен ниже +lower Function+, этот контракт не будет компилироваться.

[[online_code_editor_and_compiler_sec]]
=== Компиляция
((("compiling","Vyper")))((("Vyper","compilation")))У Vyper есть свой собственный https://vyper.online[онлайн-редактор кода и компилятор], который позволяет вам писать, а затем компилировать ваши смарт-контракты в байт-код, ABI и LLL, используя только ваш веб-браузер. Онлайн-компилятор Vyper имеет множество предварительно написанных смарт-контрактов для вашего удобства, включая контракты на простой открытый аукцион, безопасные удаленные покупки, токены ERC20 и многое другое. Этот инструмент предлагает только одну версию программного обеспечения для компиляции. Он регулярно обновляется, но не всегда гарантирует наличие последней версии. Etherscan имеет https://etherscan.io/vyper[онлайн-компилятор Vyper], который позволяет вам выбрать версию компилятора. Также https://remix.ethereum.org[Remix], первоначально разработанный для смарт-контрактов Solidity, теперь имеет плагин Vyper, доступный на вкладке настроек.

[NOTE]
====
((("ERC20 token standard","Vyper implementation of")))Vyper реализует ERC20 в виде предварительно скомпилированного контракта, что позволяет легко использовать эти смарт-контракты "из коробки". Контракты в Vyper должны быть объявлены как глобальные переменные. Пример объявления переменной ERC20 выглядит следующим образом:

[source,javascript]
----
token: address(ERC20)
----
====

Вы также можете скомпилировать контракт с помощью командной строки. Каждый контракт Vyper сохраняется в одном файле с расширением _.vy_.
После установки вы можете скомпилировать контракт с Vyper, выполнив следующую команду:

----
vyper ~/hello_world.vy
----

Удобочитаемое описание ABI (в формате JSON) затем можно получить, выполнив следующую команду:

----
vyper -f json ~/hello_world.v.py
----

[[protecting_against_overflows_sec]]
=== Защита от ошибок переполнения на уровне компилятора

((("compiling","protecting against overflow errors at the compiler level")))((("overflow","protecting against")))((("Vyper","overflow protection")))Ошибки переполнения в программном обеспечении могут быть катастрофическими при работе с реальным значением. Например, одна http://bit.ly/2yHfvoF[транзакция с середины апреля 2018 года] показывает pass:[<span class="keep-together">вредоноснаую передачу более 57,896,044,618,658,100,000,000,000,000,000,000,000,000,&thinsp;</span>]000,000,000,000,000,000 BEC токенов. Эта транзакция была результатом проблемы с переполнением целых чисел в контракте токена ERC20 BeautyChain (_BecToken.sol_). Разработчики Solidity имеют доступ к таким библиотекам, как http://bit.ly/2ABhb4l[+SafeMath+], а также инструменты анализа безопасности смарт-контрактов Ethereum, такие как http://bit.ly/2CQRoGU[Mythril OSS]. Однако разработчики не обязаны использовать инструменты безопасности. Проще говоря, если безопасность не обеспечивается языком, разработчики могут написать небезопасный код, который будет успешно компилироваться, а затем "успешно" выполняться.

Vyper имеет встроенную защиту от переполнения, реализованную в двух направлениях. Во-первых, Vyper обеспечивает http://bit.ly/2PuDfpB[+SafeMath+ эквивалент], который включает в себя необходимые случаи исключения для целочисленной арифметики. Во-вторых, Vyper использует зажимы (clamps) всякий раз, когда загружается литеральная константа, передается значение функции или присваивается переменная. Зажимы реализуются с помощью специальных функций в компиляторе Low-level Lisp-like Language (LLL) и не могут быть отключены. (Компилятор Vyper выводит LLL, а не байт-код EVM; это упрощает разработку самого Vyper.)


[[reading_and_writing_data_sec]]
=== Чтение и запись данных
((("Vyper","reading/writing data")))Хотя хранение, чтение и изменение данных обходится дорого, эти операции хранения являются необходимым компонентом большинства смарт-контрактов. Смарт-контракты могут записывать данные в два места:

Глобальное состояние:: ((("global state trie")))Переменные состояния в данном смарт-контракте хранятся в глобальной таблице состояний Ethereum; смарт-контракт может хранить, считывать и изменять данные только в отношении адреса этого конкретного контракта (т.е. смарт-контракты не могут считывать или записывать в другие смарт-контракты).

Журналы:: ((("logs, Vyper")))Смарт-контракт также может записывать данные цепочки Ethereum через события журнала. В то время как Vyper изначально использовал синтаксис pass:[<code>__log__</code>] для объявления этих событий, было внесено обновление, которое приводит его объявление событий в большее соответствие с оригинальным синтаксисом Solidity. Например, объявление Vyper события с именем `MyLog` изначально было `MyLog: pass:[__]logpass:[__]({arg1: indexed(bytes[3])})`. Синтаксис теперь стал `MyLog: event({arg1: indexed(bytes[3])})`. Важно отметить, что выполнение события log в Vyper было и остается следующим: `log.MyLog("123")`.

В то время как смарт-контракты могут записывать данные цепочки Ethereum (через события журнала), они не могут читать созданные ими события журнала в цепочке. Несмотря на это, одним из преимуществ записи в цепочку данных Ethereum с помощью событий журнала является то, что легкие клиенты могут обнаруживать и считывать журналы в общедоступной цепочке. Например, значение +logsBloom+ в добытом блоке может указывать, присутствует ли событие журнала или нет. Как только установлено существование событий журнала, данные журнала могут быть получены из данной квитанции (receipt) транзакции.


=== Заключение

Vyper - это мощный и интересный новый контрактно-ориентированный язык программирования. Его дизайн смещен в сторону "корректности" в ущерб некоторой гибкости. Это может позволить программистам писать более совершенные смарт-контракты и избегать определенных ловушек, которые приводят к возникновению серьезных уязвимостей. Далее мы более подробно рассмотрим безопасность смарт-контрактов. Некоторые нюансы дизайна Vyper могут стать более очевидными, как только вы прочтете обо всех возможных проблемах безопасности, которые могут возникнуть в смарт-контрактах.(((range="endofrange", startref="ix_08smart-contracts-vyper-asciidoc0")))

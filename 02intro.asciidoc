[[intro_chapter]]
== Основы Эфириума

((("Ethereum (generally)","basics", id="ix_02intro-asciidoc0", range="startofrange")))В этой главе мы начнем изучать Ethereum, узнаем, как использовать электронные кошельки, как создавать транзакции, а также как запускать базовый смарт-контракт.

[[ether_units]]
=== Валютные единицы Эфира

((("currency units")))((("Ethereum (generally)","currency units")))Денежная единица Ethereum называется _эфир_ (_ether_), обозначается также как "ETH" или символами &#926; (от греческой буквы "Xi", которая выглядит как стилизованная заглавная буква E) или, реже, &#9830;: например, 1 эфир, или 1 ETH, или &#926;1 или &#9830;1.

[TIP]
====
Используйте символ Юникода +U+039E+ для &#926; и +U+2666+ для &#9830;.
====

Эфир подразделяется на более мелкие единицы, вплоть до наименьшей возможной единицы, которая называется _wei_. Один эфир равен 1 квинтиллиону вей (1 * 10^18^ или 1 000 000 000 000 000 000 000). Вы можете услышать, что люди тоже называют валюту "Эфириум", но это распространенная ошибка новичков. Эфириум - это система, эфир - это валюта.

Значение эфира всегда представлено внутри Ethereum в виде целого числа без знака, выраженного в wei. Когда вы совершаете транзакцию 1-ого эфира, транзакция кодирует 1000000000000000000 wei в качестве значения.

Другие различные наименования имеют как _научное название_, использующее Международную систему единиц (_SI_), так и разговорное название, отдающее дань уважения многим великим умам вычислительной техники и криптографии.

<<ether_denominations>> показывает различные единицы измерения, их разговорные (общие) названия и их имена в СИ. В соответствии с внутренним представлением стоимости, в таблице показаны все номиналы в wei (первая строка), а эфир показан как 10^18^ wei в 7-й строке.

[[ether_denominations]]
.Деноменация Эфира и названия единиц
[options="header"]
|===
| Значение (в wei) | Степень | Название | Название в СИ
| 1 | 1 | wei | Wei
| 1,000 | 10^3^ | Babbage | Kilowei or femtoether
| 1,000,000 | 10^6^ | Lovelace | Megawei or picoether
| 1,000,000,000 | 10^9^ | Shannon | Gigawei or nanoether
| 1,000,000,000,000 | 10^12^ | Szabo | Microether or micro
| 1,000,000,000,000,000 | 10^15^ | Finney | Milliether or milli
| _1,000,000,000,000,000,000_ | _10^18^_ | _Ether_ | _Ether_
| 1,000,000,000,000,000,000,000 | 10^21^ | Grand | Kiloether
| 1,000,000,000,000,000,000,000,000 | 10^24^ | | Megaether
|===

[[choosing_eth_wallet]]
=== Выбор кошелька Ethereum

((("Ethereum (generally)","wallet choices")))((("wallets","choosing")))((("wallets","defined")))Термин "кошелек" стал означать много вещей, хотя все они взаимосвязаны и в повседневной жизни сводятся практически к одному и тому же. Мы будем использовать термин "кошелек" для обозначения программного приложения, которое помогает вам управлять вашей учетной записью Ethereum. Короче говоря, кошелек Ethereum - это ваш шлюз к системе Ethereum. Он хранит ваши ключи и может создавать и транслировать транзакции от вашего имени. Выбор кошелька Ethereum может быть затруднен, потому что существует множество различных вариантов с различными функциями и дизайном. Некоторые из них больше подходят для начинающих, а некоторые больше подходят для экспертов. Сама платформа Ethereum все еще совершенствуется, и "лучшие" кошельки часто являются теми, которые адаптируются к изменениям, связанным с обновлением платформы.

Но не волнуйтесь! Если вы выбираете кошелек, и вам не нравится, как он работает &#x2014; или если сначала он вам нравится, но позже вы хотите попробовать что-то другое &#x2014; вы можете довольно легко сменить кошелек. Все, что вам нужно сделать, это совершить транзакцию, которая отправит ваши средства со старого кошелька на новый кошелек, или экспортировать ваши личные ключи и импортировать их в новый кошелек.

Мы выбрали несколько различных типов кошельков для использования в качестве примеров на протяжении всей книги. Некоторые из них предназначены для мобильных устройств, настольных компьютеров, а другие - для работы в Интернете. Мы выбрали разные кошельки, потому что они представляют собой широкий спектр сложности и функций. Однако выбор этих кошельков не является подтверждением их качества или безопасности. Они просто являются хорошей отправной точкой для демонстраций и тестирования.

((("private keys","wallets and")))Помните, что для того, чтобы приложение кошелька работало, оно должно иметь доступ к вашим личным ключам, поэтому очень важно, чтобы вы загружали и использовали приложение кошелька только из источников, которым вы доверяете. К счастью, в целом, чем популярнее приложение для кошелька, тем более надежным оно, вероятно, будет. Тем не менее, не рекомендуется "класть все яйца в одну корзину" и распределять свои учетные записи Ethereum по нескольким кошелькам.

Ниже приведены некоторые хорошие стартовые кошельки:

MetaMask:: ((("MetaMask")))MetaMask - это кошелек с расширением для браузера, который запускается в вашем браузере (Chrome, Firefox, Opera или Brave Browser). Он прост в использовании и удобен для тестирования, так как способен подключаться к множеству узлов Ethereum и тестировать блокчейны. MetaMask - это веб-кошелек, который также включает в себя мобильные приложения как для iOS, так и для Android.

Jaxx:: ((("Jaxx")))((("wallets","Jaxx")))Jaxx - это мультиплатформенный и мультивалютный кошелек, который работает на различных операционных системах, включая Android, iOS, Windows, macOS и Linux. Это часто хороший выбор для новых пользователей, поскольку он разработан для простоты и удобства использования. Jaxx - это либо мобильный, либо настольный кошелек, в зависимости от того, где вы его устанавливаете.

MyEtherWallet (MEW):: ((("MyEtherWallet (MEW)")))((("wallets","MyEtherWallet")))MyEtherWallet - это в первую очередь веб-кошелек, который работает в любом браузере. Он также доступен на Android и iOS. Он обладает множеством сложных функций, которые мы рассмотрим во многих наших примерах.

Emerald Wallet:: ((("Ethereum Classic (ETC)","Emerald Wallet and")))((("wallets","Emerald Wallet")))((("Emerald Wallet")))Emerald Wallet предназначен для работы с блокчейном Ethereum Classic, но совместим с другими блокчейнами на базе Ethereum. Это настольное приложение с открытым исходным кодом, работающее под управлением Windows, macOS и Linux. Emerald Wallet может запускать полный узел или подключаться к общедоступному удаленному узлу, работая в "легком" режиме. Он также имеет вспомогательный инструмент для выполнения всех операций из командной строки.

Мы начнем с установки Metal Mask на рабочий стол &#x2014; но сначала мы кратко обсудим управление ключами и управление ими.

[[control_responsibility]]
=== Контроль и ответственность

((("Ethereum (generally)","control and responsibility", id="ix_02intro-asciidoc1", range="startofrange")))Открытые блокчейны, такие как Ethereum, важны, потому что они работают как _децентрализованная_ система. Это означает многое, но один важный аспект заключается в том, что каждый пользователь Ethereum может &#x2014; и должен &#x2014; контролировать свои собственные закрытые ключи, которые контролируют доступ к средствам и смарт-контрактам. Мы иногда называем комбинацию доступа к средствам и смарт-контрактам "учетной записью" или "кошельком". Эти термины могут быть довольно сложными по своей функциональности, поэтому мы рассмотрим это более подробно позже. Однако в качестве основополагающего принципа это так же просто, как один закрытый ключ равен одной учетной записи. Некоторые пользователи предпочитают отказаться от контроля над своими секретными ключами, используя стороннего хранителя, такого как онлайн-биржа. В этой книге мы научим вас, как взять под контроль и управлять своими собственными закрытыми ключами.

С контролем приходит большая ответственность. Если вы потеряете свои личные ключи, вы потеряете доступ к своим средствам и контрактам. Никто не сможет помочь вам восстановить доступ &#x2014; ваши средства будут заблокированы навсегда. Вот несколько советов, которые помогут вам справиться с этой ответственностью:

* Не импровизируйте с безопасностью. Используйте стандартные проверенные подходы.

* Чем важнее учетная запись (например, чем выше стоимость контролируемых средств или чем более значимы доступные смарт-контракты), тем более высокие меры безопасности должны быть приняты.

* Самый высокий уровень безопасности обеспечивается устройством изолированные от интернета, но этот уровень не требуется для каждой учетной записи.

* Никогда не храните свой закрытый ключ в открытом виде, особенно в цифровом виде. К счастью, большинство современных пользовательских интерфейсов даже не позволяют вам увидеть закрытый ключ.

* ((("private keys","wallets and")))Закрытые ключи могут храниться в зашифрованном виде в виде цифрового файла "хранилища ключей". Будучи зашифрованными, они нуждаются в пароле для разблокировки. Когда вам будет предложено выбрать пароль, сделайте его надежным (т.е. длинным и случайным), создайте его резервную копию и не делитесь им. Если у вас нет менеджера паролей, запишите его и храните в надежном и секретном месте. Чтобы получить доступ к вашей учетной записи, вам нужен как файл хранилища ключей, так и пароль.

* Не храните никаких паролей в цифровых документах, цифровых фотографиях, скриншотах, онлайн-дисках, зашифрованных PDF-файлах и т.д. Опять же, не импровизируйте с безопасностью. Используйте менеджер паролей или ручку и бумагу.

* Когда вам будет предложено создать резервную копию ключа в виде мнемонической последовательности слов, используйте ручку и бумагу для создания физической резервной копии. Не оставляйте это задание "на потом"; вы забудете. Эти резервные копии можно использовать для восстановления вашего закрытого ключа в случае, если вы потеряете все данные, сохраненные в вашей системе, или если вы забудете или потеряете свой пароль. Однако они также могут быть использованы злоумышленниками для получения ваших личных ключей, поэтому никогда не храните их в цифровом виде, а физическую копию надежно храните в запертом ящике или сейфе.

* Прежде чем переводить какие-либо крупные суммы (особенно на новые адреса), сначала выполните небольшую тестовую транзакцию (например, стоимостью менее 1 доллара) и дождитесь подтверждения получения.

* Когда вы создаете новую учетную запись, начните с отправки только небольшой тестовой транзакции на новый адрес. Как только вы получите тестовую транзакцию, попробуйте отправить ее обратно с этой учетной записи. Существует множество причин, по которым создание учетной записи может пойти не так, и если что-то пошло не так, лучше выяснить это с небольшими потерями. Если тесты работают, все хорошо.

* Исследователи общедоступных блоков - это простой способ независимо проверить, была ли транзакция принята сетью. Однако это удобство негативно сказывается на вашей конфиденциальности, поскольку вы раскрываете свои адреса для программ просмотра блоков, которые могут отслеживать вас.

* Не отправляйте деньги ни на один из адресов, указанных в этой книге. Секретные ключи перечислены в книге, и кто-то немедленно заберет эти деньги.

Теперь, когда мы рассмотрели некоторые основные рекомендации по управлению ключами и безопасности, давайте приступим к работе с помощью MetaMask!(((range="endofrange", startref="ix_02intro-asciidoc1")))

[[installing_MetaMask]]
=== Начало работы с MetaMask

((("Ethereum (generally)","MetaMask basics", id="ix_02intro-asciidoc2", range="startofrange")))((("MetaMask","basics", id="ix_02intro-asciidoc3", range="startofrange")))Откройте браузер Google Chrome и перейдите по ссылке https://chrome.google.com/webstore/category/extensions[].

Найдите MetaMask и нажмите на логотип с изображением лисы. Вы должны увидеть что-то вроде результата, показанного в <<metamask_download>>.

[[metamask_download]]
.Страница сведений о расширении MetaMask Chrome
image::images/metamask_download.png["MetaMask Detail Page"]

Важно убедиться, что вы загружаете настоящее расширение MetaMask, так как иногда людям удается незаметно протащить вредоносные расширения мимо фильтров Google. Настоящий:

* Показывает идентификатор +nkbihfbeogaeaoehlefnkodbefgpgknn+ в адресной строке
* Предлагается https://metamask.io
* Имеет более 1500 отзывов
* Имеет более 1 000 000 пользователей

Как только вы подтвердите, что нашли правильное расширение, нажмите "Добавить в Chrome", чтобы установить его.

[[using_MetaMask]]
==== Создание кошелька

((("MetaMask","wallet setup with", id="ix_02intro-asciidoc4", range="startofrange")))После установки MetaMask вы должны увидеть новый значок (голова лисы) на панели инструментов вашего браузера. Нажмите на нее, чтобы начать работу. Вам будет предложено принять правила и условия, а затем создать свой новый кошелек Ethereum, введя пароль (см. <<metamask_password>>).

[[metamask_password]]
.Страница пароля расширения MetaMask Chrome
image::images/metamask_password.png["MetaMask Password Page"]

[TIP]
====
Пароль контролирует доступ к MetaMask, так что он не может быть использован кем-либо, имеющим доступ к вашему браузеру.
====

((("mnemonic code words","MetaMask and", id="ix_02intro-asciidoc5", range="startofrange")))Как только вы установите пароль, MetaMask сгенерирует для вас кошелек и покажет вам _мнемоническую резервную копию_, состоящую из 12 английских слов (см. <<metamask_mnemonic>>). Эти слова могут быть использованы в любом совместимом кошельке для восстановления доступа к вашим средствам, если что-то случится с MetaMask или вашим компьютером. Для этого восстановления вам не нужен пароль; достаточно 12 слов.

[TIP]
====
Дважды создайте резервную копию своей мнемоники (12 слов) на бумаге. Храните две бумажные резервные копии в двух отдельных безопасных местах, например в огнестойком сейфе, запирающемся ящике или сейфе. Относитесь к бумажным резервным копиям как к наличным деньгам, стоимость которых эквивалентна тому, что вы храните в своем кошельке Ethereum. Любой, у кого есть доступ к этим словам, может получить доступ и украсть ваши деньги.
====

[[metamask_mnemonic]]
.The mnemonic backup of your wallet, created by MetaMask
image::images/metamask_mnemonic.png["MetaMask Mnemonic Page"]

Как только вы подтвердите, что надежно сохранили мнемонику, вы сможете увидеть детали своей учетной записи Ethereum, как показано на <<metamask_account>>.(((range="endofrange", startref="ix_02intro-asciidoc5")))

[[metamask_account]]
.Ваша учетная запись Ethereum в MetaMask
image::images/metamask_account.png["MetaMask Account Page"]

На странице вашей учетной записи отображается имя вашей учетной записи (по умолчанию "Учетная запись 1"), адрес Ethereum (+0x9E713...+ в примере) и красочный значок, который поможет вам визуально отличить эту учетную запись от других учетных записей. В верхней части страницы учетной записи вы можете увидеть, в какой сети Ethereum вы в данный момент работаете (в примере "Основная сеть").

Поздравляю! Вы создали свой первый кошелек Ethereum.(((range="endofrange", startref="ix_02intro-asciidoc4")))

[[switching_networks]]
==== Переключение сетей

((("MetaMask","network choices")))Как вы можете видеть на странице учетной записи MetaMask, вы можете выбирать между несколькими сетями Ethereum. По умолчанию MetaMask попытается подключиться к основной сети. Другими вариантами являются общедоступные тестовые сети, любой узел Ethereum по вашему выбору или узлы, работающие с частными блокчейнами на вашем собственном компьютере (localhost).:

Основная сеть Ethereum:: Основной публичный блокчейн Ethereum. Реальный ETH, реальная ценность и реальные последствия.

Ropsten – тестовая сеть:: Ethereum публично тестирует блокчейн и сеть. ETH в этой сети не имеет никакого значения.

Kovan – тестовая сеть:: Ethereum публично тестирует блокчейн и сеть, используя консенсусный протокол Aura с подтверждением полномочий (интегрированная подпись). ETH в этой сети не имеет никакого значения. Тестовая сеть Kovan поддерживается только по Parity. Другие клиенты Ethereum используют протокол консенсуса Clique, который был предложен позже, для проверки на основе подтверждения полномочий.

Rinkeby – тестовая сеть:: Ethereum публично тестирует блокчейн и сеть, используя протокол Clique консенсус с подтверждением полномочий (интегрированная подпись). ETH в этой сети не имеет никакого значения.

Localhost 8545:: Подключается к узлу, работающему на том же компьютере, что и браузер. Узел может быть частью любого публичного блокчейна (основной или тестовой сети) или частной тестовой сети.

Свой RPC:: Позволяет подключать MetaMask к любому узлу с помощью интерфейса удаленного вызова процедур (RPC), совместимого с Geth. Узел может быть частью любого публичного или частного блокчейна.

[NOTE]
====
Ваш кошелек MetaMask использует один и тот же закрытый ключ и адрес Ethereum во всех сетях, к которым он подключается. Однако баланс вашего адреса Ethereum в каждой сети Ethereum будет разным. Например, ваши ключи могут управлять эфиром и контрактами в Ropsten, но не в основной сети.
====

[[getting_test_eth]]
==== Getting Some Test Ether

((("ether (generally)","testnet")))((("MetaMask","and testnet ether")))((("test ether","obtaining")))((("testnet","ether for")))((("wallets","testnet ether and")))Your first task is to get your wallet funded. You won't be doing that on the main network because real ether costs money and handling it requires a bit more experience. For now, you'll load your wallet with some testnet ether.

((("Ropsten Test Network")))Switch MetaMask to the _Ropsten Test Network_. Click Deposit, then click Ropsten Test Faucet. MetaMask will open a new web page, as shown in <<metamask_ropsten_faucet>>.

[[metamask_ropsten_faucet]]
.MetaMask Ropsten Test Faucet
image::images/metamask_ropsten_faucet.png["MetaMask Ropsten Test Faucet"]

You may notice that the web page already contains your MetaMask wallet's Ethereum address. MetaMask integrates Ethereum-enabled web pages with your MetaMask wallet and can "see" Ethereum addresses on the web page, allowing you, for example, to send a payment to an online shop displaying an Ethereum address. MetaMask can also populate the web page with your own wallet's address as a recipient address if the web page requests it. In this page, the faucet application is asking MetaMask for a wallet address to send test ether to.

Click the green "request 1 ether from faucet" button. You will see a transaction ID appear in the lower part of the page. The faucet app has created a transaction&#x2014;a payment to you. The transaction ID looks like this:

[[faucet_tx_id]]
----
0x7c7ad5aaea6474adccf6f5c5d6abed11b70a350fbc6f9590109e099568090c57
----

In a few seconds, the new transaction will be mined by the Ropsten miners and your MetaMask wallet will show a balance of 1 ETH. Click on the transaction ID and your browser will take you to a _block explorer_, which is a website that allows you to visualize and explore blocks, addresses, and transactions. MetaMask uses the https://etherscan.io/[Etherscan block explorer], one of the more popular Ethereum block explorers. The transaction containing the payment from the Ropsten Test Faucet is shown in <<ropsten_block_explorer>>.

[[ropsten_block_explorer]]
.Etherscan Ropsten block explorer
image::images/ropsten_block_explorer.png["Etherscan Ropsten Block Explorer"]

The transaction has been recorded on the Ropsten blockchain and can be viewed at any time by anyone, simply by searching for the transaction ID, or http://bit.ly/2Q860Wk[visiting the link].

Try visiting that link, or entering the transaction hash into the _ropsten.etherscan.io_ website, to see it for yourself.

[[sending_eth_MetaMask]]
==== Sending Ether from MetaMask

((("MetaMask","sending ether from", id="ix_02intro-asciidoc6", range="startofrange")))((("test ether","sending", id="ix_02intro-asciidoc7", range="startofrange")))Once you've received your first test ether from the Ropsten Test Faucet, you can experiment with sending ether by trying to send some back to the faucet. As you can see on the Ropsten Test Faucet page, there is an option to "donate" 1 ETH to the faucet. This option is available so that once you're done testing, you can return the remainder of your test ether, so that someone else can use it next. Even though test ether has no value, some people hoard it, making it difficult for everyone else to use the test networks. Hoarding test ether is frowned upon!

Fortunately, we are not test ether hoarders. Click the orange "1 ether" button to tell MetaMask to create a transaction paying the faucet 1 ether. MetaMask will prepare a transaction and pop up a window with the confirmation, as shown in <<send_to_faucet>>.


[[send_to_faucet]]
.Sending 1 ether to the faucet
image::images/send_to_faucet.png["Sending 1 ether to the faucet"]

Oops! You probably noticed you can't complete the transaction&#x2014;MetaMask says you have an insufficient balance. At first glance this may seem confusing: you have 1 ETH, you want to send 1 ETH, so why is MetaMask saying you have insufficient funds?

((("gas","basics")))The answer is because of the cost of _gas_. Every Ethereum transaction requires payment of a fee, which is collected by the miners to validate the transaction. The fees in Ethereum are charged in a virtual currency called gas. You pay for the gas with ether, as part of the transaction.

[NOTE]
====
((("gas","on test networks")))Fees are required on the test networks too. Without fees, a test network would behave differently from the main network, making it an inadequate testing platform. Fees also protect the test networks from DoS attacks and poorly constructed contracts (e.g., infinite loops), much like they protect the main network.
====

When you sent the transaction, MetaMask calculated the average gas price of recent successful transactions at 3 gwei, which stands for gigawei. Wei is the smallest pass:[<span class="keep-together">subdivision</span>] of the ether currency, as we discussed in <<ether_units>>. The gas limit is set at the cost of sending a basic transaction, which is 21,000 gas units. Therefore, the maximum amount of ETH you will spend is 3 * 21,000 gwei = 63,000 gwei = 0.000063 ETH. (Be advised that average gas prices can fluctuate, as they are predominantly determined by miners. We will see in a later chapter how you can increase/decrease your gas limit to ensure your transaction takes precedence if need be.)

All this to say: making a 1 ETH transaction costs 1.000063 ETH. MetaMask confusingly rounds that _down_ to 1 ETH when showing the total, but the actual amount you need is 1.000063 ETH and you only have 1 ETH. Click Reject to cancel this transaction.

Let's get some more test ether! Click the green "request 1 ether from the faucet" button again and wait a few seconds. Don't worry, the faucet should have plenty of ether and will give you more if you ask.

Once you have a balance of 2 ETH, you can try again. This time, when you click the orange "1 ether" donation button, you have sufficient balance to complete the transaction. Click Submit when MetaMask pops up the payment window. After all of this, you should see a balance of 0.999937 ETH because you sent 1 ETH to the faucet with 0.000063 ETH in gas.(((range="endofrange", startref="ix_02intro-asciidoc7")))(((range="endofrange", startref="ix_02intro-asciidoc6")))

[[explore_tx_history]]
==== Exploring the Transaction History of an Address

((("addresses","exploring transaction history of", id="ix_02intro-asciidoc8", range="startofrange")))((("MetaMask","exploring transaction history of an address with", id="ix_02intro-asciidoc9", range="startofrange")))By now you have become an expert in using MetaMask to send and receive test ether. Your wallet has received at least two payments and sent at least one. You can view all these transactions using the _ropsten.etherscan.io_ block explorer. You can either copy your wallet address and paste it into the block explorer's search box, or have MetaMask open the page for you. Next to your account icon in MetaMask, you will see a button showing three dots. Click on it to show a menu of account-related options (see <<metamask_account_context_menu>>).

[[metamask_account_context_menu]]
.MetaMask account context menu
image::images/metamask_account_context_menu.png["MetaMask Account Context Menu"]

Select "View account on Etherscan" to open a web page in the block explorer showing your account's transaction history, as shown in <<block_explorer_account_history>>.

[[block_explorer_account_history]]
.Address transaction history on Etherscan
image::images/block_explorer_account_history.png["Address Transaction History on Etherscan"]

Here you can see the entire transaction history of your Ethereum address. It shows all the transactions recorded on the Ropsten blockchain where your address is the sender or recipient. Click on a few of these transactions to see more details.

You can explore the transaction history of any address. Take a look at the transaction history of the Ropsten Test Faucet address (hint: it is the "sender" address listed in the oldest payment to your address). You can see all the test ether sent from the faucet to you and to other addresses. Every transaction you see can lead you to more addresses and more transactions. Before long you will be lost in the maze of interconnected data. Public blockchains contain an enormous wealth of information, all of which can be explored programmatically, as we will see in future examples(((range="endofrange", startref="ix_02intro-asciidoc9")))(((range="endofrange", startref="ix_02intro-asciidoc8"))).(((range="endofrange", startref="ix_02intro-asciidoc3")))(((range="endofrange", startref="ix_02intro-asciidoc2")))

[[intro_world_computer]]
=== Introducing the World Computer

((("Ethereum (generally)","and EVM")))((("EVM (Ethereum Virtual Machine)","as world computer")))((("world computer, Ethereum as")))You've now created a wallet and sent and received ether. So far, we've treated Ethereum as a cryptocurrency. But Ethereum is much, much more. In fact, the cryptocurrency function is subservient to Ethereum's function as a decentralized world computer. ((("smart contracts","ether and")))Ether is meant to be used to pay for running _smart contracts_, which are computer programs that run on an emulated computer called the _Ethereum Virtual Machine_ (EVM).

The EVM is a global singleton, meaning that it operates as if it were a global, single-instance computer, running everywhere. Each node on the Ethereum network runs a local copy of the EVM to validate contract execution, while the Ethereum blockchain records the changing _state_ of this world computer as it processes transactions and smart contracts. We'll discuss this in much greater detail in <<evm_chapter>>.

[[EOA_contracts]]
=== Externally Owned Accounts (EOAs) and Contracts

((("contract accounts", seealso="smart contracts")))((("EOA (Externally Owned Account)","basics")))((("Ethereum (generally)","EOAs and contracts")))((("smart contracts","basics")))The type of account you created in the MetaMask wallet is called an _externally owned account_ (EOA). Externally owned accounts are those that have a private key; having the private key means control over access to funds or contracts. Now, you're probably guessing there is another type of account. That other type of account is a _contract account_. A contract account has smart contract code, which a simple EOA can't have. Furthermore, a contract account does not have a private key. Instead, it is owned (and controlled) by the logic of its smart contract code: the software program recorded on the Ethereum blockchain at the contract account's creation and executed by the EVM.

Contracts have addresses, just like EOAs. Contracts can also send and receive ether, just like EOAs. However, when a transaction destination is a contract address, it causes that contract to _run_ in the EVM, using the transaction, and the transaction's data, as its input. In addition to ether, transactions can contain _data_ indicating which specific function in the contract to run and what parameters to pass to that function. In this way, transactions can _call_ functions within contracts.

Note that because a contract account does not have a private key, it cannot _initiate_ a transaction. Only EOAs can initiate transactions, but contracts can _react_ to transactions by calling other contracts, building complex execution paths. One typical use of this is an EOA sending a request transaction to a multisignature smart contract wallet to send some ETH on to another address. A typical DApp programming pattern is to have Contract A calling Contract B in order to maintain a shared state across users of Contract A.

In the next few sections, we will write our first contract. You will then learn how to create, fund, and use that contract with your MetaMask wallet and test ether on the Ropsten test network.

[[simple_contract_example]]
=== A Simple Contract: A Test Ether Faucet

((("contract accounts","creating", seealso="Faucet.sol contract", id="ix_02intro-asciidoc10", range="startofrange")))((("Faucet.sol contract (test example)","creating", id="ix_02intro-asciidoc11", range="startofrange")))Ethereum has many different high-level languages, all of which can be used to write a contract and produce EVM bytecode. You can read about many of the most prominent and interesting ones in <<high_level_languages>>. One high-level language is by far the dominant choice for smart contract programming: Solidity. ((("Wood, Dr. Gavin","and Solidity")))Solidity was created by Dr. Gavin Wood, the coauthor of this book, and has become the most widely used language in Ethereum (and beyond). We'll use Solidity to write our first contract.

((("Solidity","faucet.sol and")))For our first example (<<solidity_faucet_example>>), we will write a contract that controls a _faucet_. You've already used a faucet to get test ether on the Ropsten test network. A faucet is a relatively simple thing: it gives out ether to any address that asks, and can be refilled periodically. You can implement a faucet as a wallet controlled by a human or a web server.

[[solidity_faucet_example]]
.Faucet.sol: A Solidity contract implementing a faucet
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----
====

[NOTE]
====
You will find all the code samples for this book in the _code_ subdirectory of https://github.com/ethereumbook/ethereumbook/[the book's GitHub repository]. Specifically, our _Faucet.sol_ contract is in:

----
code/Solidity/Faucet.sol
----
====

This is a very simple contract, about as simple as we can make it. It is also a _flawed_ contract, demonstrating a number of bad practices and security vulnerabilities. We will learn by examining all of its flaws in later sections. But for now, let's look at what this contract does and how it works, line by line. You will quickly notice that many elements of Solidity are similar to existing programming languages, such as JavaScript, Java, or Cpass:[++].

The first line is a comment:

[[comment]]
[source,solidity]
----
// SPDX-License-Identifier: CC-BY-SA-4.0
----

Comments are for humans to read and are not included in the executable EVM bytecode. We usually put them on the line before the code we are trying to explain, or sometimes on the same line. Comments start with two forward slashes: +//+. Everything from the first slash until the end of that line is treated the same as a blank line and ignored.

A few lines later is where our actual contract starts:

[[contract_definition]]
[source,solidity]
----
contract Faucet {
----

This line declares a +contract+ object, similar to a +class+ declaration in other object-oriented languages. The contract definition includes all the lines between the curly braces (pass:[<code>{}</code>]), which define a _scope_, much like how curly braces are used in many other programming languages.

Next, we enable the contract to accept any incoming amount:

[[receive_function]]
[source,solidity]
----
receive () external payable {}
----

((("receive function")))The receive function is called if the transaction that triggered the contract didn't name any of the declared functions in the contract, or didn't contain data and thus was a plain Ether transfer. Contracts can have one such receive function (without a name) and it is used to receive ether. That's why it is defined as an external and payable function, which means it can accept ether into the contract. It doesn't do anything, other than accept the ether, as indicated by the empty definition in the curly braces pass:[(<code>{}</code>)]. If we make a transaction that sends ether to the contract address, as if it were a wallet, this function will handle it.

After this, we declare the first function of the +Faucet+ contract:

[[withdraw_function]]
[source,solidity]
----
function withdraw(uint withdraw_amount) public {
----

The function is named +withdraw+, and it takes one unsigned integer (+uint+) argument named +withdraw_amount+. It is declared as a public function, meaning it can be called by other contracts. The function definition follows, between curly braces. The first part of the +withdraw+ function sets a limit on withdrawals:

[[withdraw_limit]]
[source,solidity]
----
require(withdraw_amount <= 100000000000000000);
----

It uses the built-in Solidity function +require+ to test a precondition, that the +withdraw_amount+ is less than or equal to 100,000,000,000,000,000 wei, which is the base unit of ether (see <<ether_denominations>>) and equivalent to 0.1 ether. If the +withdraw+ function is called with a +withdraw_amount+ greater than that amount, the +require+ function here will cause contract execution to stop and fail with an _exception_. Note that statements need to be terminated with a semicolon in Solidity.

This part of the contract is the main logic of our faucet. It controls the flow of funds out of the contract by placing a limit on withdrawals. It's a very simple control but can give you a glimpse of the power of a programmable blockchain: decentralized software controlling money.

Next comes the actual withdrawal:

[[withdraw_command]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

A couple of interesting things are happening here. The +msg+ object is one of the inputs that all contracts can access. It represents the transaction that triggered the execution of this contract. The attribute +sender+ is the sender address of the transaction. The function +transfer+ is a built-in function that transfers ether from the current contract to the address of the sender. Reading it backward, this means +transfer+ to the +sender+ of the +msg+ that triggered this contract execution. The +transfer+ function takes an amount as its only argument. We pass the +withdraw_amount+ value that was the parameter to the +withdraw+ function declared a few lines earlier.

The very next line is the closing curly brace, indicating the end of the definition of our +withdraw+ function.

Right below our default function is the final closing curly brace, which closes the definition of the contract +Faucet+. That's it!(((range="endofrange", startref="ix_02intro-asciidoc11")))(((range="endofrange", startref="ix_02intro-asciidoc10")))

[[compile_faucet_contract]]
=== Compiling the Faucet Contract

((("compiling","Faucet.sol contract", id="ix_02intro-asciidoc12", range="startofrange")))((("Faucet.sol contract (test example)","compiling", id="ix_02intro-asciidoc13", range="startofrange")))Now that we have our first example contract, we need to use a Solidity compiler to convert the Solidity code into EVM bytecode so it can be executed by the EVM on the blockchain itself.

The Solidity compiler comes as a standalone executable, as part of various frameworks, and bundled in Integrated Development Environments (IDEs). To keep things simple, we will use one of the more popular IDEs, called _Remix_.

((("Remix IDE")))Use your Chrome browser (with the MetaMask wallet you installed earlier) to navigate to the Remix IDE at https://remix.ethereum.org[].

When you first load Remix, it will start with a sample contract called _ballot.sol_. We don't need that, so close it by clicking the +x+ on the corner of the tab, as seen in <<remix_close_tab>>.

[[remix_close_tab]]
.Close the default example tab
image::images/remix_close_tab.png["Close the default example tab"]

Now, add a new tab by clicking on the circular plus sign in the top-left toolbar, as seen in <<remix_toolbar>>. Name the new file _Faucet.sol_.

[[remix_toolbar]]
.Click the plus sign to open a new tab
image::images/remix_toolbar.png["Click the plus sign to open a new tab"]

Once you have the new tab open, copy and paste the code from our example _Faucet.sol_, as seen in <<remix_faucet_load>>.

[[remix_faucet_load]]
.Copy the Faucet example code into the new tab
image::images/remix_faucet_load.png["Copy the Faucet example code into the new tab"]

Once you have loaded the _Faucet.sol_ contract into the Remix IDE, the IDE will automatically compile the code. If all goes well, you will see a green box with "Faucet" in it appear on the right, under the Compile tab, confirming the successful compilation (see <<remix_compile>>).

[[remix_compile]]
.Remix successfully compiles the Faucet.sol contract
image::images/remix_compile.png[""]

If something goes wrong, the most likely problem is that the Remix IDE is using a version of the Solidity compiler that is different from 0.6. In that case, our pragma directive will prevent _Faucet.sol_ from compiling. To change the compiler version, go to the Settings tab, set the version to 0.6.0, and try again.

The Solidity compiler has now compiled our _Faucet.sol_ into EVM bytecode. If you are curious, the bytecode looks like this:

[[faucet_bytecode]]
----
PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0xF4 DUP1 PUSH2 0x1F PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH1 0x1F JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x2E1A7D4D EQ PUSH1 0x2A JUMPI PUSH1 0x25 JUMP JUMPDEST CALLDATASIZE PUSH1 0x25 JUMPI STOP JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH1 0x35 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x5F PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH1 0x4A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH1 0x61 JUMP JUMPDEST STOP JUMPDEST PUSH8 0x16345785D8A0000 DUP2 GT ISZERO PUSH1 0x75 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH2 0x8FC DUP3 SWAP1 DUP2 ISZERO MUL SWAP1 PUSH1 0x40 MLOAD PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO DUP1 ISZERO PUSH1 0xBA JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 STOP CODECOPY 0xDC DUP16 0xD SGT PUSH6 0xD2245039EDD7 RETURN CALLDATALOAD 0xC2 0xE4 SWAP9 0xF6 0x2C 0xF8 0xB3 OR JUMPDEST 0xAC 0xD8 CREATE2 SSTORE 0x4E SIGNEXTEND PUSH4 0x3164736F PUSH13 0x634300060C0033000000000000
----

Aren't you glad you are using a high-level language like Solidity instead of programming directly in EVM bytecode? Me too!(((range="endofrange", startref="ix_02intro-asciidoc13")))(((range="endofrange", startref="ix_02intro-asciidoc12")))

[[create_contract]]
=== Creating the Contract on the Blockchain

((("blockchain","creating contract on", id="ix_02intro-asciidoc14", range="startofrange")))((("Faucet.sol contract (test example)","on the blockchain", id="ix_02intro-asciidoc15", range="startofrange")))So, we have a contract. We've compiled it into bytecode. Now, we need to "register" the contract on the Ethereum blockchain. We will be using the Ropsten testnet to test our contract, so that's the blockchain we want to submit it to.

((("zero address","contract registration")))Registering a contract on the blockchain involves creating a special transaction whose destination is the address +0x0000000000000000000000000000000000000000+, also known as the _zero address_. The zero address is a special address that tells the Ethereum blockchain that you want to register a contract. Fortunately, the Remix IDE will handle all of that for you and send the transaction to MetaMask.

((("Remix IDE", id="ix_02intro-asciidoc16", range="startofrange")))First, switch to the Run tab and select Injected Web3 in the Environment drop-down selection box. This connects the Remix IDE to the MetaMask wallet, and through MetaMask to the Ropsten test network. Once you do that, you can see Ropsten under Environment. Also, in the Account selection box it shows the address of your wallet (see <<remix_run>>).

[[remix_run]]
.Remix IDE Run tab, with Injected Web3 environment selected
image::images/remix_run.png["Remix IDE Run tab, with Injected Web3 environment selected"]

Right below the Run settings you just confirmed is the +Faucet+ contract, ready to be created. Click on the Deploy button shown in <<remix_run>>.

Remix will construct the special "creation" transaction and MetaMask will ask you to approve it, as shown in <<remix_metamask_create>>. You'll notice the contract creation transaction has no ether in it, but it has 275 bytes of data (the compiled contract) and will consume 3 gwei in gas. Press Confirm to approve it.

[[remix_metamask_create]]
.MetaMask showing the contract creation transaction
image::images/remix_metamask_create.png["MetaMask showing the contract creation transaction"]

Now you have to wait. It will take about 15 to 30 seconds for the contract to be mined on Ropsten. Remix won't appear to be doing much, but be patient.

Once the contract is created, it appears at the bottom of the Run tab (see <<remix_contract_interact>>).

[[remix_contract_interact]]
.The Faucet contract is ALIVE!
image::images/remix_contract_interact.png["The Faucet contract is ALIVE!"]

Notice that the +Faucet+ contract now has an address of its own: Remix shows it as &#x201c;Faucet at 0x72e...c7829&#x201d; (although your address, the random letters and numbers, will be different). The small clipboard symbol to the right allows you to copy the contract address to your clipboard. We will use that in the next section.(((range="endofrange", startref="ix_02intro-asciidoc16")))(((range="endofrange", startref="ix_02intro-asciidoc15")))

[[interact_contract]]
=== Interacting with the Contract

((("Faucet.sol contract (test example)","interacting with", id="ix_02intro-asciidoc17", range="startofrange")))Let's recap what we've learned so far: Ethereum contracts are programs that control money, which run inside a virtual machine called the EVM. They are created by a special transaction that submits their bytecode to be recorded on the blockchain. Once they are created on the blockchain, they have an Ethereum address, just like wallets. Anytime someone sends a transaction to a contract address it causes the contract to run in the EVM, with the transaction as its input. Transactions sent to pass:[<span class="keep-together">contract</span>] addresses may have ether or data or both. If they contain ether, it is "deposited" to the contract balance. If they contain data, the data can specify a named function in the contract and call it, passing arguments to the function.

[[view_contract_address]]
==== Viewing the Contract Address in a Block Explorer

((("Faucet.sol contract (test example)","viewing contract address in a block explorer")))We now have a contract recorded on the blockchain, and we can see it has an Ethereum address. Let's check it out in the _ropsten.etherscan.io_ block explorer and see what a contract looks like. In the Remix IDE, copy the address of the contract by clicking the clipboard icon next to its name (see <<remix_contract_address>>).

[[remix_contract_address]]
.Copy the contract address from Remix
image::images/remix_contract_address.png["Copy the contract address from Remix"]

Keep Remix open; we'll come back to it again later. Now, navigate your browser to _ropsten.etherscan.io_ and paste the address into the search box. You should see the contract's Ethereum address history, as shown in <<etherscan_contract_address>>.(((range="endofrange", startref="ix_02intro-asciidoc17")))

[[etherscan_contract_address]]
.View the Faucet contract address in the Etherscan block explorer
image::images/etherscan_contract_address.png["View the Faucet contract address in the etherscan block explorer"]

[[fund_contract]]
==== Funding the Contract

((("Faucet.sol contract (test example)","sending ether to", id="ix_02intro-asciidoc18", range="startofrange")))For now, the contract only has one transaction in its history: the contract creation transaction. As you can see, the contract also has no ether (zero balance). That's because we didn't send any ether to the contract in the creation transaction, even though we could have.

Our faucet needs funds! Our first project will be to use MetaMask to send ether to the contract. You should still have the address of the contract in your clipboard (if not, copy it again from Remix). Open MetaMask, and send 1 ether to it, exactly as you would to any other Ethereum address (see <<metamask_send_to_contract>>).

[[metamask_send_to_contract]]
.Send 1 ether to the contract address
image::images/metamask_send_to_contract.png[""]

In a minute, if you reload the Etherscan block explorer, it will show another transaction to the contract address and an updated balance of 1 ether.

Remember the unnamed default external payable function in our _Faucet.sol_ code? It looked like this:

[[receive_function_review]]
[source,solidity]
----
receive () external payable {}
----

When you sent a transaction to the contract address, with no data specifying which function to call, it called this default function. Because we declared it as +payable+, it accepted and deposited the 1 ether into the contract's account balance. Your transaction caused the contract to run in the EVM, updating its balance. You have funded your faucet!(((range="endofrange", startref="ix_02intro-asciidoc18")))

[[withdraw_from_contract]]
==== Withdrawing from Our Contract

((("Faucet.sol contract (test example)","withdrawing funds from", id="ix_02intro-asciidoc19", range="startofrange")))((("withdrawal of funds from contract", id="ix_02intro-asciidoc20", range="startofrange")))Next, let's withdraw some funds from the faucet. To withdraw, we have to construct a transaction that calls the +withdraw+ function and passes a +withdraw_amount+ argument to it. To keep things simple for now, Remix will construct that transaction for us and MetaMask will present it for our approval.

Return to the Remix tab and look at the contract on the Run tab. You should see a orange box labeled +withdraw+ with a field entry labeled +uint256 withdraw_amount+ (see <<remix_contract_withdraw>>).

[[remix_contract_withdraw]]
.The withdraw function of Faucet.sol, in Remix
image::images/remix_contract_interact.png["The withdraw function of Faucet.sol, in Remix"]

This is the Remix interface to the contract. It allows us to construct transactions that call the functions defined in the contract. We will enter a +withdraw_amount+ and click the withdraw button to generate the transaction.

First, let's figure out the +withdraw_amount+. We want to try and withdraw 0.1 ether, which is the maximum amount allowed by our contract. Remember that all currency values in Ethereum are denominated in wei internally, and our +withdraw+ function expects the +withdraw_amount+ to be denominated in wei too. The amount we want is 0.1 ether, which is 100,000,000,000,000,000 wei (a 1 followed by 17 zeros).



[TIP]
====
Due to a limitation in JavaScript, a number as large as 10^17 cannot be processed by Remix. Instead, we enclose it in double quotes, to allow Remix to receive it as a string and manipulate it as a +BigNumber+. If we don't enclose it in quotes, the Remix IDE will fail to process it and display "Error encoding arguments: Error: Assertion failed."
====

Type "100000000000000000" (with the quotes) into the +withdraw_amount+ box and click on the withdraw button (see <<remix_withdraw>>).

[[remix_withdraw]]
.Click "withdraw" in Remix to create a withdrawal transaction
image::images/remix_withdraw.png[""]

MetaMask will pop up a transaction window for you to approve. Click Confirm to send your withdrawal call to the contract (see <<metamask_withdraw>>).

[[metamask_withdraw]]
.MetaMask transaction to call the withdraw function
image::images/metamask_withdraw.png["MetaMask transaction to call the withdraw function"]

Wait a minute and then reload the Etherscan block explorer to see the transaction reflected in the +Faucet+ contract address history (see <<etherscan_withdrawal_tx>>).

[[etherscan_withdrawal_tx]]
.Etherscan shows the transaction calling the withdraw function
image::images/etherscan_withdrawal_tx.png["Etherscan shows the transaction calling the withdraw function"]


We now see a new transaction with the contract address as the destination and a value of 0 ether. The contract balance has changed and is now 0.9 ether because it sent us 0.1 ether as requested. But we don't see an "OUT" transaction in the _contract address history_.

Where's the outgoing withdrawal? A new tab has appeared on the contract's address history page, named Internal Transactions. ((("internal transaction (message)")))Because the 0.1 ether transfer originated from the contract code, it is an internal transaction (also called a _message_). Click on that tab to see it (see <<etherscan_withdrawal_internal>>).


This "internal transaction" was sent by the contract in this line of code (from the pass:[<code><span class="keep-together">withdraw</span></code>] function in _Faucet.sol_):

[[withdraw_command_review]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

To recap: you sent a transaction from your MetaMask wallet that contained data instructions to call the +withdraw+ function with a +withdraw_amount+ argument of 0.1 ether. That transaction caused the contract to run inside the EVM. As the EVM ran the +Faucet+ contract's +withdraw+ function, first it called the +require+ function and validated that the requested amount was less than or equal to the maximum allowed withdrawal of 0.1 ether. Then it called the +transfer+ function to send you the ether. Running the +transfer+ function generated an internal transaction that deposited 0.1 ether into your wallet address, from the contract's balance. That's the one shown on the Internal Transactions tab in Etherscan(((range="endofrange", startref="ix_02intro-asciidoc20")))(((range="endofrange", startref="ix_02intro-asciidoc19"))).(((range="endofrange", startref="ix_02intro-asciidoc14")))

[[etherscan_withdrawal_internal]]
.Etherscan shows the internal transaction transferring ether out from the contract
image::images/etherscan_withdrawal_internal.png["Etherscan shows the internal transaction transferring ether out from the contract"]

[[intro_conclusion]]
=== Conclusions

In this chapter, you set up a wallet using MetaMask and funded it using a faucet on the Ropsten test network. You received ether into your wallet's Ethereum address, then you sent ether to the faucet's Ethereum address.

Next, you wrote a faucet contract in Solidity. You used the Remix IDE to compile the contract into EVM bytecode, then used Remix to form a transaction and created the +Faucet+ contract on the Ropsten blockchain. Once created, the +Faucet+ contract had an Ethereum address, and you sent it some ether. Finally, you constructed a transaction to call the +withdraw+ function and successfully asked for 0.1 ether. The contract checked the request and sent you 0.1 ether with an internal transaction.

It may not seem like much, but you've just successfully interacted with software that controls money on a decentralized world computer.

We will do a lot more smart contract programming in <<smart_contracts_chapter>> and learn about best practices and security considerations in <<smart_contract_security>>.(((range="endofrange", startref="ix_02intro-asciidoc0")))

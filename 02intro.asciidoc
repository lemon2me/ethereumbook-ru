[[intro_chapter]]
== Основы Эфириума

((("Ethereum (generally)","basics", id="ix_02intro-asciidoc0", range="startofrange")))В этой главе мы начнем изучать Ethereum, узнаем, как использовать электронные кошельки, как создавать транзакции, а также как запускать базовый смарт-контракт.

[[ether_units]]
=== Валютные единицы Эфира

((("currency units")))((("Ethereum (generally)","currency units")))Денежная единица Ethereum называется _эфир_ (_ether_), обозначается также как "ETH" или символами &#926; (от греческой буквы "Xi", которая выглядит как стилизованная заглавная буква E) или, реже, &#9830;: например, 1 эфир, или 1 ETH, или &#926;1 или &#9830;1.

[TIP]
====
Используйте символ Юникода +U+039E+ для &#926; и +U+2666+ для &#9830;.
====

Эфир подразделяется на более мелкие единицы, вплоть до наименьшей возможной единицы, которая называется _wei_. Один эфир равен 1 квинтиллиону вей (1 * 10^18^ или 1 000 000 000 000 000 000 000). Вы можете услышать, что люди тоже называют валюту "Эфириум", но это распространенная ошибка новичков. Эфириум - это система, эфир - это валюта.

Значение эфира всегда представлено внутри Ethereum в виде целого числа без знака, выраженного в wei. Когда вы совершаете транзакцию 1-ого эфира, транзакция кодирует 1000000000000000000 wei в качестве значения.

Другие различные наименования имеют как _научное название_, использующее Международную систему единиц (_SI_), так и разговорное название, отдающее дань уважения многим великим умам вычислительной техники и криптографии.

<<ether_denominations>> показывает различные единицы измерения, их разговорные (общие) названия и их имена в СИ. В соответствии с внутренним представлением стоимости, в таблице показаны все номиналы в wei (первая строка), а эфир показан как 10^18^ wei в 7-й строке.

[[ether_denominations]]
.Деноменация Эфира и названия единиц
[options="header"]
|===
| Значение (в wei) | Степень | Название | Название в СИ
| 1 | 1 | wei | Wei
| 1,000 | 10^3^ | Babbage | Kilowei or femtoether
| 1,000,000 | 10^6^ | Lovelace | Megawei or picoether
| 1,000,000,000 | 10^9^ | Shannon | Gigawei or nanoether
| 1,000,000,000,000 | 10^12^ | Szabo | Microether or micro
| 1,000,000,000,000,000 | 10^15^ | Finney | Milliether or milli
| _1,000,000,000,000,000,000_ | _10^18^_ | _Ether_ | _Ether_
| 1,000,000,000,000,000,000,000 | 10^21^ | Grand | Kiloether
| 1,000,000,000,000,000,000,000,000 | 10^24^ | | Megaether
|===

[[choosing_eth_wallet]]
=== Выбор кошелька Ethereum

((("Ethereum (generally)","wallet choices")))((("wallets","choosing")))((("wallets","defined")))Термин "кошелек" стал означать много вещей, хотя все они взаимосвязаны и в повседневной жизни сводятся практически к одному и тому же. Мы будем использовать термин "кошелек" для обозначения программного приложения, которое помогает вам управлять вашей учетной записью Ethereum. Короче говоря, кошелек Ethereum - это ваш шлюз к системе Ethereum. Он хранит ваши ключи и может создавать и транслировать транзакции от вашего имени. Выбор кошелька Ethereum может быть затруднен, потому что существует множество различных вариантов с различными функциями и дизайном. Некоторые из них больше подходят для начинающих, а некоторые больше подходят для экспертов. Сама платформа Ethereum все еще совершенствуется, и "лучшие" кошельки часто являются теми, которые адаптируются к изменениям, связанным с обновлением платформы.

Но не волнуйтесь! Если вы выбираете кошелек, и вам не нравится, как он работает &#x2014; или если сначала он вам нравится, но позже вы хотите попробовать что-то другое &#x2014; вы можете довольно легко сменить кошелек. Все, что вам нужно сделать, это совершить транзакцию, которая отправит ваши средства со старого кошелька на новый кошелек, или экспортировать ваши личные ключи и импортировать их в новый кошелек.

Мы выбрали несколько различных типов кошельков для использования в качестве примеров на протяжении всей книги. Некоторые из них предназначены для мобильных устройств, настольных компьютеров, а другие - для работы в Интернете. Мы выбрали разные кошельки, потому что они представляют собой широкий спектр сложности и функций. Однако выбор этих кошельков не является подтверждением их качества или безопасности. Они просто являются хорошей отправной точкой для демонстраций и тестирования.

((("private keys","wallets and")))Помните, что для того, чтобы приложение кошелька работало, оно должно иметь доступ к вашим личным ключам, поэтому очень важно, чтобы вы загружали и использовали приложение кошелька только из источников, которым вы доверяете. К счастью, в целом, чем популярнее приложение для кошелька, тем более надежным оно, вероятно, будет. Тем не менее, не рекомендуется "класть все яйца в одну корзину" и распределять свои учетные записи Ethereum по нескольким кошелькам.

Ниже приведены некоторые хорошие стартовые кошельки:

MetaMask:: ((("MetaMask")))MetaMask - это кошелек с расширением для браузера, который запускается в вашем браузере (Chrome, Firefox, Opera или Brave Browser). Он прост в использовании и удобен для тестирования, так как способен подключаться к множеству узлов Ethereum и тестировать блокчейны. MetaMask - это веб-кошелек, который также включает в себя мобильные приложения как для iOS, так и для Android.

Jaxx:: ((("Jaxx")))((("wallets","Jaxx")))Jaxx - это мультиплатформенный и мультивалютный кошелек, который работает на различных операционных системах, включая Android, iOS, Windows, macOS и Linux. Это часто хороший выбор для новых пользователей, поскольку он разработан для простоты и удобства использования. Jaxx - это либо мобильный, либо настольный кошелек, в зависимости от того, где вы его устанавливаете.

MyEtherWallet (MEW):: ((("MyEtherWallet (MEW)")))((("wallets","MyEtherWallet")))MyEtherWallet - это в первую очередь веб-кошелек, который работает в любом браузере. Он также доступен на Android и iOS. Он обладает множеством сложных функций, которые мы рассмотрим во многих наших примерах.

Emerald Wallet:: ((("Ethereum Classic (ETC)","Emerald Wallet and")))((("wallets","Emerald Wallet")))((("Emerald Wallet")))Emerald Wallet предназначен для работы с блокчейном Ethereum Classic, но совместим с другими блокчейнами на базе Ethereum. Это настольное приложение с открытым исходным кодом, работающее под управлением Windows, macOS и Linux. Emerald Wallet может запускать полный узел или подключаться к общедоступному удаленному узлу, работая в "легком" режиме. Он также имеет вспомогательный инструмент для выполнения всех операций из командной строки.

Мы начнем с установки Metal Mask на рабочий стол &#x2014; но сначала мы кратко обсудим управление ключами и управление ими.

[[control_responsibility]]
=== Контроль и ответственность

((("Ethereum (generally)","control and responsibility", id="ix_02intro-asciidoc1", range="startofrange")))Открытые блокчейны, такие как Ethereum, важны, потому что они работают как _децентрализованная_ система. Это означает многое, но один важный аспект заключается в том, что каждый пользователь Ethereum может &#x2014; и должен &#x2014; контролировать свои собственные закрытые ключи, которые контролируют доступ к средствам и смарт-контрактам. Мы иногда называем комбинацию доступа к средствам и смарт-контрактам "учетной записью" или "кошельком". Эти термины могут быть довольно сложными по своей функциональности, поэтому мы рассмотрим это более подробно позже. Однако в качестве основополагающего принципа это так же просто, как один закрытый ключ равен одной учетной записи. Некоторые пользователи предпочитают отказаться от контроля над своими секретными ключами, используя стороннего хранителя, такого как онлайн-биржа. В этой книге мы научим вас, как взять под контроль и управлять своими собственными закрытыми ключами.

С контролем приходит большая ответственность. Если вы потеряете свои личные ключи, вы потеряете доступ к своим средствам и контрактам. Никто не сможет помочь вам восстановить доступ &#x2014; ваши средства будут заблокированы навсегда. Вот несколько советов, которые помогут вам справиться с этой ответственностью:

* Не импровизируйте с безопасностью. Используйте стандартные проверенные подходы.

* Чем важнее учетная запись (например, чем выше стоимость контролируемых средств или чем более значимы доступные смарт-контракты), тем более высокие меры безопасности должны быть приняты.

* Самый высокий уровень безопасности обеспечивается устройством изолированные от интернета, но этот уровень не требуется для каждой учетной записи.

* Никогда не храните свой закрытый ключ в открытом виде, особенно в цифровом виде. К счастью, большинство современных пользовательских интерфейсов даже не позволяют вам увидеть закрытый ключ.

* ((("private keys","wallets and")))Закрытые ключи могут храниться в зашифрованном виде в виде цифрового файла "хранилища ключей". Будучи зашифрованными, они нуждаются в пароле для разблокировки. Когда вам будет предложено выбрать пароль, сделайте его надежным (т.е. длинным и случайным), создайте его резервную копию и не делитесь им. Если у вас нет менеджера паролей, запишите его и храните в надежном и секретном месте. Чтобы получить доступ к вашей учетной записи, вам нужен как файл хранилища ключей, так и пароль.

* Не храните никаких паролей в цифровых документах, цифровых фотографиях, скриншотах, онлайн-дисках, зашифрованных PDF-файлах и т.д. Опять же, не импровизируйте с безопасностью. Используйте менеджер паролей или ручку и бумагу.

* Когда вам будет предложено создать резервную копию ключа в виде мнемонической последовательности слов, используйте ручку и бумагу для создания физической резервной копии. Не оставляйте это задание "на потом"; вы забудете. Эти резервные копии можно использовать для восстановления вашего закрытого ключа в случае, если вы потеряете все данные, сохраненные в вашей системе, или если вы забудете или потеряете свой пароль. Однако они также могут быть использованы злоумышленниками для получения ваших личных ключей, поэтому никогда не храните их в цифровом виде, а физическую копию надежно храните в запертом ящике или сейфе.

* Прежде чем переводить какие-либо крупные суммы (особенно на новые адреса), сначала выполните небольшую тестовую транзакцию (например, стоимостью менее 1 доллара) и дождитесь подтверждения получения.

* Когда вы создаете новую учетную запись, начните с отправки только небольшой тестовой транзакции на новый адрес. Как только вы получите тестовую транзакцию, попробуйте отправить ее обратно с этой учетной записи. Существует множество причин, по которым создание учетной записи может пойти не так, и если что-то пошло не так, лучше выяснить это с небольшими потерями. Если тесты работают, все хорошо.

* Исследователи общедоступных блоков - это простой способ независимо проверить, была ли транзакция принята сетью. Однако это удобство негативно сказывается на вашей конфиденциальности, поскольку вы раскрываете свои адреса для программ просмотра блоков, которые могут отслеживать вас.

* Не отправляйте деньги ни на один из адресов, указанных в этой книге. Секретные ключи перечислены в книге, и кто-то немедленно заберет эти деньги.

Теперь, когда мы рассмотрели некоторые основные рекомендации по управлению ключами и безопасности, давайте приступим к работе с помощью MetaMask!(((range="endofrange", startref="ix_02intro-asciidoc1")))

[[installing_MetaMask]]
=== Начало работы с MetaMask

((("Ethereum (generally)","MetaMask basics", id="ix_02intro-asciidoc2", range="startofrange")))((("MetaMask","basics", id="ix_02intro-asciidoc3", range="startofrange")))Откройте браузер Google Chrome и перейдите по ссылке https://chrome.google.com/webstore/category/extensions[].

Найдите MetaMask и нажмите на логотип с изображением лисы. Вы должны увидеть что-то вроде результата, показанного в <<metamask_download>>.

[[metamask_download]]
.Страница сведений о расширении MetaMask Chrome
image::images/metamask_download.png["MetaMask Detail Page"]

Важно убедиться, что вы загружаете настоящее расширение MetaMask, так как иногда людям удается незаметно протащить вредоносные расширения мимо фильтров Google. Настоящий:

* Показывает идентификатор +nkbihfbeogaeaoehlefnkodbefgpgknn+ в адресной строке
* Предлагается https://metamask.io
* Имеет более 1500 отзывов
* Имеет более 1 000 000 пользователей

Как только вы подтвердите, что нашли правильное расширение, нажмите "Добавить в Chrome", чтобы установить его.

[[using_MetaMask]]
==== Создание кошелька

((("MetaMask","wallet setup with", id="ix_02intro-asciidoc4", range="startofrange")))После установки MetaMask вы должны увидеть новый значок (голова лисы) на панели инструментов вашего браузера. Нажмите на нее, чтобы начать работу. Вам будет предложено принять правила и условия, а затем создать свой новый кошелек Ethereum, введя пароль (см. <<metamask_password>>).

[[metamask_password]]
.Страница пароля расширения MetaMask Chrome
image::images/metamask_password.png["MetaMask Password Page"]

[TIP]
====
Пароль контролирует доступ к MetaMask, так что он не может быть использован кем-либо, имеющим доступ к вашему браузеру.
====

((("mnemonic code words","MetaMask and", id="ix_02intro-asciidoc5", range="startofrange")))Как только вы установите пароль, MetaMask сгенерирует для вас кошелек и покажет вам _мнемоническую резервную копию_, состоящую из 12 английских слов (см. <<metamask_mnemonic>>). Эти слова могут быть использованы в любом совместимом кошельке для восстановления доступа к вашим средствам, если что-то случится с MetaMask или вашим компьютером. Для этого восстановления вам не нужен пароль; достаточно 12 слов.

[TIP]
====
Дважды создайте резервную копию своей мнемоники (12 слов) на бумаге. Храните две бумажные резервные копии в двух отдельных безопасных местах, например в огнестойком сейфе, запирающемся ящике или сейфе. Относитесь к бумажным резервным копиям как к наличным деньгам, стоимость которых эквивалентна тому, что вы храните в своем кошельке Ethereum. Любой, у кого есть доступ к этим словам, может получить доступ и украсть ваши деньги.
====

[[metamask_mnemonic]]
.The mnemonic backup of your wallet, created by MetaMask
image::images/metamask_mnemonic.png["MetaMask Mnemonic Page"]

Как только вы подтвердите, что надежно сохранили мнемонику, вы сможете увидеть детали своей учетной записи Ethereum, как показано на <<metamask_account>>.(((range="endofrange", startref="ix_02intro-asciidoc5")))

[[metamask_account]]
.Ваша учетная запись Ethereum в MetaMask
image::images/metamask_account.png["MetaMask Account Page"]

На странице вашей учетной записи отображается имя вашей учетной записи (по умолчанию "Учетная запись 1"), адрес Ethereum (+0x9E713...+ в примере) и красочный значок, который поможет вам визуально отличить эту учетную запись от других учетных записей. В верхней части страницы учетной записи вы можете увидеть, в какой сети Ethereum вы в данный момент работаете (в примере "Основная сеть").

Поздравляю! Вы создали свой первый кошелек Ethereum.(((range="endofrange", startref="ix_02intro-asciidoc4")))

[[switching_networks]]
==== Переключение сетей

((("MetaMask","network choices")))Как вы можете видеть на странице учетной записи MetaMask, вы можете выбирать между несколькими сетями Ethereum. По умолчанию MetaMask попытается подключиться к основной сети. Другими вариантами являются общедоступные тестовые сети, любой узел Ethereum по вашему выбору или узлы, работающие с частными блокчейнами на вашем собственном компьютере (localhost).:

Основная сеть Ethereum:: Основной публичный блокчейн Ethereum. Реальный ETH, реальная ценность и реальные последствия.

Ropsten – тестовая сеть:: Ethereum публично тестирует блокчейн и сеть. ETH в этой сети не имеет никакого значения.

Kovan – тестовая сеть:: Ethereum публично тестирует блокчейн и сеть, используя консенсусный протокол Aura с подтверждением полномочий (интегрированная подпись). ETH в этой сети не имеет никакого значения. Тестовая сеть Kovan поддерживается только по Parity. Другие клиенты Ethereum используют протокол консенсуса Clique, который был предложен позже, для проверки на основе подтверждения полномочий.

Rinkeby – тестовая сеть:: Ethereum публично тестирует блокчейн и сеть, используя протокол Clique консенсус с подтверждением полномочий (интегрированная подпись). ETH в этой сети не имеет никакого значения.

Localhost 8545:: Подключается к узлу, работающему на том же компьютере, что и браузер. Узел может быть частью любого публичного блокчейна (основной или тестовой сети) или частной тестовой сети.

Свой RPC:: Позволяет подключать MetaMask к любому узлу с помощью интерфейса удаленного вызова процедур (RPC), совместимого с Geth. Узел может быть частью любого публичного или частного блокчейна.

[NOTE]
====
Ваш кошелек MetaMask использует один и тот же закрытый ключ и адрес Ethereum во всех сетях, к которым он подключается. Однако баланс вашего адреса Ethereum в каждой сети Ethereum будет разным. Например, ваши ключи могут управлять эфиром и контрактами в Ropsten, но не в основной сети.
====

[[getting_test_eth]]
==== Получим немного тестового Эфира

((("ether (generally)","testnet")))((("MetaMask","and testnet ether")))((("test ether","obtaining")))((("testnet","ether for")))((("wallets","testnet ether and")))Ваша первая задача - пополнить свой кошелек. Вы не будете делать этого в основной сети, потому что реальный трафик стоит денег, а для его обработки требуется немного больше опыта. На данный момент вы загрузите в свой кошелек немного "тестового" эфира.

((("Ropsten Test Network")))Переключите MetaMask на _тестовую сеть Ropsten_. Нажмите кнопку "Внести депозит", затем нажмите кнопку "Ropsten Test Faucet". MetaMask откроет новую веб-страницу, как показано на <<metamask_ropsten_faucet>>.

[[metamask_ropsten_faucet]]
.MetaMask Ropsten Test Faucet
image::images/metamask_ropsten_faucet.png["MetaMask Ropsten Test Faucet"]

Вы можете заметить, что веб-страница уже содержит Ethereum-адрес вашего кошелька MetaMask. MetaMask интегрирует веб-страницы с поддержкой Ethereum с вашим кошельком MetaMask и может "находить" адреса Ethereum на веб-странице, позволяя вам, например, отправлять платеж в интернет-магазин, отображающий адрес Ethereum. MetaMask также может заполнить веб-страницу адресом вашего собственного кошелька в качестве адреса получателя, если веб-страница запрашивает его. На этой странице приложение faucet запрашивает у MetaMask адрес кошелька для отправки тестового эфира.

Нажмите зеленую кнопку "запросить 1 эфир с faucet". Вы увидите, что в нижней части страницы появится идентификатор транзакции. Приложение faucet создало транзакцию - платеж для вас. Идентификатор транзакции выглядит следующим образом:

[[faucet_tx_id]]
----
0x7c7ad5aaea6474adccf6f5c5d6abed11b70a350fbc6f9590109e099568090c57
----

Через несколько секунд новая транзакция будет добыта майнерами Ropsten, и ваш кошелек MetaMask покажет баланс в размере 1 ETH. Нажмите на идентификатор транзакции, и ваш браузер перенесет вас на _программу для просмотра блоков_ (_block explorer_), который представляет собой веб-сайт, позволяющий визуализировать и исследовать блоки, адреса и транзакции. MetaMask использует https://etherscan.io/[Etherscan block explorer], один из самых популярных обозревателей блоков Ethereum. Транзакция, содержащая платеж с тестового крана Ropsten, показана в <<ropsten_block_explorer>>.

[[ropsten_block_explorer]]
.Etherscan Ropsten обозреватель блоков
image::images/ropsten_block_explorer.png["Etherscan Ropsten Block Explorer"]

Транзакция была записана в блокчейне Ropsten и может быть просмотрена в любое время любым пользователем, просто выполнив поиск по идентификатору транзакции или http://bit.ly/2Q860Wk[перейдя по ссылке].

Попробуйте перейти по этой ссылке или ввести хэш транзакции на веб-сайте _ropsten.etherscan.io_, чтобы убедиться в этом сами.

[[sending_eth_MetaMask]]
==== Отправка эфира из MetaMask

((("MetaMask","sending ether from", id="ix_02intro-asciidoc6", range="startofrange")))((("test ether","sending", id="ix_02intro-asciidoc7", range="startofrange")))После того, как вы получили свой первый тестовый эфир из Ropsten Test Faucet, вы можете поэкспериментировать с отправкой любого из них, попытавшись отправить некоторые обратно в сеть. Как вы можете видеть на странице Ropsten Test Faucet, есть возможность "пожертвовать" 1 ETH в сеть. Эта опция доступна для того, чтобы после завершения тестирования вы могли вернуть оставшуюся часть своего тестового эфира, чтобы кто-то другой мог использовать его в следующий раз. Несмотря на то, что тестовый эфир не имеет никакой ценности, некоторые люди копят его, что затрудняет использование тестовых сетей всеми остальными. Накопление тестового эфира не одобряется!

К счастью, мы не являемся тестовыми накопителями эфира. Нажмите оранжевую кнопку "1 эфир", чтобы указать MetaMask создать транзакцию, отправляющую 1 эфир обратно в сеть. MetaMask подготовит транзакцию и откроет окно с подтверждением, как показано на <<send_to_faucet>>.


[[send_to_faucet]]
.Отправка 1 эфира в сеть
image::images/send_to_faucet.png["Sending 1 ether to the faucet"]

Упс! Вы, вероятно, заметили, что не можете завершить транзакцию &#x2014; MetaMask говорит, что у вас недостаточный баланс. На первый взгляд это может показаться запутанным: у вас есть 1 ETH, вы хотите отправить 1 ETH, так почему же MetaMask говорит, что у вас недостаточно средств?

((("gas","basics")))Ответ заключается в стоимости _газа_ (_gas_). Каждая транзакция Ethereum требует уплаты комиссии, которая собирается майнерами для подтверждения транзакции. Сборы в Ethereum взимаются в виртуальной валюте, называемой газ. Вы платите за газ эфиром, как часть транзакции.

[NOTE]
====
((("gas","on test networks")))Плата также взимается в тестовых сетях. Без платы тестовая сеть вела бы себя иначе, чем основная сеть, что делало бы ее неадекватной платформой для тестирования. Сборы также защищают тестовые сети от DoS-атак и плохо сконструированных контрактов (например, бесконечных циклов), так же как они защищают основную сеть.
====

Когда вы отправляли транзакцию, MetaMask рассчитала среднюю цену на газ для недавних успешных транзакций в размере 3 гвей, что означает гигавей. Вей - самая маленькая pass:[<span class="keep-together">единица</span>]валюты эфира, как мы обсуждали в <<ether_units>>. Лимит газа устанавливается на основе стоимости отправки базовой транзакции, которая составляет 21 000 единиц газа. Таким образом, максимальная сумма ETH, которую вы потратите, составляет 3 * 21 000 gwei = 63 000 gwei = 0,000063 ETH. (Имейте в виду, что средние цены на газ могут колебаться, поскольку они в основном определяются майнерами. В следующей главе мы увидим, как вы можете увеличить / уменьшить свой лимит газа, чтобы при необходимости ваша транзакция имела приоритет.)

Все это для того, чтобы сказать: совершение транзакции в 1 ETH стоит 1.000063 ETH. MetaMask сбивает с толку округляя вниз до 1 ETH при отображении общей суммы, но фактическая сумма, которая вам нужна, составляет 1.000063 ETH, а у вас есть только 1 ETH. Нажмите кнопку Отклонить, чтобы отменить эту транзакцию.

Давайте возьмем еще немного тестового эфира! Снова нажмите зеленую кнопку "запросить 1 эфир с крана" и подождите несколько секунд. Не волнуйтесь, в кране должно быть много эфира, и он даст вам больше, если вы попросите.

Как только у вас будет баланс в 2 ETH, вы можете попробовать еще раз. На этот раз, когда вы нажимаете оранжевую кнопку пожертвования "1 эфира", у вас есть достаточный баланс для завершения транзакции. Нажмите кнопку Отправить, когда откроется окно оплаты MetaMask. После всего этого вы должны увидеть баланс в размере 0,999937 ETH, потому что вы отправили 1 ETH в кран с 0,000063 ETH в газе.(((range="endofrange", startref="ix_02intro-asciidoc7")))(((range="endofrange", startref="ix_02intro-asciidoc6")))

[[explore_tx_history]]
==== Изучение истории транзакций по адресу

((("addresses","exploring transaction history of", id="ix_02intro-asciidoc8", range="startofrange")))((("MetaMask","exploring transaction history of an address with", id="ix_02intro-asciidoc9", range="startofrange")))К настоящему времени вы стали экспертом в использовании MetaMask для отправки и получения тестового эфира. Ваш кошелек получил по крайней мере два платежа и отправил по крайней мере один. Вы можете просмотреть все эти транзакции с помощью обозревателя блоков _ropsten.etherscan.io_. Вы можете либо скопировать адрес своего кошелька и вставить его в поле поиска block explorer, либо попросить MetaMask открыть страницу для вас. Рядом со значком вашей учетной записи в MetaMask вы увидите кнопку с тремя точками. Нажмите на нее, чтобы отобразить меню параметров, связанных с учетной записью (см. <<metamask_account_context_menu>>).

[[metamask_account_context_menu]]
.MetaMask account context menu
image::images/metamask_account_context_menu.png["MetaMask Account Context Menu"]

Выберите "Просмотреть учетную запись в Etherscan", чтобы открыть веб-страницу в проводнике блоков, содержащую историю транзакций вашей учетной записи, как показано на <<block_explorer_account_history>>.

[[block_explorer_account_history]]
.История транзакций адреса в Etherscan
image::images/block_explorer_account_history.png["Address Transaction History on Etherscan"]

Здесь вы можете просмотреть всю историю транзакций вашего адреса Ethereum. Он показывает все транзакции, записанные в блокчейне Ropsten, где ваш адрес является отправителем или получателем. Нажмите на некоторые из этих транзакций, чтобы увидеть более подробную информацию.

Вы можете просмотреть историю транзакций по любому адресу. Взгляните на историю транзакций адреса тестового крана Ropsten (подсказка: это адрес "отправителя", указанный в самом старом платеже на ваш адрес). Вы можете видеть весь тестовый эфир, отправленный с крана вам и на другие адреса. Каждая транзакция, которую вы видите, может привести вас к большему количеству адресов и большему количеству транзакций. Очень скоро вы заблудитесь в лабиринте взаимосвязанных данных. Публичные блокчейны содержат огромное количество информации, которую можно исследовать программно, как мы увидим в будущих примерах(((range="endofrange", startref="ix_02intro-asciidoc9")))(((range="endofrange", startref="ix_02intro-asciidoc8"))).(((range="endofrange", startref="ix_02intro-asciidoc3")))(((range="endofrange", startref="ix_02intro-asciidoc2")))

[[intro_world_computer]]
=== Знакомство с мировым компьютером

((("Ethereum (generally)","and EVM")))((("EVM (Ethereum Virtual Machine)","as world computer")))((("world computer, Ethereum as")))Теперь вы создали кошелек и отправляете и получаете эфир. До сих пор мы рассматривали Ethereum как криптовалюту. Но Эфириум - это гораздо, гораздо больше. Фактически, функция криптовалюты подчинена функции Ethereum как децентрализованного мирового компьютера. ((("smart contracts","ether and")))Эфир предназначен для оплаты запуска _смарт-контрактов_ (_smart contracts_), которые представляют собой компьютерные программы, работающие на виртуальном компьютере, называемом _Ethereum Virtual Machine_ (EVM).

EVM - это глобальный синглтон, что означает, что он работает так, как если бы это был глобальный компьютер с одним экземпляром, работающий везде. Каждый узел в сети Ethereum запускает локальную копию EVM для проверки исполнения контракта, в то время как блокчейн Ethereum записывает изменяющееся _состояние_ этого мирового компьютера по мере обработки транзакций и смарт-контрактов. Мы обсудим это гораздо более подробно в <<evm_chapter>>.

[[EOA_contracts]]
=== Счета, принадлежащие внешним лицам (EOAS), и контракты

((("contract accounts", seealso="smart contracts")))((("EOA (Externally Owned Account)","basics")))((("Ethereum (generally)","EOAs and contracts")))((("smart contracts","basics")))Тип учетной записи, которую вы создали в кошельке MetaMask, называется _учетной записью, принадлежащей внешнему владельцу_ (_externally owned account_) (EOA). Такие учетные записи - это те, которые имеют приватный ключ; наличие приватного ключа означает контроль над доступом к средствам или контрактам. Теперь вы, вероятно, догадываетесь, что существует другой тип учетной записи. Этот другой тип учетной записи - это _контрактная учетная запись_ (_contract account_). Контрактная учетная запись имеет код смарт-контракта, которого не может быть у простого EOA. Кроме того, контрактная учетная запись не имеет приватного ключа. Вместо этого, владение и контроль осуществляется логикой кода его смарт-контракта: программой, записанной в блокчейне Ethereum при создании учетной записи контракта и выполняемой EVM.

Контракты имеют адреса, как и EOAs. Контракты также могут отправлять и получать эфир, как и EOAs. Однако, когда адресатом транзакции является адрес контракта, это приводит к тому, что этот контракт _выполняется_ (_run_) в EVM, используя транзакцию и данные транзакции в качестве входных данных. В дополнение к эфиру транзакции могут содержать _данные_ (_data_), указывающие, какую конкретную функцию в контракте запускать и какие параметры передавать этой функции. Таким образом, транзакции могут _вызывать_ (_call_) функции внутри контрактов.

Обратите внимание, что, поскольку контрактная учетная запись (contract account) не имеет закрытого ключа, она не может _инициировать_ (_initiate_) транзакцию. Только EOAS могут инициировать транзакции, но контракты могут _реагировать_ (_react_) на транзакции, вызывая другие контракты, создавая сложные пути выполнения. Одним из типичных применений этого является EOA, отправляющая запрос-транзакцию в кошелек смарт-контракта с несколькими подписями для отправки некоторого количества ETH на другой адрес. Типичный шаблон программирования DApp заключается в том, чтобы Контракт A вызывал Контракт B для поддержания общего состояния между пользователями Контракта A.

В следующих нескольких разделах мы напишем наш первый контракт. Затем вы узнаете, как создать, финансировать и использовать этот контракт с вашим кошельком MetaMask, а также протестировать эфир в тестовой сети Ropsten.

[[simple_contract_example]]
=== Простой контракт: тестовый эфирный кран

((("contract accounts","creating", seealso="Faucet.sol contract", id="ix_02intro-asciidoc10", range="startofrange")))((("Faucet.sol contract (test example)","creating", id="ix_02intro-asciidoc11", range="startofrange")))В Ethereum есть много различных языков высокого уровня, все из которых можно использовать для написания контракта и создания байт-кода виртуальной машины. Вы можете прочитать о многих наиболее выдающихся и интересных из них в <<высокоуровневые языки>>. Один язык высокого уровня на сегодняшний день является доминирующим выбором для программирования смарт-контрактов: Solidity. ((("Wood, Dr. Gavin","and Solidity")))Solidity был создан доктором Гэвином Вудом, соавтором этой книги, и стал наиболее широко используемым языком в Ethereum (и за его пределами). Мы будем использовать Solidity для написания нашего первого контракта.

((("Solidity","faucet.sol and")))Для нашего первого примера (<<solidity_faucet_example>>), мы напишем контракт, который управляет _краном_ (_faucet_). Вы уже использовали кран для получения тестового эфира в тестовой сети Ropsten. Кран - это относительно простая вещь: он выдает эфир на любой адрес, который запрашивает эфир, и может периодически пополняться. Вы можете реализовать кран как кошелек, управляемый человеком или веб-сервером.

[[solidity_faucet_example]]
.Faucet.sol: Solidity контракт, реализующий кран
====
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----
====

[NOTE]
====
Вы найдете все примеры кода для этой книги в подкаталоге _code_ https://github.com/ethereumbook/ethereumbook/[репозиторий книги на GitHub]. В частности, наш контракт _Faucet.sol_ находится в:

----
code/Solidity/Faucet.sol
----
====

Это очень простой контракт, настолько простой, насколько мы можем его составить. Это также _уязвимый_ (_flawed_) контракт, демонстрирующий ряд плохих практик и уязвимостей в системе безопасности. Мы узнаем, изучив все его недостатки в последующих разделах. Но пока давайте рассмотрим, что делает этот контракт и как он работает, строка за строкой. Вы быстро заметите, что многие элементы Solidity похожи на существующие языки программирования, такие как JavaScript, Java или Cpass:[++].

Первая строка - это комментарий:

[[comment]]
[source,solidity]
----
// SPDX-License-Identifier: CC-BY-SA-4.0
----

Комментарии предназначены для чтения людьми и не включаются в байт-код исполняемой виртуальной машины. Обычно мы помещаем их в строку перед кодом, который пытаемся объяснить, а иногда и в ту же строку. Комментарии начинаются с двух косых черт: +//+. Все, начиная с первой косой черты и заканчивая концом этой строки, обрабатывается так же, как пустая строка, и игнорируется.

Несколькими строками позже начинается наш фактический контракт:

[[contract_definition]]
[source,solidity]
----
contract Faucet {
----

Эта строка объявляет объект +contract+, аналогично объявлению +class+ в других объектно-ориентированных языках. Определение контракта включает в себя все строки, заключенные в фигурные скобки (pass:[<code>{}</code>]), которые определяют _область видимости_ (_scope_), очень похоже на то, как фигурные скобки используются во многих других языках программирования.

Далее мы разрешаем контракту принимать любую входящую сумму:

[[receive_function]]
[source,solidity]
----
receive () external payable {}
----

((("receive function")))Функция приема вызывается, если транзакция, которая инициировала контракт, не называла ни одну из объявленных функций в контракте или не содержала данных и, таким образом, была простой передачей эфира. Контракты могут иметь одну такую функцию приема (без имени), и она используется для получения эфира. Вот почему он определяется как внешняя и оплачиваемая функция, что означает, что он может принимать эфир в контракт. Он ничего не делает, кроме как принимает эфир, на что указывает пустое определение в фигурных скобках pass:[(<code>{}</code>)]. Если мы совершим транзакцию, которая отправит эфир на адрес контракта, как если бы это был кошелек, эта функция обработает его.

После этого мы объявляем первую функцию +Faucet+ контракта:

[[withdraw_function]]
[source,solidity]
----
function withdraw(uint withdraw_amount) public {
----

Функция называется +withdraw+, и она принимает один аргумент: целое число без знака (+uint+) с именем +withdraw_amount+. Она объявлена как общедоступная функция, что означает, что она может быть вызвана другими контрактами. Ниже приводится определение функции, заключенное в фигурные скобки. Первая часть функции +withdraw_amount+ устанавливает лимит на вывод средств:

[[withdraw_limit]]
[source,solidity]
----
require(withdraw_amount <= 100000000000000000);
----

Она использует встроенную в Solidity функцию +require+ для проверки предварительного условия, что +withdraw_amount+ меньше или равно 100 000 000 000 000 000 wei, что является базовой единицей эфира (см. <<ether_denominations>>) и эквивалентно 0.1 эфира. Если функция +withdraw+ вызывается с +withdraw_amount+, превышающим эту сумму, функция +require+ здесь приведет к остановке выполнения контракта и сбою с _исключением_ (_exception_). Обратите внимание, что операторы должны завершаться точкой с запятой в Solidity.

Эта часть контракта является основной логикой нашей работы. Он контролирует поток средств из контракта, устанавливая лимит на снятие средств. Это очень простое управление, но оно может дать вам представление о мощи программируемого блокчейна: децентрализованного программного обеспечения, управляющего деньгами.

Далее следует фактический вывод средств:

[[withdraw_command]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Здесь происходит пара интересных вещей. Объект +msg+ является одним из входных данных, к которому могут получить доступ все контракты. Он представляет транзакцию, которая привела к исполнению этого контракта. Атрибут +sender+ - это адрес отправителя транзакции. Функция +transfer+ - это встроенная функция, которая переводит эфир из текущего контракта на адрес отправителя. Читая его в обратном порядке, это означает _переведи отправителю транзакции_ (_transfer to the sender of the msg_), которое инициировало выполнение этого контракта. Функция +transfer+ принимает сумму в качестве своего единственного аргумента. Мы передаем значение +withdraw_amount+, которое было параметром, функции +withdraw+, объявленной несколькими строками ранее.

Следующая строка - это закрывающая фигурная скобка, указывающая на конец определения нашей функции +withdraw+.

Прямо под нашей функцией по умолчанию находится заключительная закрывающая фигурная скобка, которая закрывает определение контракта +Faucet+. Вот и все!(((range="endofrange", startref="ix_02intro-asciidoc11")))(((range="endofrange", startref="ix_02intro-asciidoc10")))

[[compile_faucet_contract]]
=== Компиляция контракта Faucet

((("compiling","Faucet.sol contract", id="ix_02intro-asciidoc12", range="startofrange")))((("Faucet.sol contract (test example)","compiling", id="ix_02intro-asciidoc13", range="startofrange")))Теперь, когда у нас есть наш первый пример контракта, нам нужно использовать компилятор Solidity для преобразования кода Solidity в байт-код EVM, чтобы он мог быть выполнен EVM на самом блокчейне.

Компилятор Solidity поставляется в виде отдельного исполняемого файла, как часть различных фреймворков, а также в комплекте с интегрированными средами разработки (IDE). Чтобы упростить задачу, мы будем использовать одну из наиболее популярных IDE, называемую _Remix_.

((("Remix IDE")))Используйте свой браузер Chrome (с кошельком MetaMask, который вы установили ранее), чтобы перейти к Remix IDE по адресу https://remix.ethereum.org[].

Когда вы впервые загрузите Remix, он запустится с примером контракта с именем _ballot.sol_. Нам это не нужно, поэтому закройте его, нажав +x+ в углу вкладки, как показано на <<remix_close_tab>>.

[[remix_close_tab]]
.Закройте вкладку с примером по умолчанию
image::images/remix_close_tab.png["Close the default example tab"]

Теперь добавьте новую вкладку, нажав на круглый знак плюс на верхней левой панели инструментов, как показано на <<remix_toolbar>>. Назовите новый файл _Faucet.sol_.

[[remix_toolbar]]
.Нажмите на знак плюс, чтобы открыть новую вкладку
image::images/remix_toolbar.png["Click the plus sign to open a new tab"]

Как только у вас откроется новая вкладка, скопируйте и вставьте код из нашего примера _Faucet.sol_, как показано на <<remix_faucet_load>>.

[[remix_faucet_load]]
.Скопируйте пример кода крана в новую вкладку
image::images/remix_faucet_load.png["Copy the Faucet example code into the new tab"]

Как только вы загрузили контракт _Faucet.sol_ в среду разработки Remix IDE, среда разработки автоматически скомпилирует код. Если все пройдет хорошо, вы увидите справа, под вкладкой Компиляции, зеленое поле с надписью "Faucet", подтверждающее успешную компиляцию (см. <<remix_compile>>).

[[remix_compile]]
.Remix успешно компилирует контракт Faucet.sol
image::images/remix_compile.png[""]

Если что-то пойдет не так, наиболее вероятная проблема заключается в том, что среда разработки Remix использует версию компилятора Solidity, отличную от версии 0.6. В этом случае наша директива pragma предотвратит компиляцию _Faucet.sol_. Чтобы изменить версию компилятора, перейдите на вкладку "Настройки", установите версию 0.6.0 и повторите попытку.

Компилятор Solidity теперь скомпилировал наш файл _Faucet.sol_ в байт-код виртуальной машины. Если вам интересно, байт-код выглядит следующим образом:

[[faucet_bytecode]]
----
PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0xF4 DUP1 PUSH2 0x1F PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH1 0x1F JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x2E1A7D4D EQ PUSH1 0x2A JUMPI PUSH1 0x25 JUMP JUMPDEST CALLDATASIZE PUSH1 0x25 JUMPI STOP JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH1 0x35 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x5F PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH1 0x4A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH1 0x61 JUMP JUMPDEST STOP JUMPDEST PUSH8 0x16345785D8A0000 DUP2 GT ISZERO PUSH1 0x75 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH2 0x8FC DUP3 SWAP1 DUP2 ISZERO MUL SWAP1 PUSH1 0x40 MLOAD PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO DUP1 ISZERO PUSH1 0xBA JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 STOP CODECOPY 0xDC DUP16 0xD SGT PUSH6 0xD2245039EDD7 RETURN CALLDATALOAD 0xC2 0xE4 SWAP9 0xF6 0x2C 0xF8 0xB3 OR JUMPDEST 0xAC 0xD8 CREATE2 SSTORE 0x4E SIGNEXTEND PUSH4 0x3164736F PUSH13 0x634300060C0033000000000000
----

Разве вы не рады, что используете язык высокого уровня, такой как Solidity, вместо программирования непосредственно в байт-коде виртуальной машины? Я рад!(((range="endofrange", startref="ix_02intro-asciidoc13")))(((range="endofrange", startref="ix_02intro-asciidoc12")))

[[create_contract]]
=== Создание контракта на блокчейне

((("blockchain","creating contract on", id="ix_02intro-asciidoc14", range="startofrange")))((("Faucet.sol contract (test example)","on the blockchain", id="ix_02intro-asciidoc15", range="startofrange")))Итак, у нас есть контракт. Мы скомпилировали его в байт-код. Теперь нам нужно "зарегистрировать" контракт на блокчейне Ethereum. Мы будем использовать тестовую сеть Ropsten для тестирования нашего контракта, так что это тот блокчейн, на который мы хотим его отправить.

((("zero address","contract registration")))Регистрация контракта в блокчейне предполагает создание специальной транзакции, адресатом которой является адрес +0x00000000000000000000000000000000000000000000+, также известный как _нулевой адрес_ (_zero address_). Нулевой адрес - это специальный адрес, который сообщает блокчейну Ethereum, что вы хотите зарегистрировать контракт. К счастью, среда разработки Remix IDE обработает все это за вас и отправит транзакцию в MetaMask.

((("Remix IDE", id="ix_02intro-asciidoc16", range="startofrange")))Сначала перейдите на вкладку Run и выберите Injected Web 3 в раскрывающемся списке Environment. Это позволяет подключить Remix IDE к кошельку MetaMask, а через MetaMask - к тестовой сети Ropsten. Как только вы это сделаете, вы сможете увидеть Ropsten в поле Environment. Кроме того, в поле выбора учетной записи отображается адрес вашего кошелька (см. <<remix_run>>).

[[remix_run]]
.Вкладка запуска Remix IDE с выбранной средой внедрения Web3
image::images/remix_run.png["Remix IDE Run tab, with Injected Web3 environment selected"]

Прямо под настройками запуска, которые вы только что подтвердили, находится готовый к созданию контракт +Faucet+. Нажмите на кнопку Deploy, показанную в <<remix_run>>.

Remix создаст специальную транзакцию с "созданием контракта", и MetaMask попросит вас одобрить ее, как показано в <<remix_metamask_create>>. Вы заметите, что транзакция создания контракта не содержит эфира, но она содержит 275 байт данных (скомпилированный контракт) и будет потреблять 3 gwei газа. Нажмите кнопку Подтвердить, чтобы утвердить его.

[[remix_metamask_create]]
.MetaMask, показывающий транзакцию с созданием контракта
image::images/remix_metamask_create.png["MetaMask showing the contract creation transaction"]

Теперь вам придется подождать. Для майнинга контракта на Ropsten потребуется от 15 до 30 секунд. Похоже, что вы ничего особенного не делаете, но наберитесь терпения.

Как только контракт будет создан, он появится в нижней части вкладки Выполнить (см. <<remix_contract_interact>>).

[[remix_contract_interact]]
.Контракт на кран ЖИВ!
image::images/remix_contract_interact.png["The Faucet contract is ALIVE!"]

Обратите внимание, что контракт +Faucet+ теперь имеет собственный адрес: Remix показывает его как &#x201c;Faucet в 0x72e...c7829 &#x201d; (хотя ваш адрес, случайные буквы и цифры, будут отличаться). Маленький символ буфера обмена справа позволяет скопировать адрес контракта в буфер обмена. Мы будем использовать это в следующем разделе.(((range="endofrange", startref="ix_02intro-asciidoc16")))(((range="endofrange", startref="ix_02intro-asciidoc15")))

[[interact_contract]]
=== Взаимодействие с контрактом

((("Faucet.sol contract (test example)","interacting with", id="ix_02intro-asciidoc17", range="startofrange")))Давайте резюмируем то, что мы узнали до сих пор: контракты Ethereum - это программы, управляющие деньгами, которые выполняются внутри виртуальной машины, называемой EVM. Они создаются с помощью специальной транзакции, которая отправляет их байт-код для записи в блокчейн. Как только они создаются на блокчейне, у них есть адрес Ethereum, как и у кошельков. Каждый раз, когда кто-то отправляет транзакцию на адрес контракта, это приводит к запуску контракта в EVM с транзакцией в качестве входных данных. Транзакции, отправленные на pass:[<span class="keep-together">контракт</span>]-адреса могут содержать эфир или данные, или и то, и другое. Если они содержат эфир, он "депонируется" на баланс контракта. Если они содержат данные, данные могут указывать именованную функцию в контракте и вызывать ее, передавая аргументы функции.

[[view_contract_address]]
==== Просмотр адреса контакта в обозревателе блоков

((("Faucet.sol contract (test example)","viewing contract address in a block explorer")))Теперь у нас есть контракт, записанный в блокчейне, и мы видим, что у него есть адрес Ethereum. Давайте проверим это в проводнике блоков _ropsten.etherscan.io_ и посмотрим, как выглядит контракт. В среде разработки Remix скопируйте адрес контракта, щелкнув значок буфера обмена рядом с его именем (см. <<remix_contract_address>>).

[[remix_contract_address]]
.Скопируйте адрес контракта из Remix
image::images/remix_contract_address.png["Copy the contract address from Remix"]

Держите ремикс открытым; мы вернемся к нему позже. Теперь перейдите в своем браузере на страницу _ropsten.etherscan.io_ и вставьте адрес в поле поиска. Вы должны увидеть историю адресов Ethereum контракта, как показано на <<etherscan_contract_address>>.(((range="endofrange", startref="ix_02intro-asciidoc17")))

[[etherscan_contract_address]]
.Просмотр адреса контракта Faucet в обозревателе блоков Etherscan
image::images/etherscan_contract_address.png["View the Faucet contract address in the etherscan block explorer"]

[[fund_contract]]
==== Финансирование контракта

((("Faucet.sol contract (test example)","sending ether to", id="ix_02intro-asciidoc18", range="startofrange")))На данный момент в истории контракта есть только одна транзакция: транзакция создания контракта. Как вы можете видеть, в контракте также нет эфира (нулевой баланс). Это потому, что мы не отправили никакого эфира в контракт в транзакции создания, хотя могли бы это сделать.

Наш кран нуждается в средствах! Наш первый проект будет заключаться в использовании MetaMask для отправки эфира в контракт. У вас все еще должен быть адрес контракта в вашем буфере обмена (если нет, скопируйте его снова из Remix). Откройте MetaMask и отправьте на него 1 эфир, точно так же, как вы бы отправили на любой другой адрес Ethereum (см. <<metamask_send_to_contract>>).

[[metamask_send_to_contract]]
.Отправьте 1 эфир на адрес контракта
image::images/metamask_send_to_contract.png[""]

Через минуту, если вы перезагрузите Etherscan block explorer, он покажет другую транзакцию на адрес контракта и обновленный баланс в размере 1 эфира.

Помните неназванную внешнюю платежную функцию по умолчанию в нашем коде _Faucet.sol_? Это выглядело примерно так:

[[receive_function_review]]
[source,solidity]
----
receive () external payable {}
----

Когда вы отправляли транзакцию на адрес контракта без каких-либо данных, указывающих, какую функцию вызывать, она вызывала эту функцию по умолчанию. Поскольку мы объявили его как +payable+, он принял и внес 1 эфир на баланс счета контракта. Ваша транзакция привела к запуску контракта в EVM, обновив его баланс. Вы профинансировали свой кран!(((range="endofrange", startref="ix_02intro-asciidoc18")))

[[withdraw_from_contract]]
==== Извлечем эфир из нашего контракта

((("Faucet.sol contract (test example)","withdrawing funds from", id="ix_02intro-asciidoc19", range="startofrange")))((("withdrawal of funds from contract", id="ix_02intro-asciidoc20", range="startofrange")))Далее давайте снимем часть средств с крана. Чтобы вывести средства, мы должны создать транзакцию, которая вызывает функцию +withdraw+ и передает ей аргумент +withdraw_amount+. Чтобы пока все было просто, Remix сконструирует эту транзакцию для нас, а MetaMask представит ее на наше одобрение.

Вернитесь на вкладку Remix и посмотрите на контракт на вкладке Run. Вы должны увидеть оранжевую кнопку +withdraw+ с полем для ввода с надписью +uint256 withdraw_amount+ (см. <<remix_contract_withdraw>>).

[[remix_contract_withdraw]]
.Функция вывода Faucet.sol, в Remix
image::images/remix_contract_interact.png["The withdraw function of Faucet.sol, in Remix"]

Это интерфейс ремикса к контракту. Это позволяет нам создавать транзакции, которые вызывают функции, определенные в контракте. Мы введем +withdraw_amount+ и нажмем кнопку вывода, чтобы сгенерировать транзакцию.

Во-первых, давайте разберемся с +withdraw_amount+. Мы хотим попытаться вывести 0.1 эфира, что является максимальной суммой, разрешенной нашим контрактом. Помните, что все значения валюты в Ethereum внутренне выражены в wei, и наша функция +withdraw+ ожидает, что значение +withdraw_amount+ также будет выражено в wei. Сумма, которую мы хотим, составляет 0.1 эфира, что составляет 100 000 000 000 000 000 вей (1, за которым следуют 17 нулей).



[TIP]
====
Из-за ограничения в JavaScript число размером до 10^17 не может быть обработано Remix. Вместо этого мы заключаем его в двойные кавычки, чтобы позволить Remix получать его как строку и манипулировать им как +BigNumber+. Если мы не заключим его в кавычки, среда разработки Remix не сможет обработать его и отобразит "Аргументы кодирования ошибок: Ошибка: Ошибка утверждения".
====

Введите "100000000000000000" (с кавычками) в поле +withdraw_amount+ и нажмите на кнопку вывода средств (см. <<remix_withdraw>>).

[[remix_withdraw]]
.Нажмите "withdraw" в Remix, чтобы создать транзакцию вывода средств
image::images/remix_withdraw.png[""]

MetaMask откроет окно транзакции, которое вы должны одобрить. Нажмите кнопку Подтвердить, чтобы отправить в контракт запрос на вывод средств (см. <<metamask_withdraw>>).

[[metamask_withdraw]]
.Транзакция MetaMask для вызова функции вывода средств
image::images/metamask_withdraw.png["MetaMask transaction to call the withdraw function"]

Подождите минуту, а затем перезагрузите обозреватель блоков Etherscan, чтобы увидеть транзакцию, отраженную в истории адресов +Faucet+ contract. (см. <<etherscan_withdrawal_tx>>).

[[etherscan_withdrawal_tx]]
.Etherscan показывает транзакцию, вызывающую функцию вывода средств
image::images/etherscan_withdrawal_tx.png["Etherscan shows the transaction calling the withdraw function"]


Теперь мы видим новую транзакцию с адресом контракта в качестве пункта назначения и значением 0 ether. Баланс контракта изменился и теперь составляет 0.9 эфира, потому что он отправил нам 0.1 эфира по запросу. Но мы не видим транзакции "OUT" в _истории адресов контракта_ (_contract address history_).

Где исходящий вывод средств? На странице истории адресов контракта появилась новая вкладка с названием "Внутренние транзакции". ((("internal transaction (message)")))Поскольку передача 0.1 ether произошла из кода контракта, это внутренняя транзакция (также называемая _message_). Нажмите на эту вкладку, чтобы увидеть ее (см. <<etherscan_withdrawal_internal>>).


Эта "внутренняя транзакция" была отправлена контрактом в этой строке кода (из pass:[<code><span class="keep-together">withdraw</span></code>] функции в _Faucet.sol_):

[[withdraw_command_review]]
[source,solidity]
----
msg.sender.transfer(withdraw_amount);
----

Напомним: вы отправили транзакцию из своего кошелька MetaMask, которая содержала инструкции по передаче данных для вызова функции +withdraw+ с аргументом +withdraw_amount+ равным 0.1 эфира. Эта транзакция привела к запуску контракта внутри EVM. Поскольку EVM запустил функцию +withdraw+ контракта +Faucet+, сначала он вызвал функцию +require+ и подтвердил, что запрошенная сумма была меньше или равна максимально допустимому выводу 0.1 эфира. Затем он вызвал функцию +transfer+, чтобы отправить вам эфир. Запуск функции +transfer+ сгенерировал внутреннюю транзакцию, которая внесла 0.1 эфира на адрес вашего кошелька с баланса контракта. Это тот, который показан на вкладке Внутренние транзакции в Etherscan(((range="endofrange", startref="ix_02intro-asciidoc20")))(((range="endofrange", startref="ix_02intro-asciidoc19"))).(((range="endofrange", startref="ix_02intro-asciidoc14")))

[[etherscan_withdrawal_internal]]
.Etherscan показывает внутреннюю транзакцию, выводящую эфир из контракта
image::images/etherscan_withdrawal_internal.png["Etherscan shows the internal transaction transferring ether out from the contract"]

[[intro_conclusion]]
=== Заключение

В этой главе вы настраивали кошелек с помощью MetaMask и пополняли его с помощью крана в тестовой сети Ropsten. Вы получили эфир на Ethereum-адрес своего кошелька, затем отправили эфир на Ethereum-адрес крана.

Затем вы написали контракт на кран в Solidity. Вы использовали IDE Remix для компиляции контракта в байт-код EVM, затем использовали Remix для формирования транзакции и создали контракт +Faucet+ на блокчейне Ropsten. После создания контракт +Faucet+ имел адрес Ethereum, и вы отправили ему немного эфира. Наконец, вы создали транзакцию для вызова функции +withdraw+ и успешно запросили 0.1 эфира. Контракт проверил запрос и отправил вам 0.1 эфира с внутренней транзакцией.

Может показаться, что это не так уж много, но вы только что успешно взаимодействовали с программным обеспечением, которое управляет деньгами на децентрализованном мировом компьютере.

Мы будем гораздо больше программировать смарт-контракты в <<smart_contracts_chapter>> и узнаем о лучших практиках и соображениях безопасности в <<smart_contract_security>>.(((range="endofrange", startref="ix_02intro-asciidoc0")))
